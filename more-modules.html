<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="more-modules-and-libraries">More Modules and Libraries</h2>

<h3 id="tangent-ish-ppx_jane-and-deriving">Tangent-ish: <code>ppx_jane</code> and <code>deriving</code></h3>

<ul>
  <li>We briefly hit on <code>[@@deriving eq]</code> syntax in the <a href="variants.html">Variants lecture</a>
    <ul>
      <li>append to <code>type</code> declaration to get an <code>equal</code> function for free on our type.</li>
    </ul>
  </li>
  <li>Here cover the Jane Street <code>ppx_jane</code> version of <code>[@@deriving ...]</code></li>
  <li>Recall our genome type declaration with added <code>[@@deriving eq]</code> which made an <code>equal_nucleotide</code> function</li>
  <li>For the Jane Street equivalent just say <code>[@@deriving equal]</code> instead of <code>[@@deriving eq]</code></li>
</ul>

<pre><code class="language-ocaml">(* Needs #require "ppx_jane";; in top loop, 
   and (preprocess (pps (ppx_jane))) in as part of the library declaration *)
   (i.e. it is (library (name ..)  .. (preprocess ... )) - one of the library decl components)
# type nucleotide = A | C | G | T [@@deriving equal];;
type nucleotide = A | C | G | T
val equal_nucleotide : nucleotide -&gt; nucleotide -&gt; bool = fun
</code></pre>
<ul>
  <li>The <code>[@@zibbo...]</code> indicates the type declaration is processed by the macro named <code>ppx_zibbo</code></li>
  <li>The <code>equal</code> is a parameter to the macro, here it is which <code>deriving</code> extension is added</li>
  <li>The <code>[@@deriving equal]</code> in particular causes an <code>equal_nucleotide</code> function to be automatically generated</li>
  <li>Without this function we would have to use pattern matching to write our own equality.</li>
</ul>

<h4 id="composing-deriving-equal">Composing <code>deriving equal</code></h4>

<ul>
  <li>If we have an <code>xyy_equal</code> function on component types, <code>deriving</code> can derive <code>equal</code> for a type built from those components:<br />
```ocaml
    <h1 id="type-n_list--nucleotide-list-deriving-equal">type n_list = nucleotide list [@@deriving equal];;</h1>
    <p>type n_list = nucleotide list<br />
val equal_n_list : n_list -&gt; n_list -&gt; bool = fun</p>
    <h1 id="equal_n_list-aaa-aga">equal_n_list [A;A;A] [A;G;A];;</h1>
  </li>
  <li>: bool = false
    <h1 id="type-n_queue--nucleotide-queuet-deriving-equal">type n_queue = nucleotide Queue.t [@@deriving equal];;</h1>
    <p>type n_queue = nucleotide Core_kernel.Queue.t<br />
val equal_n_queue : n_queue -&gt; n_queue -&gt; bool = fun<br />
```</p>
  </li>
  <li>Notice that the <code>Core</code> libraries are designed to play well as they have <code>List.equal</code>, <code>Queue.equal</code> built in</li>
  <li>Generally for a component type that is the <code>t</code> of a module, the name looked for is <code>My_module.equal</code> instead of <code>t_equal</code></li>
  <li>Similarly, if we are making our own module with its carrier type <code>t</code> it will also generate <code>My_module.equal</code> if we use <code>[@@deriving equal]</code></li>
</ul>

<h3 id="some-other-useful-deriving-type-accessor-extensions-in-ppx_jane">Some other useful <code>@@deriving</code> type accessor extensions in ppx_jane</h3>

<ul>
  <li><code>sexp</code> generates S-expression printable representations of types which is handy for displaying data internals</li>
  <li>S-expressions are a general data format like JSON or XML, in fact they are the first such format</li>
  <li>For some reason the <code>Core</code> libraries make heavy use of S-expressions instead of JSON - a mistake really.</li>
  <li>It is not too hard to read S-expressions after a bit of staring<br />
```ocaml
    <h1 id="type-nucleotide--a--c--g--t-deriving-equal-sexp">type nucleotide = A | C | G | T [@@deriving equal, sexp];;</h1>
    <p>type nucleotide = A | C | G | T<br />
val equal_nucleotide : nucleotide -&gt; nucleotide -&gt; bool = fun<br />
val nucleotide_of_sexp : Sexp.t -&gt; nucleotide = fun<br />
val sexp_of_nucleotide : nucleotide -&gt; Sexp.t = fun<br />
 type n_list = nucleotide list [@@deriving equal, sexp];;<br />
type n_list = nucleotide list<br />
type n_list = nucleotide list<br />
val equal_n_list : n_list -&gt; n_list -&gt; bool = fun<br />
val n_list_of_sexp : Sexp.t -&gt; n_list = fun<br />
val sexp_of_n_list : n_list -&gt; Sexp.t = fun</p>
    <h1 id="sexp_of_n_list-agg">sexp_of_n_list [A;G;G];;</h1>
  </li>
  <li>: Sexp.t = (A G G) (* this is the “S-Expression” version of a list.. parens and spaces *)<br />
```</li>
  <li><code>[@@deriving compare]</code> is analogous to <code>equal</code> except it makes a <code>compare</code> function instead of <code>equal</code><br />
```ocaml
    <h1 id="type-nucleotide--a--c--g--t-deriving-compare">type nucleotide = A | C | G | T [@@deriving compare];;</h1>
    <p>type nucleotide = A | C | G | T<br />
val compare_nucleotide : nucleotide -&gt; nucleotide -&gt; int = fun</p>
    <h1 id="compare_nucleotide-a-c">compare_nucleotide A C;;</h1>
  </li>
  <li>: int = -1<br />
utop # compare_nucleotide C A;;</li>
  <li>: int = 1<br />
```</li>
  <li><code>Core</code> does have some libraries for dealing with JSON as well fortunately.</li>
  <li>For the homework there is a to/from JSON format function you can add to any type</li>
  <li>this will save wear and tear on your fingers, no need to convert.</li>
</ul>

<pre><code class="language-ocaml"># #require "ppx_deriving_yojson";; (* see the ppx_deriving_yojson docs linked in HW for `dune` use *)
# type nucleotide = A | C | G | T [@@deriving yojson];;
type nucleotide = A | C | G | T
val nucleotide_to_yojson : nucleotide -&gt; Yojson.Safe.t = fun
val nucleotide_of_yojson :
  Yojson.Safe.t -&gt; nucleotide Ppx_deriving_yojson_runtime.error_or = fun
</code></pre>

<h2 id="defining-modules-in-the-top-loop">Defining Modules in the top loop</h2>

<ul>
  <li>We will now cover how you can define modules in the top loop.</li>
  <li>The main reason we are covering this is it will help us understand nested modules and functors
    <ul>
      <li>generally the file-based method of defining a module we have done thus far is how modules are defined.</li>
    </ul>
  </li>
  <li>Basic idea to input a module in top-loop: write <code>module My_module = struct ... end</code> with file in the `..</li>
  <li><code>struct</code> stands for structure, modules used to be called that in OCaml; view a struct as = to a module.</li>
  <li>Modules are by default not expressions, so we normally can’t define with <code>let</code></li>
  <li>Simple set example put in top-loop syntax:</li>
</ul>

<pre><code class="language-ocaml"># module Simple_set = struct 
open Core
type 'a t = 'a list
let emptyset : 'a t = []
let add (x : 'a) (s : 'a t) = (x :: s)
let rec remove (x : 'a) (s: 'a t) (equal : 'a -&gt; 'a -&gt; bool) =
  match s with
  | [] -&gt; failwith "item is not in set"
  | hd :: tl -&gt;
    if equal hd x then tl
    else hd :: remove x tl equal
let rec contains (x: 'a) (s: 'a t) (equal : 'a -&gt; 'a -&gt; bool) =
  match s with
  | [] -&gt; false
  | hd :: tl -&gt;
    if equal x hd then true else contains x tl equal
end;;
module Simple_set :
  sig
    type 'a t = 'a list
    val emptyset : 'a t
    val add : 'a -&gt; 'a t -&gt; 'a t
    val remove : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; 'a t
    val contains : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; bool
  end
# Simple_set.emptyset;;
- : 'a list = []
</code></pre>

<ul>
  <li>Notice how it infers a module type (aka signature – <code>sig</code> at the start is for signature)</li>
  <li>We can also declare module types and explicitly declare along with the module</li>
  <li>Use <code>module type Type_name_here = ... type here ...</code> to declare module types:</li>
</ul>

<pre><code class="language-ocaml">module type Simple_set = (* module and module type namespaces are distinct, can re-use name *)
  sig
    type 'a t
    val emptyset : 'a t
    val add : 'a -&gt; 'a t -&gt; 'a t
    val remove : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; 'a t
    val contains : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; bool
  end
</code></pre>

<p>Then can replace <code>module Simple_set = struct .. end</code> with</p>
<pre><code class="language-ocaml">module Simple_set : Simple_set = struct ... end
</code></pre>

<p>and it will define the module with the above signature on it</p>

<h2 id="nested-modules">Nested modules</h2>

<ul>
  <li>OK generally we will use file-defined modules, why this detour into how to define them in top loop?</li>
  <li>Answer: the real use of the above syntax is it also lets us define <em>modules within modules</em> in files
    <ul>
      <li>which is in fact very useful</li>
    </ul>
  </li>
  <li>We are using many of those already, e.g. <code>Core.List.map</code> means <code>List</code> is just a module inside <code>Core</code>.</li>
  <li>Modules nest exactly as you would expect, just write a <code>module My_module = struct .. end</code> declaration<br />
 within a (file-based <em>or</em> top-loop-defined) module</li>
  <li>Here is an example
    <ul>
      <li>(note we will do top-loop version here, could remove top/bottom two lines and put in file)</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">module Super_simple_core = struct

  module Simple_set = struct (* insert above code here ... *) end

  module List = Core.List (* just borrow Core's list for our Super_simple_core *)
end
</code></pre>

<h3 id="basic-functors">Basic Functors</h3>

<ul>
  <li>Functors are simply parametric modules, i.e. functions from modules to modules</li>
  <li>They let us define a generic code library to which we can plug in some concrete code
    <ul>
      <li>in other words, just like what higher-order functions do except for modules</li>
    </ul>
  </li>
  <li>Like modules they are also “top-level-definable” only in basic OCaml
    <ul>
      <li>they are not expressions</li>
    </ul>
  </li>
</ul>

<h4 id="simple-functors-example">Simple Functors Example</h4>

<ul>
  <li>Lets fix the problem of the <code>equal</code> function needed as a parameter to <code>remove</code> and <code>contains</code> on our <code>Simple_set</code> module.</li>
</ul>

<pre><code class="language-ocaml">module type Eq = sig 
type t
val equal: t -&gt; t -&gt; bool 
end

module Simple_set_functor (M: Eq) = 
struct
open Core
type t = M.t list
let emptyset : t = []
let add (x : M.t) (s : t) = (x :: s)
let rec remove (x : M.t) (s: t) =
  match s with
  | [] -&gt; failwith "item is not in set"
  | hd :: tl -&gt;
    if M.equal hd x then tl
    else hd :: remove x tl
let rec contains (x: M.t) (s: t) =
  match s with
  | [] -&gt; false
  | hd :: tl -&gt;
    if M.equal x hd then true else contains x tl
end
</code></pre>

<ul>
  <li>Notice how the type that was polymorphic, <code>'a</code> in the original <code>Simple_set</code>, is <code>M.t</code> here – we are<br />
taking the type from the <code>Eq</code> module – that is the type we need, the type over the <code>equal</code> operation.</li>
  <li>
    <p>To use the functor, just define a specific module by applying the functor to a module that has a type <code>t</code> and a function <code>equal : t -&gt; t-&gt; bool</code>.</p>
  </li>
  <li>Alternate syntax for functors - anonymous form like with expression’s “<code>function x -&gt; ...</code>”</li>
</ul>

<pre><code class="language-ocaml">module Simple_set_functor = functor (M : Eq) -&gt; struct  (stuff above ...) end
</code></pre>
<ul>
  <li>(Can also make higher-order functors: pass and return functors from functors)</li>
</ul>

<h4 id="types-of-functors">Types of functors</h4>

<ul>
  <li>Functors also have types, OCaml inferred a type for <code>Simple_set_functor</code> but we can also declare it:</li>
</ul>

<pre><code class="language-ocaml"># module type SSF = functor (M : Eq) -&gt;
    sig
      type t = M.t list
      val emptyset : t
      val add : M.t -&gt; t -&gt; t
      val remove : M.t -&gt; t -&gt; t
      val contains : M.t -&gt; t -&gt; bool
    end;;
</code></pre>
<ul>
  <li>Observe the type is generally <code>functor (M : Module_type) -&gt; sig ... end</code></li>
  <li>Notice how the argument module <code>M</code> occurs in the result type since it has types in it</li>
  <li>Such a type is called a <em>dependent type</em></li>
</ul>

<h3 id="using-functors">Using functors</h3>

<ul>
  <li>Pass a module to a functor to make a module specializing the parameter to what was passed</li>
  <li>In other words, just like a function but on modules</li>
</ul>

<pre><code class="language-ocaml"># module String_set = Simple_set_functor(String);;
module String_set :
  sig
    type t = string list
    val emptyset : t
    val add : string -&gt; t -&gt; string list
    val remove : string -&gt; t -&gt; string list
    val contains : string -&gt; t -&gt; bool
  end
</code></pre>
<ul>
  <li>Note that we passed in a <code>String</code> module where the parameter had the <code>Eq</code> module type</li>
  <li><code>String.t</code> is the underlying type of the string, and <code>String.equal</code> exists as an equality operation on strings, so <code>String</code> matches the <code>Eq</code> module type</li>
  <li>(<code>utop</code> command <code>#show_module String</code> will dump the full module if you want to verify <code>t</code> and <code>equal</code> are there)</li>
  <li>Note <code>String</code> also has a whole <strong>ton</strong> of other functions, types, etc
    <ul>
      <li>but like with subclasses or Java interfaces you match if you have “at least” the stuff needed.</li>
    </ul>
  </li>
  <li>Here is one way you can test if a module matches a module type:</li>
</ul>

<pre><code class="language-ocaml"># module String2 = (String : Eq);;
module String2 : Eq
# module String2 : Eq = String;; (* Equivalent way to write the above *)
module String2 : Eq
</code></pre>
<ul>
  <li>This declares a new module <code>String2</code> which is <code>String</code> matched against the <code>Eq</code> type.</li>
  <li>
    <p>Note that <code>String2</code> is restricted to <em>only</em> have <code>t</code>/<code>equal</code> with this declaration (<code>String</code> of course keeps everything, no mutuation!)</p>
  </li>
  <li>Here is how we could instantiate the <code>Simple_set_functor</code> with our own data type</li>
</ul>

<pre><code class="language-ocaml"># #require "ppx_jane";;
# module Nucleotide = struct type t = A | C | G | T [@@deriving equal] end;;
module Nucleotide : sig type t = A | C | G | T val equal : t -&gt; t -&gt; bool end
# module Nuc_set = Simple_set_functor(Nucleotide);;
module Nuc_set :
  sig
    type t = Nucleotide.t list
    val emptyset : t
    val add : Nucleotide.t -&gt; t -&gt; Nucleotide.t list
    val remove : Nucleotide.t -&gt; t -&gt; Nucleotide.t list
    val contains : Nucleotide.t -&gt; t -&gt; bool
  end
</code></pre>

<ul>
  <li>Note this requires us to make a module out of our type</li>
  <li>(also note that we used <code>[@@deriving equal]</code> to make the <code>equal</code> for free)
    <ul>
      <li>(and note it is given the name <code>Nucleotide.equal</code> and not <code>Nucleotide.equal_nucleotide</code>, since it is in a module and is the type <code>t</code> there)</li>
    </ul>
  </li>
</ul>

<h3 id="cores-set-map-hash-table-etc"><code>Core</code>’s Set, Map, Hash table, etc</h3>

<ul>
  <li>The <code>Core</code> advanced data structures support something similar to what we did above
    <ul>
      <li>“plug in the comparison in an initialization phase and then forget about it”</li>
    </ul>
  </li>
  <li>Here for example is how you make a map where the key is a built-in type (which has an associated module)</li>
</ul>

<pre><code class="language-ocaml"># module FloatMap = Map.Make(Float);; (* Or Char/Int/String/Bool/etc *)
module FloatMap :
  sig ... end
</code></pre>

<ul>
  <li>Note it requires a bit more than just the type and comparison to be in <code>Float</code> for this to work</li>
  <li>to/from S-expression conversions needed; use <code>[@@deriving compare, sexp]</code> on your own type:</li>
</ul>

<pre><code class="language-ocaml">#require "ppx_jane";;
# module IntPair = struct
type t = int * int [@@deriving compare, sexp]
end;;
module IntPair :
  sig
    type t = int * int
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexplib0.Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
# module IPMap = Map.Make(IntPair);;
module IPMap :
  sig ... end
# module IPSet = Set.Make(IntPair);;  (* Sets in Core also need compare (sorts internally) *)
...
# IPSet.(empty |&gt; Fn.flip add (1,2) |&gt; Fn.flip add (3,2) |&gt; Fn.flip add (3,2) |&gt; to_list);;
- : IntPair.t list = [(1, 2); (3, 2)]
</code></pre>

<p>Observe that only non-parametric types can be keys for maps:</p>

<pre><code class="language-ocaml"># module FloatMap = Map.Make(List);;
Line 1, characters 27-31:
Error: Signature mismatch:
       ...
       Type declarations do not match:
         type 'a t = 'a list
       is not included in
         type t
       They have different arities.
       File "src/map_intf.ml", line 29, characters 2-35: Expected declaration
       File "src/list.mli", line 12, characters 0-48: Actual declaration
</code></pre>

<ul>
  <li>Mildly annoying solution: explictly make a module for the list type you care about:</li>
</ul>

<pre><code class="language-ocaml"># module SList = struct type t = string list [@@deriving compare,sexp] end;;
module SList :
  sig
    type t = string list
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
# module SListMap = Map.Make(SList);;
module SListMap :
  sig ... end
</code></pre>
<p>Simpler way to do above: can inline the module definition, no need to name it</p>
<pre><code class="language-ocaml"># module SListMap = Map.Make(struct type t = string list [@@deriving compare,sexp] end);;
module SListMap :
  sig .. end
</code></pre>
<ul>
  <li>The above is a map where the <em>keys</em> are lists of strings</li>
  <li>The above examples show how non-trivial data structures can be map keys</li>
  <li>Here is the opposite, how we can make e.g. a variant with maps in it.</li>
  <li>This assumes the keys are integer pairs, and the values can be any type (<code>'a</code>)</li>
</ul>

<pre><code class="language-ocaml"># type 'a intpairmaptree = Leaf | Node of ('a IPMap.t) * 'a intpairmaptree * 'a intpairmaptree;; 
type 'a intpairmaptree =
    Leaf
  | Node of 'a IPMap.t * 'a intpairmaptree * 'a intpairmaptree
</code></pre>

<h3 id="larger-example-using-coremap">Larger Example Using Core.Map</h3>
<ul>
  <li>We will go over the code of <a href="examples/school.ml">school.ml</a>, simple code that uses a <code>Core.Map</code>.</li>
  <li>Note that there is a fancier way than <code>Map.Make</code> using advanced features we have not covered yet: <em>first-class modules</em>.
    <ul>
      <li>We will peek at <a href="examples/cool_school.ml">cool_school.ml</a> which re-writes the <code>school.ml</code> example to use first-class modules</li>
      <li>The advantage of this code is you don’t need to make a new module for every type you use it at</li>
      <li>Imagine if for every <code>List</code> type we had to make an <code>IntList</code>, <code>StringList</code> etc module - painful!</li>
      <li>(<code>List</code> itself avoids this problem by not being comparison-friendly, we had to pass in <code>compare</code> to <code>List.sort</code> for example)</li>
    </ul>
  </li>
</ul>

<h3 id="a-few-other-module-features-include-and-with">A few other module features: <code>include</code> and <code>with</code></h3>

<h4 id="include"><code>include</code></h4>

<ul>
  <li><code>include</code> is pretty straightforward, it “copies/pastes” one module or module type’s definitions inside a new definition.
    <pre><code class="language-ocaml"># module Sized_set = struct 
include Simple_set 
let size (s : 'a t) = List.length s
end
</code></pre>
  </li>
  <li>This will make a new module <code>Sized_set</code> which is the same as <code>Simple_set</code> but with an added <code>size</code> function.</li>
  <li>Observe how <code>'a t</code> works to refer to a type in <code>Simple_set</code>, just like we had pasted all that stuff in.</li>
</ul>

<p>Similarly module types (and also functors) can use <code>include</code></p>

<pre><code class="language-ocaml">module type Size_set =
  sig
    include Simple_set
    val size : 'a t -&gt; int
  end
</code></pre>

<h4 id="with"><code>with</code></h4>

<ul>
  <li><code>with</code> is needed when you have a module type with an abstract <code>type</code> in it (so values in the type will be <code>&lt;abstr&gt;</code> to outsiders)</li>
  <li>
    <p><strong>but</strong> you need to see the concrete type.</p>
  </li>
  <li>Example: here is a type of modules which contain pairs (a non-useful but small example)</li>
  <li>Note we want this to be generic over any type of pair so we let <code>l</code> and <code>r</code> be undefined</li>
  <li>But, the downside is we are going to also make them <code>&lt;abstr&gt;</code> by doing this which is not always what we want…
    <pre><code class="language-ocaml">module type Pair_hidden = 
sig
  type l
  type r
  val left : (l * r) -&gt; l
  val right : (l * r) -&gt; r
end;;
</code></pre>
    <p>OK lets make a concrete example of the above on <code>int</code> and <code>string</code></p>
    <pre><code class="language-ocaml">module Pair = struct 
 type l = int
 type r = string
 let left ((l:l), (r:r)) = l
 let right ((l:l), (r:r)) = r
end;;
</code></pre>
    <p>Now the problem is if we put the above signature on the module, we hid too much!</p>
    <pre><code class="language-ocaml"># module Matched_pair = (Pair : Pair_hidden);;
module Matched_pair : Pair_hidden
# Matched_pair.left (4,"hi");;
Line 1, characters 19-20:
Error: This expression has type int but an expression was expected of type
       Matched_pair.l
</code></pre>
  </li>
</ul>

<p>The solution is you can instantiate abstract types in module types by <code>with</code>:</p>

<pre><code class="language-ocaml"># module Matched_pair = (Pair : Pair_hidden with type l = int with type r = string);;
module Matched_pair :
  sig
    type l = int
    type r = string
    val left : l * r -&gt; l
    val right : l * r -&gt; r
  end
# Matched_pair.left (4,"hi");;
- : int = 4
</code></pre>
<p>Usually <code>with</code> is inlined like above, but it is just defining a new module type:</p>

<pre><code class="language-ocaml"># module type Pair_unhidden = Pair_hidden with type l = int with type r = string;;
module type Pair_unhidden =
  sig
    type l = int
    type r = string
    val left : l * r -&gt; l
    val right : l * r -&gt; r
  end
</code></pre>

<h3 id="other-data-structures-in-core">Other Data Structures in <code>Core</code></h3>

<ul>
  <li><code>Core</code> has complete implementations of many classic data structures, many of which are built similarly with functor like <code>Map.Make</code></li>
  <li>Be careful on imperative vs functional, difference is not well-documented or consistently-named</li>
  <li>Functional data structures in <code>Core</code>:
    <ul>
      <li><code>Set</code>, <code>Map</code>, <code>Doubly_linked</code> (list), <code>Fqueue</code>, <code>Fdeque</code> (functional (double-ended) queue)</li>
    </ul>
  </li>
  <li>Imperative data structures:
    <ul>
      <li><code>Stack</code> and <code>Queue</code> as we previously discussed (which don’t need <code>Make</code>/<code>compare</code>), plus <code>Hash_queue</code>, <code>Hash_set</code>, <code>Hashtbl</code> (mutable hashed queue/set/map),  <code>Linked_queue</code>,  <code>Bag</code> (a multi-set)</li>
    </ul>
  </li>
</ul>

<h3 id="tangent--summary-of-important-directives-for-utop">Tangent:  Summary of Important Directives for <code>utop</code></h3>
<ul>
  <li><code>show_val</code> - shows the type of a value</li>
  <li><code>#show_type</code> - expands a type definition (if it has an expansion)</li>
  <li><code>#show_module</code> - shows all the elements inside a particular module <em>or functor</em></li>
  <li><code>#show_module_type</code> - as previous but for module types</li>
  <li><code>#show</code> - the above four condensed into one command</li>
  <li><code>#require</code> - loads a library (does not <code>open</code> it, just loads the module)</li>
  <li><code>#use "afile.ml"</code> - loads code file as if it was copied and pasted into the top loop.</li>
  <li><code>#mod_use</code> - like <code>#use</code> but loads the file like it was a module (name of file as a module name)</li>
  <li><code>#load "blah.cmo"</code>, <code>#load "blahlib.cma"</code> - load a compiled binary or library file.</li>
  <li><code>#use_output "dune top"</code> - run a command and assume output is top loop input commands.
    <ul>
      <li>The particular argument <code>dune top</code> here generates top loop commands to load the current project.</li>
      <li>If <code>dune utop</code> is not working this is very similar but less glitchy.</li>
    </ul>
  </li>
  <li><code>#directory adir</code> - adds <code>adir</code> to the list of directories to search for files.</li>
  <li><code>#pwd</code> - shows current working directory.</li>
  <li><code>#cd</code> - changes directory for loads etc.</li>
  <li><code>#trace afun</code> - subsequent calls and returns to <code>afun</code> will now be dumped to top level - a simple debugging tool.</li>
  <li><code>#help</code> - in case you forget one of the above</li>
</ul>

<p>Also, standard edit/search keys work in <code>utop</code>:</p>
<ul>
  <li>control-R searches for a previous input with a certin string in it</li>
  <li>control-P / control-N go up and down to edit, control-A is start of line, control-E is end, control-D deletes current</li>
  <li>up/down arrow go to previous/next inputs</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
