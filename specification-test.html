<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/syllabus.html">Syllabus</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="specification">Specification</h2>

<ul>
  <li>
    <p>Let us step back from syntax and look at the bigger picture</p>
  </li>
  <li>Specification: <em>what</em> the program should do</li>
  <li>Implementation: <em>how</em> it does it</li>
</ul>

<h3 id="why-specify">Why specify?</h3>

<ul>
  <li>You have to have at least some idea what your goal is before you start coding</li>
  <li>The more clear that goal is, the better chance you will make it</li>
</ul>

<h3 id="degrees-of-specification">Degrees of specification</h3>

<ul>
  <li>Requirements and Design documents: high-level informal descriptions of what the app should do
    <ul>
      <li>This is the classic form of specification in software engineering; far from code</li>
    </ul>
  </li>
  <li>Types, e.g. writing an <code>.mli</code> file before implementing the code
    <ul>
      <li>Much more precise than the previous in terms of code/spec relationship, but limited expressiveness</li>
    </ul>
  </li>
  <li>Tests
    <ul>
      <li>a test suite constitutes a specification on a finite window of behavior</li>
      <li>Can be very accurate on the cases listed, but could be woefully incomplete</li>
    </ul>
  </li>
  <li>Full logical assertions
    <ul>
      <li>e.g. <em>precondition</em> on a function that tree parameter is a binary tree (left values &lt; right values)</li>
      <li>e.g. <em>postcondition</em> that <code>List.sort</code> always returns a sorted list</li>
      <li>e.g. <em>invariants</em> on data structures such as a <code>Set</code> implementation which uses an underlying always-sorted list.</li>
      <li>More general than tests, but not necessarily verified</li>
    </ul>
  </li>
  <li>Verified assertions aka formal methods
    <ul>
      <li>after making the above logical assertions, <em>verify</em> the code meets the assertions</li>
      <li>now this is mostly research, but becoming more mainstream</li>
    </ul>
  </li>
</ul>

<h3 id="type-directed-programming">Type-directed programming</h3>

<p>Fact: types outline the “shape” of the code you need to write and so serve as a “structural” spec.</p>

<ul>
  <li>You have been doing type-directed programming, perhaps getting very annoyed whilst
    <ul>
      <li>With time the annoyance turns to thanks (we promise!)</li>
    </ul>
  </li>
  <li>Principle is: just to write code matching declared (or even inferred) type will get you well on the way to an implementation
    <ul>
      <li>type errors point to code errors to be fixed</li>
      <li>when the last type error drops, the code will often directly work</li>
    </ul>
  </li>
</ul>

<p>Review example: not bubbling up <code>option</code> or other wrapped results properly</p>

<pre><code class="language-ocaml"># let zadd l1 l2 = let l = List.zip l1 l2 in List.map ~f:(fun (x,y) -&gt; x+y) l;;
Line 1, characters 74-75:
Error: This expression has type ('a * 'b) list List.Or_unequal_lengths.t
       but an expression was expected of type 'c list
</code></pre>
<ul>
  <li>To solve this type error you will need to <code>match</code> on the result</li>
</ul>

<p>Review example: with partial parameters applied, remainder types hint at what is needed.</p>

<pre><code class="language-ocaml">let l = [[3;3]; [4;4]; 22;17] in
List.map l;;
- : f:(int list -&gt; '_weak1) -&gt; '_weak1 list = &lt;fun&gt;
</code></pre>
<ul>
  <li>The type shows that <code>f</code> needs to be a function taking an <code>int list</code> as argument.</li>
</ul>

<p>Review example: the type in an <code>.mli</code> file can direct your implementation, e.g. <code>map</code> on <code>dict</code> example from HW2</p>
<pre><code class="language-ocaml">val map : ('a -&gt; 'b) -&gt; 'a dict -&gt; 'b dict
</code></pre>
<ul>
  <li>Q: “how can I get a dict of <code>'b</code>’s built from a dict of <code>'a</code>’s here</li>
  <li>A: “Use the function from <code>'a</code> to <code>'b</code> on elements of <code>'a dict</code>.</li>
</ul>

<p>Extension example: add a new field to a record or a new variant case, chase the type errors to patch</p>

<pre><code class="language-ocaml">type party = Dem | Rep
type voter = { name : string; party: party }
let count_parties (l : voter list) =
  List.fold l ~init: (0,0) 
    ~f:(fun (cd,cr) -&gt; fun {party; _} -&gt; 
     match party with 
     | Dem -&gt; (cd+1, cr)
     | Rep -&gt; (cd, cr+1) );;
</code></pre>

<p>Adding a <code>Gre</code> for green party:</p>

<pre><code class="language-ocaml">type party = Dem | Rep | Gre
type voter = { name : string; party: party }
let count_parties (l : voter list) =
  List.fold l ~init: (0,0) 
    ~f:(fun (cd,cr) -&gt; fun {party; _} -&gt; 
     match party with 
     | Dem -&gt; (cd+1, cr)
     | Rep -&gt; (cd, cr+1) );;
Lines 6-8, characters 5-24:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Gre
type party = Dem | Rep | Gre
type voter = { name : string; party : party; }
val count_parties : voter list -&gt; int * int = &lt;fun&gt;
</code></pre>

<ul>
  <li>Shows a new <code>match</code> case is needed; in process of adding new case it will become clear a triple is also needed</li>
  <li>This example also shows why non-exhaustive pattern matches are bad: errors often lurk</li>
</ul>

<p>Conclusion: Don’t <strong>wrestle</strong> with OCaml’s types, <em>dance</em> with them</p>

<h3 id="preconditions-and-postconditions">Preconditions and Postconditions</h3>

<ul>
  <li>Types are fine for high-level structural information, but cannot express deeper properties.
    <ul>
      <li>“a function only takes non-negative input”</li>
      <li>“a function returns a sorted list”</li>
      <li>etc</li>
    </ul>
  </li>
</ul>

<p>Let us consider some preconditions and postconditions on the <code>Simple_set</code>:</p>

<pre><code class="language-ocaml">module Simple_set_functor (M: Eq) = 
struct
open Core
type t = M.t list
let emptyset : t = []
let add (x : M.t) (s : t) = (x :: s)
let rec remove (x : M.t) (s: t) =
  match s with
  | [] -&gt; failwith "item is not in set"
  | hd :: tl -&gt;
    if M.equal hd x then tl
    else hd :: remove x tl
let rec contains (x: M.t) (s: t) =
  match s with
  | [] -&gt; false
  | hd :: tl -&gt;
    if M.equal x hd then true else contains x tl
end
</code></pre>

<ul>
  <li>Precondition on <code>remove</code>: <code>s</code> is not empty (it would always fail otherwise)</li>
  <li>Stronger precondition: <code>contains x s</code> must hold</li>
  <li>Postcondition on <code>remove</code> for it returning set <code>s'</code>:  <code>not(contains x s')</code> - ??
    <ul>
      <li>No, this set data structure could be a multiset and this will not always hold!</li>
      <li>If we had this postcondition on our spec we would know our implementation failed</li>
    </ul>
  </li>
  <li>Postcondition on <code>add x s</code>: for the resulting set <code>s'</code>, <code>contains x s'</code> is true</li>
</ul>

<h4 id="assertions">Assertions</h4>

<ul>
  <li>OCaml <code>assert</code> can be placed in code to directly verify properties
    <ul>
      <li>program dies if the assertion fails, it should always hold</li>
    </ul>
  </li>
  <li>Example new version of <code>add</code> above:
    <pre><code class="language-ocaml">let add (x : M.t) (s : t) = 
let s' = (x :: s) in assert (contains x s')
</code></pre>
  </li>
  <li>Good for development mode, but not after deployment (slows things down)</li>
</ul>

<h3 id="data-structure-invariants">Data structure invariants</h3>

<ul>
  <li>It is often the case that there are additional restrictions on values allowed in a data structure type</li>
  <li>Example from <code>dict</code> on homework: <code>is_ordered</code> must hold for the binary tree.</li>
  <li>Such data structure invariants should be made clear in the code documentation</li>
</ul>

<h3 id="recursion-invariants">Recursion Invariants</h3>

<ul>
  <li>Recursion and other loops (e.g. in fold) is a prime place to assert invariants</li>
  <li>(Even if you don’t write them out, <em>thinking</em> of the invariants are critical to any recursive program)</li>
  <li>A standard invariant for recursive functions is that the recursive calls return what the outer function expected</li>
</ul>

<pre><code class="language-ocaml">let rec rev l = 
  match l with 
  | [] -&gt; []
  | x::xs -&gt; let rxs = rev xs in assert(Poly.(List.rev xs = rev xs)); rxs @ [x]
</code></pre>
<ul>
  <li>This assertion should never fail.</li>
  <li>Note however that we have to use the built-in <code>List.rev</code> to test our version - circular</li>
  <li>In general a big issue with specification is it is often hard to give a code-based definition of the spec.</li>
  <li>So, our main focus is on <em>partial</em> specs, give sanity conditions and not complete property</li>
</ul>

<h3 id="invariants-over-folds-etc">Invariants over folds etc</h3>

<ul>
  <li>In re-implementing some of the common <code>List</code> functions with <code>fold</code>s it helps to see invariant</li>
  <li>Folding left (<code>List.fold</code>):
    <ul>
      <li>Suppose we are at some arbitrary point processing the fold;</li>
      <li>assume accumulation <code>a</code> has “the result of the task” for all elements to the left</li>
      <li>require <code>~f</code> to then “do the task” to incorporate the current element <code>x</code></li>
      <li>also assume <code>a</code> is initially <code>init</code></li>
    </ul>
  </li>
  <li>Folding right: just flip the order the list is walked over in the above</li>
</ul>

<pre><code class="language-ocaml">let length l = List.fold ~init:0 ~f:(fun a _ -&gt; a+1) l
let rev l = List.fold ~init:[]  ~f:(fun a x -&gt; x::a) l 
let map ~f l = List.fold_right ~init:[]  ~f:(fun x a -&gt; (f x)::a) l
let filter ~f l = List.fold_right ~init:[] ~f:(fun x a -&gt; if f x then x::a else a) l
</code></pre>

<h3 id="formal-verification">Formal Verification</h3>

<ul>
  <li>We are not going to focus on this topic as it is not a part of mainstream software engineering (yet)</li>
  <li>But it is getting there and will become more and more common through your careers</li>
  <li>A simple view of what it is is the preconditions/postconditions/invariants/<code>asserts</code> above will be <strong>verified</strong> to always hold by a computer program.
    <ul>
      <li>Like how a compiler verifies the type information but on a much grander scale.</li>
      <li>Goal is to do this over a full, not partial, spec.</li>
    </ul>
  </li>
</ul>

<h3 id="specification-and-abstraction">Specification and Abstraction</h3>

<ul>
  <li>The better a module is specified the less the users need to know about the underlying implementration</li>
  <li>The built-in <code>Core.Map</code> etc types are examples where the users need to know nothing about the implementation</li>
  <li>But they are a bit idealistic as “everyone knows” what an e.g. Map should do</li>
  <li>Still, on your own libraries you can often abstract details behind a rich spec
    <ul>
      <li>and it will make it a lot easier for users, they can just think about the spec view.</li>
    </ul>
  </li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
  <li>Testing wears two very different but both very useful hats:
    <ol>
      <li>Implementation-based: find bugs in code, for example when you change code make sure you didn’t break it.</li>
      <li>Specification-based: use tests to define and refine what the code should do</li>
    </ol>
  </li>
  <li>When testing, wear both hats!!
    <ul>
      <li>Writing tests before fully coding the answer makes the tests serve as your “coding spec”</li>
      <li>Adding tests for corner cases will flesh out the spec</li>
      <li>Adding tests covering past bugs will make sure they are caught quickly next time</li>
    </ul>
  </li>
  <li>Another way this is phrased: black-box (spec) and glass-box (code-based) testing</li>
  <li>Black-box tests are those written against the spec</li>
  <li>Glass-box tests are in the context of bugs in the code and other code properties</li>
</ul>

<h3 id="standard-categories-of-tests">Standard categories of tests</h3>
<ul>
  <li><strong>Unit testing</strong>: what you have mainly done – test the small pieces of the app</li>
  <li><strong>Acceptance testing</strong>: test the bigger pieces.
    <ul>
      <li>For example testing your <code>cloc.exe</code> on a certain fixed directory tree.</li>
    </ul>
  </li>
  <li><strong>Random testing</strong> aka fuzz testing aka monkey testing aka property-based testing aka quickcheck: test on randomly generated inputs in some distribution</li>
</ul>

<h3 id="testing-and-coverage">Testing and coverage</h3>

<ul>
  <li>Code coverage is a great <em>glass-box</em> (impl-based) metric of how good your test suite is</li>
  <li>The simple idea of coverage: are there lines of your code that never get exercised by any of your tests?</li>
  <li>Coverage tools let you easily check this.</li>
  <li>We will show how the Bisect coverage tool can be used below</li>
</ul>

<h2 id="ounit2">OUnit2</h2>

<ul>
  <li>We have been using <code>OUnit2</code> mostly as a black box up to now</li>
  <li>Now we will go through the details, which are in fact very simple
    <ul>
      <li>There is not much in <code>OUnit2</code> per se, if you want something extra just write some higher-order functions to do it</li>
    </ul>
  </li>
  <li>Here is your standard simple <code>tests.ml</code> file, from the simple-set example:</li>
</ul>

<pre><code class="language-ocaml">open OUnit2
open Simple_set

let tests = "test suite for rev" &gt;::: [
  "empty"  &gt;:: (fun _ -&gt; assert_equal (emptyset) (emptyset));
  "3-elt"    &gt;:: (fun _ -&gt; assert_equal true (contains 5 (add 5 emptyset) (=)));
  "1-elt nested" &gt;:: (fun _ -&gt; assert_equal false (contains 5 (remove 5 (add 5 emptyset) (=))(=)));
]

let () = run_test_tt_main tests
</code></pre>

<ul>
  <li>The infix <code>&gt;::</code> operator takes a string (left) and a function with <code>_</code> argument (right) and builds a single test</li>
  <li>The <code>&gt;:::</code> operator simply takes an OCaml list of the above and builds a test suite</li>
  <li>Then, <code>OUnit2.run_test_tt_main tests</code> will run the suite <code>tests</code></li>
</ul>

<h4 id="how-the-tests-run">How the tests run</h4>
<ul>
  <li>The above <code>tests.ml</code> file is just defining an executable, like <code>cloc.ml/exe</code> on HW2</li>
  <li>Build and run the executable to run the tests</li>
  <li>Here is the dune build file for the simple set tests for example:</li>
</ul>

<pre><code class="language-scheme">(executable
  (name tests)
  (libraries
    ounit2
    simple_set
  ))

; dune rule so command line "dune runtest" (and "dune test") will run tests.
(rule
 (alias runtest)
 (action (chdir %{project_root}
  (run ./test/tests.exe))))
</code></pre>

<ul>
  <li>The alias rule also runs the tests after building them</li>
  <li>There in fact is a shorthand for the above in dune: replace <code>executable</code> with <code>test</code> and it makes an executable with the above alias to run tests:</li>
</ul>

<pre><code class="language-scheme">(test
  (name tests)
  (libraries
    ounit2
    simple_set
  ))
</code></pre>

<h3 id="tangent-defining-infix-operators">Tangent: defining infix operators</h3>

<ul>
  <li>The OUnit infix operators <code>&gt;::</code>/<code>&gt;:::</code> are just like <code>+</code>, <code>^</code> etc</li>
</ul>

<pre><code class="language-ocaml"># #require "ounit2";;
# open OUnit2;;
# (&gt;::) ;;
- : string -&gt; test_fun -&gt; test = &lt;fun&gt;
# (&gt;:::);;
- : string -&gt; test list -&gt; test = &lt;fun&gt;
</code></pre>

<ul>
  <li>There is no magic to this, you can also do it:</li>
</ul>

<pre><code class="language-ocaml">utop # let (^^) x y = x + y;;
val ( ^^ ) : int -&gt; int -&gt; int = &lt;fun&gt;
utop # 3 ^^ 5;;
- : int = 8
</code></pre>
<ul>
  <li>Note unlike in C++ we are not overloading operators, <code>^^</code> only works on two ints now.</li>
  <li>The old version of <code>^^</code> for printing just got nuked.</li>
  <li>So, new infix ops are always defined within a module to avoid overlap</li>
  <li>OCaml will eventually have overloading but it is still in the development pipe</li>
</ul>

<h3 id="building-test-suites-with-ounit">Building test suites with OUnit</h3>

<ul>
  <li>The OUnit philosophy is to use OCaml functions to pull out the repeated code in your suite</li>
  <li>Simple example of testing one function on a bunch of lists:</li>
</ul>

<pre><code class="language-ocaml"># let make_rev_test l = ("test test" &gt;:: (fun _ -&gt; assert_equal(List.rev @@ List.rev l) l));; 
val make_rev_test : 'a list -&gt; test = &lt;fun&gt;
</code></pre>

<pre><code class="language-ocaml">let make_rev_suite ll = 
  "suite of rev rev tests" &gt;::: List.map ll ~f:(fun l -&gt; make_rev_test l);;
val make_rev_suite : 'a list list -&gt; test = &lt;fun&gt;
</code></pre>

<pre><code class="language-ocaml">let s = make_rev_suite [[];[1;2;3];[2;44;2];[32;2;3;2;1]];;
let () = run_test_tt_main s;; (* DON'T actually do this line, runs OK but crashes utop! *)
</code></pre>

<ul>
  <li>In general you can build an arbitrarily big tree of tests with suites of suites etc
    <ul>
      <li>As can be seen above, a suite of tests just has type <code>test</code></li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">let s' = "id tests" &gt;::: 
  ["one" &gt;:: (fun _ -&gt; assert_equal (Fn.id 4) 4) ;
   "two" &gt;:: (fun _ -&gt; assert_equal (Fn.id "hello") "hello")];;
let suites = test_list [s;s'];; (* make suite of suites *)
let named_suites = "revrev and Fn.id" &gt;: suites (* any tree of tests can be named *)
</code></pre>

<p>Here is the type of <code>test</code> under the hood (from the docs) which should make clear why the above works:</p>

<pre><code class="language-ocaml">type test =
| TestCase of test_fun
| TestList of test list
| TestLabel of string * test
</code></pre>

<ul>
  <li>We will now take a brief pass through the <br />
OUnit <a href="https://gildor478.github.io/ounit/ounit2/index.html">Overview docs</a> and <a href="http://ocaml.github.io/platform-dev/packages/ounit/ounit.2.0.0/doc/oUnit/OUnit2/">API docs</a>
    <ul>
      <li>Testing if exception that should have been raised was raised: <code>assert_raises</code></li>
      <li>If you need fixed setup/teardown code bracketing a group of tests: <code>bracket</code>
        <ul>
          <li>useful for large mutable structures or external databases, etc</li>
        </ul>
      </li>
      <li>Testing applications (aka acceptance testing): <code>assert_command</code> to run your app
        <ul>
          <li>Really not OCaml-specific, tests input/output of any executable</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="bisect-for-ocaml-code-coverage">Bisect for OCaml code coverage</h3>

<ul>
  <li>The <code>bisect_ppx</code> preprocessor can decorate your code with one hit-bit per line
    <ul>
      <li>it can then show which lines are “hit” upon running your test suite</li>
    </ul>
  </li>
  <li>Add <code>(preprocess (pps bisect_ppx))</code> to library or executable declaration in <code>dune</code> to decorate</li>
  <li>Then do a <code>dune test</code> which will generate the low-level hit-lines data in a file.</li>
  <li>Shell command <code>bisect-ppx-report html</code> generates a pretty report showing which lines hit
    <ul>
      <li>open <code>_coverage/index.html</code> in your browser to see the report</li>
    </ul>
  </li>
  <li>See <a href="https://github.com/aantron/bisect_ppx">Bisect docs</a> for more details</li>
</ul>

<p>We will check how well my tests of the simple set example covered the code using Bisect</p>

<h3 id="qcheck-for-random-testing">QCheck for random testing</h3>

<ul>
  <li>The <code>QCheck</code> library lets you easily write random tests</li>
</ul>

<pre><code class="language-ocaml"># #require "qcheck";;
# let test =
  QCheck.Test.make ~count:1000 ~name:"list_rev_is_involutive"
   QCheck.(list small_nat)
   (fun l -&gt; List.equal (=) (List.rev (List.rev l)) l);;
# QCheck.Test.check_exn test;;
</code></pre>
<ul>
  <li>The novel bit is the <code>QCheck.(list small_nat)</code></li>
  <li>
    <p>This is specifying that the parameter <code>l</code> on the tests will get passed random lists of small natural numbers (i.e. non-negative <code>int</code>s)</p>
  </li>
  <li>OK lets make a bad reverse and repeat.</li>
</ul>

<pre><code class="language-ocaml">let bad_rev l = match l with 1::xs -&gt; [] | _ -&gt; List.rev l;;
... (re-enter test above using bad_rev) ...
# QCheck.Test.check_exn test;;
Exception:
test `list_rev_is_involutive` failed on ≥ 1 cases:
[1] (after 9 shrink steps)
</code></pre>

<ul>
  <li>this is reporting that it found the error.</li>
</ul>

<h3 id="the-details">The details</h3>

<ul>
  <li>We will take a run through the <a href="https://github.com/c-cube/qcheck">QCheck documentation</a></li>
  <li>It covers how to make random data in your own type, e.g. random trees</li>
  <li>It also covers how to package these up into your OUnit suite</li>
  <li>The full API is <a href="https://c-cube.github.io/qcheck/0.15/qcheck-core/QCheck/index.html">here</a></li>
</ul>

      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
