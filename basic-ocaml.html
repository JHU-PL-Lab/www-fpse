<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/syllabus.html">Syllabus</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="introduction-to-ocaml">Introduction to OCaml</h2>

<p>Installing: see <a href="https://pl.cs.jhu.edu/fpse/coding.html">the Coding page</a> for install instructions and lots of other information</p>

<h3 id="the-ecosystem-via-hello-world-in-ocaml">The Ecosystem via Hello World in OCaml</h3>

<p>In a file <code class="highlighter-rouge">helloworld.ml</code> type</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hw</span> <span class="o">=</span> <span class="s2">"hello"</span><span class="o">^</span><span class="s2">" world"</span>
</code></pre></div></div>
<ul>
  <li>Paste into <code class="highlighter-rouge">ocaml</code> then in <code class="highlighter-rouge">utop</code></li>
  <li>Save file in new directory, <code class="highlighter-rouge">ocamlc helloworld.ml</code></li>
  <li><code class="highlighter-rouge">./a.out</code> to run</li>
  <li>Nothing happens?  Because executables only interact by I/O (think Java, C, etc)</li>
  <li>Re-write to add
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_string</span> <span class="n">hw</span>
</code></pre></div>    </div>
  </li>
  <li>recompile and run: we get some output!</li>
</ul>

<h4 id="building-and-running-with-dune">Building and running with Dune</h4>

<ul>
  <li>In same directory, add a file <code class="highlighter-rouge">dune</code>:
    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">executable</span>
<span class="p">(</span><span class="nf">name</span> <span class="nv">helloworld</span><span class="p">)</span>
<span class="p">(</span><span class="nf">modules</span> <span class="nv">helloworld</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>This is the build file, like a <code class="highlighter-rouge">Makefile</code>.</li>
  <li>Now, type <code class="highlighter-rouge">dune build</code> to compile a standalone program like we did above.</li>
  <li>Then, run with <code class="highlighter-rouge">dune exec ./helloworld</code></li>
</ul>

<h4 id="adding-a-library">Adding a Library</h4>

<ul>
  <li>Lets make printing less primitive: use a <code class="highlighter-rouge">Core</code> library function, <code class="highlighter-rouge">printf</code></li>
  <li>Replace printing with line <code class="highlighter-rouge">Core.printf "the string is %s\n" hw</code></li>
  <li>Try building - gives an error</li>
  <li>Add line <code class="highlighter-rouge">(libraries core)</code> to dune file to fix</li>
  <li>Compile and run</li>
</ul>

<h4 id="exploring-basic-data-in-the-top-loop">Exploring Basic Data in the top loop</h4>

<ul>
  <li>We will use the <code class="highlighter-rouge">utop</code> top loop; the classic version is <code class="highlighter-rouge">ocaml</code> which has fewer bells and whistles</li>
  <li>See <a href="https://pl.cs.jhu.edu/fpse/coding.html">the Coding page</a> to install <code class="highlighter-rouge">utop</code>.  Note you need to also set up an <code class="highlighter-rouge">.ocamlinit</code> file as per that page</li>
  <li>
    <p>All the following are typed as input into <code class="highlighter-rouge">utop</code> with <code class="highlighter-rouge">;;</code> ending input.</p>
  </li>
  <li>Integers
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* give the value a name via let keyword. *)</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* can use x now *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="boolean-operations">Boolean operations</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="bp">false</span><span class="p">;;</span>
<span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span><span class="p">;;</span>
<span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* = not == for equality comparison *)</span>
<span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;;</span>  <span class="c">(* &lt;&gt; not != for not equal *)</span>
</code></pre></div></div>

<h4 id="other-basic-data--see-documentation-for-details">Other basic data – see documentation for details</h4>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span><span class="o">.</span><span class="mi">5</span><span class="p">;;</span> <span class="c">(* floats *)</span>
<span class="mi">4</span><span class="o">.</span><span class="mi">5</span> <span class="o">+.</span> <span class="mi">4</span><span class="o">.</span><span class="mi">3</span> <span class="c">(* operations are +. etc not just + which is for ints only *)</span>
<span class="mi">30980314323422</span><span class="nc">L</span><span class="p">;;</span> <span class="c">(* 64-bit integers *)</span>
<span class="k">'</span><span class="n">c'</span><span class="p">;;</span> <span class="c">(* characters *)</span>
<span class="s2">"and of course strings"</span><span class="p">;;</span>

</code></pre></div></div>
<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code class="highlighter-rouge">squared</code> with <code class="highlighter-rouge">x</code> its one parameter.  <code class="highlighter-rouge">return</code> is  implicit.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">squared</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;;</span> 
<span class="n">squared</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* to call a function -- separate arguments with S P A C E S *)</span>
</code></pre></div></div>
<ul>
  <li>OCaml has no <code class="highlighter-rouge">return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is automatically <strong>inferred</strong> and printed as domain <code class="highlighter-rouge">-&gt;</code> range</li>
  <li>OCaml functions in fact take only one argument - !  multiple arguments can be encoded by a trick (later)</li>
</ul>

<h4 id="fibonacci-series-example---0-1-1-2-3-5-8-13-">Fibonacci series example - <code class="highlighter-rouge">0 1 1 2 3 5 8 13 ...</code></h4>

<p>Let’s write a well-known function with recursion</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>     <span class="c">(* the "rec" keyword needs to be added to allow recursion *)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);;</span> <span class="c">(* notice again everything is an expression, no "return" *)</span>

<span class="n">fib</span> <span class="mi">10</span><span class="p">;;</span> <span class="c">(* get the 10th Fibonacci number *)</span>
</code></pre></div></div>

<h4 id="anonymous-functions">Anonymous functions</h4>

<ul>
  <li>Key to FP: functions are just expressions; put them in variables, pass and return from other functions, etc.</li>
  <li>Similar to lambdas in Python, Java, C++, etc - all are based on the lambda calculus *)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* normal add1 definition *)</span>
<span class="k">let</span> <span class="n">funny_add1</span> <span class="o">=</span> <span class="p">(</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span> <span class="c">(* "x" is argument here *)</span>
<span class="n">funny_add1</span> <span class="mi">3</span><span class="p">;;</span>
<span class="p">(</span><span class="n">funny_add1</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> 
<span class="p">((</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(*  a "-&gt;" function is an expression and can be used anywhere *)</span>
<span class="p">((</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(*  shorthand notation -- cut off the "ction" *)</span>
</code></pre></div></div>

<ul>
  <li>Multiple arguments - just leave spaces between multiple arguments</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="n">add</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="p">(</span><span class="n">add</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* same meaning as previous application -- two applications, " " associates LEFT *)</span>
<span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">3</span><span class="p">;;</span> <span class="c">(* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)</span>
<span class="n">add3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="n">add3</span> <span class="mi">20</span><span class="p">;;</span>
</code></pre></div></div>

<p>Conclusion: add is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, add is a <strong>higher-order function</strong>: it either takes a function as an argument, or returns a function as result.</p>

<p>Observe <code class="highlighter-rouge">int -&gt; int -&gt; int</code> is parenthesized as <code class="highlighter-rouge">int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add3</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);;</span>
<span class="n">add3</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than * *)</span>
<span class="n">add3</span> <span class="o">@@</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)</span>
</code></pre></div></div>

<h3 id="simple-structured-data-types-option-and-result">Simple Structured Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code class="highlighter-rouge">option</code> type.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Some</span> <span class="mi">5</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<ul>
  <li>all this does is “wrap” the 5 in the <code class="highlighter-rouge">Some</code> tag</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">None</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
</code></pre></div></div>

<ul>
  <li>Notice these are both in the <code class="highlighter-rouge">option</code> type .. either you have <code class="highlighter-rouge">Some</code> data or you have <code class="highlighter-rouge">None</code>.</li>
  <li>This type is very useful; here is a simple example.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nice_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<p>There is a downside with this though, you can’t just use <code class="highlighter-rouge">nice_div</code> like <code class="highlighter-rouge">/</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">14</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">option</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span>
</code></pre></div></div>

<p>This type error means the <code class="highlighter-rouge">+</code> lhs should be type <code class="highlighter-rouge">int</code> but is a <code class="highlighter-rouge">Some</code> value so is not an <code class="highlighter-rouge">int</code>.</p>

<p>Here is a non-solution to that:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">not_nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">47</span><span class="o">-</span><span class="mi">52</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="k">'</span><span class="n">a</span> <span class="n">option</span>
</code></pre></div></div>
<ul>
  <li>The <code class="highlighter-rouge">then</code> and <code class="highlighter-rouge">else</code> branches must return the same type, here they do not.</li>
</ul>

<h4 id="pattern-matching-first-example">Pattern matching first example</h4>

<p>Here is a real solution to the above issue:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span> <span class="c">(* i is bound to the result, 2 here *)</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"This should never happen, we divided by 2"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>
<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option types, via the <code class="highlighter-rouge">match</code> syntax.</li>
  <li><code class="highlighter-rouge">match</code> is similar to <code class="highlighter-rouge">switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>LHS in OCaml can be a general pattern</li>
  <li>Note that we turned <code class="highlighter-rouge">None</code> into an exception via <code class="highlighter-rouge">failwith</code>.</li>
</ul>

<h4 id="result">Result</h4>

<p>An “even nicer” version of the above would be to use the <code class="highlighter-rouge">result</code> type, which is very similar to option.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nicer_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Error</span> <span class="s2">"Divide by zero"</span> <span class="k">else</span> <span class="nc">Ok</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nicer_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>The <code class="highlighter-rouge">result</code> type is explicitly intended for this case of failure-result
    <ul>
      <li><code class="highlighter-rouge">Ok</code> means the normal result</li>
      <li><code class="highlighter-rouge">Error</code> is the error case, which unlike none can include failure data.</li>
    </ul>
  </li>
  <li>Again we can do the same kind of pattern match on <code class="highlighter-rouge">Ok/Error</code> as above.</li>
  <li>This is a “more well-typed” version of the C approach of returning <code class="highlighter-rouge">-1</code> or <code class="highlighter-rouge">NULL</code> to indicate failure.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nicer_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Ok</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
   <span class="o">|</span> <span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>

<p>Lastly, the function could itself raise an exception</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">div_exn</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"divide by zero is bad!"</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="n">div_exn</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
</code></pre></div></div>

<p>Which has the property of not needing a match on the result.</p>

<h3 id="lists">Lists</h3>

<p>Lists are pervasive in OCaml; easy to create and manipulate</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span> <span class="s2">"b"</span><span class="p">;</span> <span class="s2">"c"</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="s2">"a"</span><span class="p">];;</span> <span class="c">(* errors - All elements must have same type - HOMOGENEOUS *)</span>
<span class="k">let</span> <span class="n">l5</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">;;</span> <span class="c">(* empty list *)</span>
</code></pre></div></div>

<h4 id="building-lists">Building lists</h4>

<p>Lists are represented internally as BINARY TREES with left child a leaf.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">::</span> <span class="n">l1</span><span class="p">;;</span> <span class="c">(* "::" is 'consing' an element to the front - fast *)</span>
<span class="mi">0</span> <span class="o">::</span> <span class="p">(</span><span class="mi">1</span> <span class="o">::</span> <span class="p">(</span><span class="mi">2</span> <span class="o">::</span> <span class="p">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="p">)));;</span> <span class="c">(* equivalent to the above *)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span> <span class="c">(* appending lists - slower *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">6</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">z</span><span class="p">;;</span>
<span class="n">z</span><span class="p">;;</span> <span class="c">(* Observe z itself did not change -- lists are immutable in OCaml *)</span>
</code></pre></div></div>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span>  <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">rev</span> <span class="n">xs</span> <span class="o">@</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="p">;;</span>
<span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* = 1 :: ( 2 :: ( 3 :: [])) *)</span>
</code></pre></div></div>

<ul>
  <li>Correctness of a recursive function by induction: assume recursive call does what you expect in arguing it is overall correct.</li>
  <li>For this example, can assume <code class="highlighter-rouge">rev xs</code> always reverses the tail of the list.</li>
  <li>Given that fact, <code class="highlighter-rouge">rev xs @ [x]</code> should clearly reverse the whole list.</li>
  <li>QED, the function is proved correct! (actually partially correct, it could also loop forever)</li>
</ul>

<h4 id="immutable-data-structures-in-functional-programming">Immutable Data Structures in Functional Programming</h4>

<ul>
  <li>By default, data structures are immutable</li>
  <li>A change is instead implemented as rebuilding the whole list from scratch</li>
  <li>This style of programming: “Data structure corresponds to control flow”</li>
</ul>

<p>Example: zero out all the negative elements in a list of numbers.</p>

      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
