<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/assignment6.html">Assignment 6</a></li>
                <li><a href="/fpse/assignments/assignment7.html">Assignment 7</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1192943254">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="side-effects">Side effects</h2>

<ul>
  <li>Side effects are operations which do more than return a result: mutate, I/O, exceptions, threads, etc.</li>
  <li>So far we have not seen many side effects but a few have snuck in: printing, file input, exceptions</li>
  <li>Principle of idiomatic OCaml (and style for this class): <strong>avoid effects</strong>, unless they are a real improvement, or a necessity (e.g. I/O).</li>
  <li>Reminder: don’t use mutation on your homeworks, and limit use of other effects as well.</li>
</ul>

<p>Side effects of OCaml include</p>
<ul>
  <li>Mutatable state - <em>changing</em> the contents of a memory location intead of making a new one
    <ul>
      <li>Three built-in sorts in OCaml: references, mutable record fields, and arrays.</li>
      <li>Plus many libraries: <code>Stack</code>, <code>Queue</code>, <code>Hashtbl</code>, <code>Hash_set</code>, etc</li>
      <li>Faster because rebuilding avoided, but slower due to impossibility of sharing sub-components</li>
    </ul>
  </li>
  <li>Exceptions (we saw a bit of this already, <code>failwith "ill-formed"</code> etc)</li>
  <li>Input/output (in basic modules lecture we looked at file input and results printing for example)</li>
  <li>Concurrency and parallelism (will cover later)</li>
</ul>

<h3 id="state">State</h3>
<ul>
  <li>Variables in OCaml are <em>never</em> directly mutable</li>
  <li>But, they can hold a <em>reference</em> to memory that can be mutated</li>
  <li>i.e. it is only indirect mutability - variable itself can’t change, but what it points to can.</li>
</ul>

<h3 id="mutable-references">Mutable References</h3>

<ul>
  <li>References, mutable references, refs, reference cells, and cells are all more or less synomyms</li>
  <li><code>'a ref</code> is a type, and <code>val ref : 'a -&gt; 'a ref</code> is a function that makes a ref cell.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* have to declare initial value when creating *)</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div></div>

<p>Meaning of the above: <code>x</code> forevermore (i.e. forever unless shadowed) refers to a fixed cell.  The <strong>contents</strong> of that fixed cell, currently <code>4</code>, can change, but not <code>x</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>

<span class="o">#</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">ref</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="kt">int</span>
</code></pre></div></div>

<ul>
  <li>Addition with <code>(+)</code> works on integers, but <code>x</code> is of type <code>int ref</code>.</li>
  <li>Get the value from a ref cell with the <code>!</code> prefix operator.
    <ul>
      <li>It simply gets the (immutable) value that the ref cell points to.</li>
      <li>It does <em>not</em> get the memory location that it points to.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* use !x to get out the value; similar to *x in C *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* assignment with (:=). x must be a ref cell.  Returns () - only performs side effect *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>

<span class="o">#</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* Mutation happened to contents of cell x *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div></div>

<p>And <code>!</code> does <strong>not</strong> return the memory location to which a ref cell points, so this is a syntax error:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span>
<span class="k">let</span> <span class="o">!</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span> <span class="c">(* syntax error. !x is a value, not a valid assignee *)</span>
</code></pre></div></div>

<p>In this way, <code>!x</code> in OCaml is not like <code>*x</code> in C.</p>

<h3 id="tangent-on-unit">Tangent on unit</h3>

<ul>
  <li><code>unit</code> is a terminal type. Only one value called <code>()</code> has type <code>unit</code>, and it is totally useless.</li>
  <li>All you can do is pass it around.</li>
  <li>So what is it good for?</li>
</ul>

<p>Since <code>()</code> is useless, any function that returns it is either useless <strong>or</strong> performs a side effect. It is almost certainly the latter.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">print_endline</span><span class="p">;;</span> <span class="c">(* returns unit; has the side effect of printing *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="p">(</span><span class="o">:=</span><span class="p">);;</span> <span class="c">(* returns unit; has the side effect of assignment to LHS *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">ref</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">set</span><span class="p">;;</span> <span class="c">(* returns unit, so it has the side effect of assignment *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">:</span><span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li><code>Hashtbl.set</code> returns <code>unit</code> so it must be a mutable data structure.</li>
  <li>On the flip side, functions taking <code>unit</code> as argument are often also only performing side effects.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">create</span><span class="p">;;</span> <span class="c">(* takes unit, so it is making a new mutable data structure *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Stack</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span><span class="p">;;</span> <span class="c">(* Note the convention of putting a space here *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak1</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Stack</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span> <span class="c">(* Its abstract, we can't see internals.. more on weak types soon *)</span>
</code></pre></div></div>

<h3 id="variables-are-still-themselves-immutable">Variables are still themselves immutable</h3>

<ul>
  <li>To be clear, <code>let</code> doesn’t turn into a mutation operator with <code>ref</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">!</span><span class="n">x</span><span class="p">;;</span>

<span class="n">x</span> <span class="o">:=</span> <span class="mi">234</span><span class="p">;;</span>
<span class="n">f</span><span class="bp">()</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* shadows previous x definition, NOT an assignment to x !! *)</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span> <span class="c">(* 234, not 6 *)</span>
</code></pre></div></div>

<h3 id="null-or-nil-initial-cell-contents-in-ocaml-and-weakly-polymorphic-types">Null or Nil initial cell contents in OCaml, and Weakly Polymorphic types</h3>

<ul>
  <li>If you don’t yet have a well-formed initial value, use an <code>option</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak1</span> <span class="n">option</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">None</span><span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Note the type here, <code>'_weak1 option ref</code>, this is a <em>weakly polymorphic type</em></li>
  <li>Which really is not polymorphic at all - what it means is the type can be only a single type
    <ul>
      <li>which is not known yet</li>
    </ul>
  </li>
  <li>To the first order, a weakly polymorphic type is like a “Schrodinger’s type”.
    <ul>
      <li>It is ready to be any (single) type until it is observed (i.e. used), after which it is fixed.</li>
    </ul>
  </li>
  <li>If you think about it, there is no other possibility, can’t put int and string in same cell
    <ul>
      <li>would not know the type when taking out of cell.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="p">;;</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span> <span class="c">(* now we see '_weak1 was touched and its now forevermore an int *)</span>
</code></pre></div></div>

<ul>
  <li>At various points OCaml will infer only weak types on certain things</li>
  <li>Most of the time it is because it would be incorrect not to</li>
  <li>But occasionally OCaml is too dumb to realize things are not weak
    <ul>
      <li>there are advanced workarounds for this case which we will not cover</li>
    </ul>
  </li>
</ul>

<p>The weak types are here so that we cannot do this:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span> <span class="c">(* Puts Schrodinger's cat in the box. It is weakly typed, not polymorphic. *)</span>

<span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="mi">5</span> <span class="c">(* Observes Schrodinger's cat: fixes the weak type to be int *)</span>

<span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="s2">"hello"</span> <span class="c">(* type error! x is not a string ref *)</span>
</code></pre></div></div>

<h3 id="mutable-records">Mutable Records</h3>

<ul>
  <li>Along with refs we can declare some record fields <code>mutable</code></li>
  <li><code>'a ref</code> is really implemented by a mutable record with one field, contents:</li>
  <li><code>'a ref</code> in fact abbreviates the type <code>{ mutable contents: 'a }</code>
    <ul>
      <li>And <code>ref</code> is a just a function to make creation convenient.</li>
      <li>And <code>(:=)</code> is just a function to make assignment convenient.</li>
      <li>And <code>(!)</code> is just a function to make reading convenient and explicit.</li>
    </ul>
  </li>
  <li>The keyword mutable on a record field means it can mutate</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};;</span> <span class="c">(* 100.0% identical to `let x = ref 4` *)</span>


<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">7</span><span class="p">;;</span>  <span class="c">(* identical to `x := 6` *)</span>


<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* identical to `!x + 1` *)</span>
</code></pre></div></div>

<h3 id="declaring-mutable-record-types">Declaring Mutable Record Types</h3>

<ul>
  <li>Default on each field is that the value is <em>immutable</em></li>
  <li>Put <code>mutable</code> qualifier on each field that you want to mutate</li>
  <li>Principle of least mutability: you should only put <code>mutable</code> on fields you <strong>have</strong> to mutate</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mutable_point</span> <span class="o">=</span> <span class="p">{</span> <span class="k">mutable</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">float</span> <span class="p">;</span> <span class="k">mutable</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">float</span> <span class="p">};;</span>

<span class="k">let</span> <span class="n">translate</span> <span class="n">p</span> <span class="n">dx</span> <span class="n">dy</span> <span class="o">=</span>
  <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+.</span> <span class="n">dx</span><span class="p">);</span> <span class="c">(* observe use of ";" here to sequence effects *)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+.</span> <span class="n">dy</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">};;</span> <span class="c">(* new mutable record *)</span>

<span class="n">translate</span> <span class="n">mypoint</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span> <span class="c">(* changes fields inside mypoint *)</span>

<span class="n">mypoint</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Here, the <code>x</code> and <code>y</code> fields of the point are mutable, but the point as a whole you cannot swap in a different point for.</p>
  </li>
  <li>
    <p>Note that <code>;</code> is the standard sequencing operator</p>
    <ul>
      <li>But in OCaml everything is an expression so its a bit non-standard</li>
      <li><code>e ; e'</code> is roughly the same as <code>let () = e in e'</code>: evaluate <code>e</code>, ignore result, evaluate <code>e;</code>.</li>
      <li><code>(5 + 2); true</code> will give you a warning since <code>5</code> is not of type <code>unit</code></li>
      <li>The reasoning here is if you are using <code>;</code> the first thing must be a side effect
        <ul>
          <li>and, as we covered above those functions will nearly always return <code>unit</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tree-with-mutable-subtrees">Tree with mutable subtrees</h3>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* version using ref: *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree_ref</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="o">|</span> <span class="nc">MNode</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="n">ref</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="n">ref</span><span class="p">;;</span>
<span class="c">(* But, use this type with mutable records - no `!` needed: *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="o">|</span> <span class="nc">MNode</span> <span class="k">of</span> <span class="p">{</span> <span class="n">data</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="p">;</span> <span class="k">mutable</span> <span class="n">left</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="p">;</span> <span class="k">mutable</span> <span class="n">right</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="p">};;</span>
</code></pre></div></div>

<ul>
  <li>Note that in this <code>mtree</code> we can only mutate the subtrees, <em>not</em> the data</li>
  <li>Also, cannot replace a leaf at top of tree with a non-leaf.</li>
  <li>The idea is to put mutablility only where you are doing mutation, no more no less.</li>
  <li>So if the tree structure never changes but the node values can, only make the <code>data</code> mutable.</li>
</ul>

<p>Example use: mutate left subtree</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">mt</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="p">};;</span>
<span class="k">val</span> <span class="n">mt</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">}</span>

<span class="o">#</span> <span class="k">match</span> <span class="n">mt</span> <span class="k">with</span> 
<span class="o">|</span> <span class="nc">MLeaf</span> <span class="o">-&gt;</span> <span class="bp">()</span>
<span class="o">|</span> <span class="nc">MNode</span> <span class="p">({</span><span class="n">data</span><span class="p">;</span><span class="n">left</span><span class="p">;</span><span class="n">right</span><span class="p">}</span> <span class="k">as</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="c">(* "as" captures it all under one name *)</span>
  <span class="n">r</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;-</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>

<span class="c">(* Verify that mt mutated *)</span>
<span class="o">#</span> <span class="n">mt</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">mtree</span> <span class="o">=</span>
<span class="nc">MNode</span>
 <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">3</span>
 <span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="p">}</span>
 <span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="physical-equality">Physical equality</h3>

<ul>
  <li>Occasionally in imperative programs you need to check for “same pointer”.
    <ul>
      <li>It’s also useful in functional programming for fast comparison when data is shared.</li>
      <li>There’s no need to compare entire structures if their memory addresses are identical.</li>
    </ul>
  </li>
  <li><code>phys_equal</code> is <code>Core</code>’s notion for for “same pointer” (use <code>==</code> in non-Core).</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">phys_equal</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* memory layout of 2 is always the same *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;;</span> <span class="c">(* make y an alias for x *)</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>

<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">x</span> <span class="n">y</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span> <span class="c">(* same pointer *)</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* new cell. totally different from x and y *)</span>
<span class="k">val</span> <span class="n">z</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>

<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">x</span> <span class="n">z</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span> <span class="c">(* different pointers *)</span>
</code></pre></div></div>

<p>We can use <code>phys_equal</code> to see that data is shared in functional data structures.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">big_list</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">init</span> <span class="mi">10000</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="p">;;</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">::</span> <span class="n">big_list</span> <span class="p">;;</span>

<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">::</span> <span class="n">big_list</span> <span class="p">;;</span>

<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">x</span> <span class="n">y</span> <span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span> 

<span class="o">#</span> <span class="n">phys_equal</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl_exn</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl_exn</span> <span class="n">y</span><span class="p">)</span> <span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span> <span class="c">(* the tails are physically identical, they are big_list *)</span>
</code></pre></div></div>

<h3 id="control-structures-to-help-with-mutution">Control structures to help with mutution</h3>

<ul>
  <li>As mentioned above, side effecting operations usually return <code>unit</code></li>
  <li>But occasionally they don’t, and you might want to use <code>;</code> with them which OCaml will complain about:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">incr</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span> 
    <span class="k">let</span> <span class="n">incr</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">count</span> <span class="o">:=</span> <span class="o">!</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">!</span><span class="n">count</span> <span class="k">in</span>
    <span class="n">incr</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>

<span class="o">#</span> <span class="n">incr</span><span class="bp">()</span> <span class="p">;</span> <span class="n">incr</span><span class="bp">()</span><span class="p">;;</span> <span class="c">(* Increment twice *)</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">6</span><span class="o">:</span>
<span class="nc">Warning</span> <span class="mi">10</span><span class="o">:</span> <span class="n">this</span> <span class="n">expression</span> <span class="n">should</span> <span class="n">have</span> <span class="k">type</span> <span class="kt">unit</span><span class="o">.</span>
<span class="o">...</span>
</code></pre></div></div>

<ul>
  <li>Gives a warning since first <code>incr()</code> does not return <code>unit</code></li>
  <li>To silence warning (once you are clear you are doing the right thing):</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">ignore</span> <span class="p">(</span><span class="n">incr</span> <span class="bp">()</span><span class="p">);</span> <span class="n">incr</span> <span class="bp">()</span> <span class="c">(* or, let _ = incr () in incr () *)</span>
</code></pre></div></div>

<ul>
  <li><code>for</code> and <code>while</code> loops are useful with mutable state</li>
  <li>But they are almost always a code smell in OCaml, usually a data structure iterator like map fold etc is better.</li>
  <li>Here is a <code>while .. do .. done</code> loop; <code>for</code> syntax also standard</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span> <span class="k">in</span>
<span class="k">while</span> <span class="o">!</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">do</span>
  <span class="n">printf</span> <span class="s2">"count is %i ...</span><span class="se">\n</span><span class="s2">"</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">done</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Fact: <code>while</code> loops are useless without mutation: would either never loop or infinitely loop</li>
  <li>Same for <code>e1 ; e2</code> –  if <code>e1</code> has no side effects, you may as well delete it. It is dead code!</li>
  <li>Remember that <code>e1; e2</code> is exactly the same as writing <code>let () = e1 in e2</code></li>
</ul>

<h3 id="arrays">Arrays</h3>
<ul>
  <li>They are mutable, and they are also constant time to access nth element unlike lists</li>
  <li>But, extending an array is inefficient: cannot share sub-array due to mutation</li>
  <li>And, sub-components of different arrays cannot be shared since they may change</li>
  <li>Entered and shown as <code>[| 1; 2; 3 |]</code> (added “<code>|</code>”) in top-loop to distinguish from lists.</li>
  <li>Have to be initialized before using
    <ul>
      <li>In general, there is no such thing as “uninitialized” in OCaml.</li>
      <li>If you need “undefined”/”null” array, make it an <code>int option array</code> and init to <code>None</code>’s.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arrhi</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="mi">10</span> <span class="s2">"hi"</span><span class="p">;;</span> <span class="c">(* length and initial value *)</span>

<span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">];;</span> <span class="c">(* make a literal array *)</span>

<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">);;</span> <span class="c">(* access (unfortunately already used [] for lists so a bit ugly) *)</span>

<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">55</span><span class="p">;;</span> <span class="c">(* update like with mutable record fields *)</span>

<span class="n">arr</span><span class="p">;;</span> <span class="c">(* see that arr has changed *)</span>

<span class="c">(* Don't use for loops for arrays, use your favorite iterators: *)</span>
<span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;;</span> <span class="c">(* standard map - produces a new array *)</span>

<span class="nn">Array</span><span class="p">.</span><span class="n">map_inplace</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;;</span> <span class="c">(* This *changes* the array using the map function *)</span>

<span class="c">(* Here are some conversions *)</span>
<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">to_list</span> <span class="n">a</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>

<ul>
  <li>As mentioned earlier, exceptions are powerful but dangerous
    <ul>
      <li>They are OK if they are always handled close to when they are raised</li>
      <li>If the handler is far away it can lead to buggy code</li>
      <li>We will aim for idiomatic use of OCaml exceptions in FPSE: local necessary ones only.</li>
    </ul>
  </li>
  <li><code>Core</code> discourages over-use of exceptions in its library function signatures
    <ul>
      <li>Avoid the <code>blah_exn</code> library functions unless the handler is close by</li>
    </ul>
  </li>
</ul>

<p>There are a few simple built-in exceptions which we used some already:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">failwith</span> <span class="s2">"Oops"</span><span class="p">;;</span> <span class="c">(* Generic code failure - exception is named Failure *)</span>
<span class="n">invalid_arg</span> <span class="s2">"This function works on non-empty lists only"</span><span class="p">;;</span> <span class="c">(* Invalid_argument exception *)</span>
</code></pre></div></div>

<p>Also there are library functions we covered that raise exceptions</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"length mismatch in zip_exn: 2 &lt;&gt; 3"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="ocaml-syntax-for-defining-raising-and-handling-exceptions">OCaml syntax for defining raising and handling exceptions</h3>

<ul>
  <li>New exception names need to be declared via <code>exception</code> like <code>type</code>s needs to be declared</li>
  <li>Unfortunately, oCaml types do not include what exceptions a function may raise
    <ul>
      <li>an outdated aspect of OCaml; even Java has this with <code>raises</code> on method declarations</li>
    </ul>
  </li>
  <li>The value returned by an exception is very similar in looks to a variant.
    <ul>
      <li>(tangent: under the hood, the <code>exn</code> type is an extensible variant)</li>
    </ul>
  </li>
</ul>

<p>Extend the <code>exn</code> type with your exception using the <code>exception</code> keyword.</p>
<ul>
  <li>Everything following the <code>exception</code> keyword is just like a variant constructor declaration.</li>
  <li>There is no need for <code>of</code> if you don’t want data in your exception, just like a variant with no payload (e.g. <code>None</code>).</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">exception</span> <span class="nc">Boom</span> <span class="k">of</span> <span class="kt">string</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">_</span> <span class="o">=</span> <span class="k">raise</span> <span class="o">@@</span> <span class="nc">Boom</span> <span class="s2">"keyboard on fire"</span><span class="p">;;</span> <span class="c">(* raise is ultimately how all exceptions are raised *)</span>

<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span> <span class="c">(* this raises the exception *)</span>

<span class="k">let</span> <span class="n">g</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">try</span> <span class="n">f</span> <span class="bp">()</span>
  <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Boom</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">"exception Boom raised with payload string </span><span class="se">\"</span><span class="s2">%s</span><span class="se">\"\n</span><span class="s2">"</span> <span class="n">s</span>
<span class="p">;;</span>

<span class="n">g</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="mutating-data-structures-in-core">Mutating data structures in <code>Core</code></h3>

<ul>
  <li>The <code>Stack</code> and <code>Queue</code> modules in <code>Core</code> are <em>mutable</em> data structures.</li>
  <li>(There are no immutable stack/queue libraries in <code>Core</code> - just use <code>list</code>s)</li>
  <li>(There is also <code>Hash_set</code> which is a (hashed) mutable set and <code>Hashtbl</code> which is a mutable hashtable; more on those later)</li>
  <li>Here is a simple example of playing around with a <code>Stack</code>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">create</span><span class="bp">()</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak1</span> <span class="nn">Core</span><span class="p">.</span><span class="nn">Stack</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span> <span class="c">(* Stack.t is the underlying implementation and is hidden *)</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span> <span class="c">(* returns unit because s is mutated *)</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello again"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello one more time"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">to_list</span> <span class="n">s</span><span class="p">;;</span> <span class="c">(* a handy function to see what is there; top on left *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"hello one more time"</span><span class="p">;</span> <span class="s2">"hello again"</span><span class="p">;</span> <span class="s2">"hello"</span><span class="p">]</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">"hello one more time"</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop_exn</span> <span class="n">s</span><span class="p">;;</span> <span class="c">(* exception raised if empty here *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"hello again"</span> <span class="c">(* s changed from the last pop, so this pop is different! *)</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop_exn</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"hello"</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>

<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">exists</span> <span class="n">s</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">is_substring</span> <span class="n">s</span> <span class="s2">"time"</span><span class="p">);;</span> <span class="c">(* Stack has folds, maps, etc too *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
</code></pre></div></div>

<h3 id="summing-up-effects-with-an-example-a-parentheses-matching-function">Summing Up Effects With an Example: A Parentheses Matching Function</h3>

<ul>
  <li>To show how to use effects and some of the trade-offs, we look at a small example</li>
  <li>See file <a href="../examples/random-examples/matching.ml">matching.ml</a> which has several versions of a simple parenthesis matching function</li>
  <li>It shows uses of <code>Stack</code>, and some trade-offs of using exceptions vs option type.</li>
  <li>Lastly there is a pure functional version which is arguably simpler</li>
  <li>Yes, you <strong>don’t</strong> need that mutation!</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
