<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1191913911">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="side-effects">Side effects</h2>

<ul>
  <li>Side effects are operations which do more than return a result</li>
  <li>So far we have not seen many side effects but a few have snuck in: printing, file input, exceptions</li>
  <li>Principle of idiomatic OCaml (and style for this class): <strong>avoid effects</strong>, unless they are a real improvement.</li>
</ul>

<p>Side effects of OCaml include</p>
<ul>
  <li>Mutatable state - <em>changing</em> the contents of a memory location intead of making a new one
    <ul>
      <li>Three built-in sorts in OCaml: references, mutable record fields, and arrays.</li>
      <li>Plus many libraries: <code>Stack</code> etc</li>
    </ul>
  </li>
  <li>Exceptions (we saw a bit of this already, <code>failwith "ill-formed"</code> etc)</li>
  <li>Input/output (in basic modules lecture we looked at file input and results printing for example)</li>
  <li>Concurrency and parallelism (will cover later)</li>
</ul>

<h3 id="state">State</h3>
<ul>
  <li>Variables in OCaml are <em>still</em> not directly mutable</li>
  <li>But, they can hold a <em>reference</em> to mutable memory (and a way to mutate said reference)</li>
  <li>i.e. it is only indirect mutability - variable itself can’t change, but what it points to can.</li>
  <li>OCaml invariant: items are immutable unless their mutability is explicitly declared</li>
</ul>

<h3 id="mutable-references">Mutable References</h3>

<ul>
  <li>References, mutable references, refs, reference cells, and cells are all more or less synomyms</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* have to declare initial value when creating *)</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div></div>

<p>Meaning of the above: x forevermore (i.e. forever unless shadowed) refers to a fixed cell.  The <strong>contents</strong> of that fixed call can change, but not x.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">ref</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="kt">int</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* need !x to get out the value; parallels *x in C *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* assignment - x must be a ref cell.  Returns () - only performs side effect *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* Mutation happened to contents of cell x *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
<span class="o">#</span> 
</code></pre></div></div>

<h4 id="null-or-nil-initial-cell-contents-in-ocaml-and-weakly-polymorphic-types">Null or Nil initial cell contents in OCaml, and Weakly Polymorphic types</h4>

<ul>
  <li>If you don’t yet have a well-formed initial value, use an <code>option</code>:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="p">;;</span> <span class="c">(* Use an option type if initial value not known yet *)</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak1</span> <span class="n">option</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">None</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Note the type here, <code>'_weak1 option ref</code>, this is a <em>weakly polymorphic type</em></li>
  <li>Which really is not polymorphic at all - what it means is the type can be only a single type
    <ul>
      <li>which is not known yet</li>
    </ul>
  </li>
  <li>If you think about it, there is no other possibility, can’t put int and string in same cell
    <ul>
      <li>would not know the type when taking out of cell.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">x</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="mi">3</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="o">!</span><span class="n">x</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">3</span> <span class="c">(* `'_weak1` = `int` now, permanently *)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak2</span> <span class="n">option</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">None</span><span class="p">}</span> <span class="c">(* next one is `'_weak2` etc *)</span>
</code></pre></div></div>

<ul>
  <li>At various points OCaml will infer only weak types on certain things</li>
  <li>Most of the time it is because it would be incorrect not to</li>
  <li>But occasionally OCaml is too dumb to realize things are not weak
    <ul>
      <li>there are some workarounds for this case</li>
    </ul>
  </li>
</ul>

<h3 id="mutable-records">Mutable Records</h3>

<ul>
  <li>Along with refs we can make some record fields mutable</li>
  <li><code>'a ref</code> is really implemented by a mutable record with one field, contents:</li>
  <li><code>'a ref</code> abbreviates the type <code>{ mutable contents: 'a }</code></li>
  <li>The keyword mutable on a record field means it can mutate</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">};;</span> <span class="c">(* identical to x's definition above *)</span>
<span class="n">x</span> <span class="o">:=</span> <span class="mi">6</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">&lt;-</span> <span class="mi">7</span><span class="p">;;</span>  <span class="c">(* same effect as previous line: backarrow updates a field *)</span>

<span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span>
<span class="n">x</span><span class="o">.</span><span class="n">contents</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* same effect as previous line *)</span>
</code></pre></div></div>
<h4 id="declaring-mutable-record-types">Declaring Mutable Record Types</h4>

<ul>
  <li>Default on each field is the value will be <em>immutable</em></li>
  <li>Put <code>mutable</code> qualifier on each field that you want to mutate</li>
  <li>Principle of least mutability: only put <code>mutable</code> on fields you <strong>have</strong> to mutate</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">mutable_point</span> <span class="o">=</span> <span class="p">{</span> <span class="k">mutable</span> <span class="n">x</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span> <span class="k">mutable</span> <span class="n">y</span><span class="o">:</span> <span class="kt">float</span> <span class="p">};;</span>
<span class="k">let</span> <span class="n">translate</span> <span class="n">p</span> <span class="n">dx</span> <span class="n">dy</span> <span class="o">=</span>
  <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+.</span> <span class="n">dx</span><span class="p">);</span> <span class="c">(* observe use of ";" here to sequence effects *)</span>
  <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+.</span> <span class="n">dy</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">mypoint</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="p">};;</span>
<span class="n">translate</span> <span class="n">mypoint</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span>
<span class="n">mypoint</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="tree-with-mutable-subtrees">Tree with mutable subtrees</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* version using ref: *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="o">|</span> <span class="nc">MNode</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="n">ref</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="n">ref</span><span class="p">;;</span>
<span class="c">(* But, this type would be more readable with mutable record - no `!` needed: *)</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MLeaf</span> <span class="o">|</span> <span class="nc">MNode</span> <span class="k">of</span> <span class="p">{</span> <span class="n">data</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">;</span> <span class="k">mutable</span> <span class="n">left</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span><span class="p">;</span> <span class="k">mutable</span> <span class="n">right</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">mtree</span><span class="p">};;</span>
</code></pre></div></div>

<ul>
  <li>Note that in this <code>mtree</code> we can only mutate the subtrees, <em>not</em> the data</li>
  <li>Also, cannot replace a leaf at top of tree with a non-leaf.</li>
  <li>The idea is to put mutablility only where you are doing mutation, no more no less.</li>
</ul>

<p>Example use: mutate right tree</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">mt</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">};;</span>
<span class="k">val</span> <span class="n">mt</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">mtree</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">}</span>
<span class="o">#</span> <span class="k">match</span> <span class="n">mt</span> <span class="k">with</span> 
<span class="o">|</span> <span class="nc">MLeaf</span> <span class="o">-&gt;</span> <span class="bp">()</span>
<span class="o">|</span> <span class="nc">MNode</span> <span class="p">({</span><span class="n">data</span><span class="p">;</span><span class="n">left</span><span class="p">;</span><span class="n">right</span><span class="p">}</span> <span class="k">as</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;-</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">};;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="n">mt</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">mtree</span> <span class="o">=</span>
<span class="nc">MNode</span>
 <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MNode</span> <span class="p">{</span><span class="n">data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">left</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">;</span> <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">};</span>
  <span class="n">right</span> <span class="o">=</span> <span class="nc">MLeaf</span><span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>Note the use of the <code>... as r</code> in the pattern, sometimes something needs a name that didn’t have one</li>
  <li>And of course notice that <code>mt</code> actually <em>changed</em> here unlike with immutables</li>
</ul>

<h4 id="variables-are-still-themselves-immutable">Variables are still themselves immutable</h4>

<ul>
  <li>To be clear, <code>let</code> doesn’t turn into a mutation operator with <code>ref</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">f</span> <span class="bp">()</span> <span class="o">=</span> <span class="o">!</span><span class="n">x</span><span class="p">;;</span>

<span class="n">x</span> <span class="o">:=</span> <span class="mi">234</span><span class="p">;;</span>
<span class="n">f</span><span class="bp">()</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">6</span><span class="p">;;</span> <span class="c">(* shadows previous x definition, NOT an assignment to x !! *)</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span> <span class="c">(* 234, not 6 *)</span>
</code></pre></div></div>

<h3 id="physical-equality">Physical equality</h3>

<ul>
  <li>Occasionally in imperative programs you need to check for “same pointer”</li>
  <li><code>phys_equal</code> is <code>Core</code> notion for for “same pointer” (use <code>==</code> in non-Core)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">phys_equal</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">y</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">x</span> <span class="n">y</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span> <span class="c">(* same pointer *)</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">z</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">4</span><span class="p">}</span>
<span class="o">#</span> <span class="n">phys_equal</span> <span class="n">x</span> <span class="n">z</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span> <span class="c">(* different pointers *)</span>
</code></pre></div></div>

<h4 id="control-structures-to-help-with-mutution">Control structures to help with mutution</h4>

<ul>
  <li>Sequencing via “<code>;</code>” becomes useful with side effects</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_string</span> <span class="s2">"hi"</span><span class="p">;</span> <span class="n">print_string</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Observe that operations that only have a side effect return <code>() : unit</code>
    <ul>
      <li><code>:=</code>, <code>&lt;-</code>, <code>print</code>ing, etc</li>
      <li>But sometimes operators will both have effects and return something</li>
      <li>Sometimes need to sequence that and you may get an annoying warning if so:</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">incr</span> <span class="o">=</span> 
<span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span> 
<span class="k">let</span> <span class="n">incr</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">count</span> <span class="o">:=</span> <span class="o">!</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">!</span><span class="n">count</span> <span class="k">in</span> <span class="n">incr</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">incr</span><span class="bp">()</span> <span class="p">;</span> <span class="n">incr</span><span class="bp">()</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">6</span><span class="o">:</span>
<span class="nc">Warning</span> <span class="mi">10</span><span class="o">:</span> <span class="n">this</span> <span class="n">expression</span> <span class="n">should</span> <span class="n">have</span> <span class="k">type</span> <span class="kt">unit</span><span class="o">.</span>
<span class="o">...</span>
</code></pre></div></div>

<ul>
  <li>Gives a warning since it is concerned that the first incr does not return unit.</li>
  <li>This warning is actually good most of the time in fact, it means <code>;</code> was used incorrectly</li>
  <li>To silence warning (once you are clear you are doing the right thing):</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">ignore</span><span class="p">(</span><span class="n">incr</span><span class="bp">()</span><span class="p">)</span> <span class="p">;</span> <span class="n">incr</span><span class="bp">()</span> <span class="c">(* or, can use let _ = incr() in incr() *)</span>
</code></pre></div></div>

<ul>
  <li><code>for</code> and <code>while</code> loops are useful with mutable state</li>
  <li>But, don’t fall back into old state habits; good OCaml style is functional by default</li>
  <li>You hardly ever for or while, usually use a list or data structure iterator like map fold etc.</li>
  <li>Here is a <code>while .. do .. done</code> loop; <code>for</code> syntax also standard</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span> <span class="k">in</span>
<span class="k">while</span> <span class="o">!</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">do</span>
  <span class="n">printf</span> <span class="s2">"count is %i ...</span><span class="se">\n</span><span class="s2">"</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">done</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Fact: while loops are useless without mutation: would either never loop or infinitely loop</li>
  <li>Same for <code>e1 ; e2</code> –  if <code>e1</code> has no side effects may as well delete it, it is dead code!</li>
  <li>Note that <code>e1; e2</code> is equivalent to <code>let () = e1 in e2</code></li>
</ul>

<h3 id="arrays">Arrays</h3>
<ul>
  <li>Entered and shown as <code>[| 1; 2; 3 |]</code> (added “<code>|</code>”) in top-loop to distinguish from lists.</li>
  <li>Have to be initialized before using
    <ul>
      <li>In general, there is no such thing as “uninitialized” in OCaml.</li>
      <li>If you need “undefined”/”null”, make it an <code>int option array</code> and init to <code>None</code>’s.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arrhi</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="o">~</span><span class="n">len</span><span class="o">:</span><span class="mi">10</span> <span class="s2">"hi"</span><span class="p">;;</span> <span class="c">(* length and initial value *)</span>
<span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">];;</span> <span class="c">(* make a literal array *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">);;</span> <span class="c">(* access (unfortunately already used [] for lists so a bit ugly) *)</span>
<span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">55</span><span class="p">;;</span> <span class="c">(* update *)</span>
<span class="n">arr</span><span class="p">;;</span>
<span class="c">(* Of course there are many library functions over Array including map fold etc *)</span>
<span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;;</span> <span class="c">(* standard map - produces a new array *)</span>
<span class="nn">Array</span><span class="p">.</span><span class="n">map_inplace</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;;</span> <span class="c">(* This *changes* the array based on map-function *)</span>
<span class="c">(* Here are some conversions *)</span>
<span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">to_list</span> <span class="n">a</span><span class="p">;;</span>
</code></pre></div></div>

<h3 id="exceptions">Exceptions</h3>

<ul>
  <li>As mentioned earlier, exceptions are powerful but dangerous
    <ul>
      <li>They are OK if they are always handled very close to when they are raised</li>
      <li>If the handler is far away it can lead to buggy code</li>
      <li>We will aim for idiomatic use of OCaml exceptions in FPSE: local necessary ones only.</li>
    </ul>
  </li>
  <li><code>Core</code> discourages over-use of exceptions in its library function signatures
    <ul>
      <li>Avoid the <code>blah_exn</code> library functions unless the handler is close by</li>
    </ul>
  </li>
</ul>

<p>There are a few simple built-in exceptions which we used some already:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">failwith</span> <span class="s2">"Oops"</span><span class="p">;;</span> <span class="c">(* Generic code failure - exception is named Failure *)</span>
<span class="n">invalid_arg</span> <span class="s2">"This function works on non-empty lists only"</span><span class="p">;;</span> <span class="c">(* Invalid_argument exception *)</span>
</code></pre></div></div>

<p>Also there are library functions we covered that raise exceptions</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"length mismatch in zip_exn: 2 &lt;&gt; 3"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="ocaml-syntax-for-defining-raising-and-handling-exceptions">OCaml syntax for defining raising and handling exceptions</h3>
<ul>
  <li>New exception names need to be declared via <code>exception</code> like <code>type</code>s needs to be declared</li>
  <li>Unfortunately types do not include what exceptions a function will raise
    <ul>
      <li>an outdated aspect of OCaml</li>
    </ul>
  </li>
  <li>The value returned by an exception is very similar in looks to a variant.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">exception</span> <span class="nc">Boom</span> <span class="k">of</span> <span class="kt">string</span><span class="p">;;</span> <span class="c">(* Note like with variants the `of` is optional, no payload required *)</span>

<span class="k">let</span> <span class="n">f</span> <span class="n">_</span> <span class="o">=</span> <span class="k">raise</span> <span class="o">@@</span> <span class="nc">Boom</span> <span class="s2">"keyboard on fire"</span><span class="p">;;</span> <span class="c">(* raise is ultimately how all exceptions are raised *)</span>
<span class="n">f</span> <span class="bp">()</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">g</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">try</span> <span class="n">f</span> <span class="bp">()</span>
  <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Boom</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">"exception Boom raised with payload string </span><span class="se">\"</span><span class="s2">%s</span><span class="se">\"\n</span><span class="s2">"</span> <span class="n">s</span>
<span class="p">;;</span>
<span class="n">g</span> <span class="bp">()</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Exceptions are in fact first-class data, all of the single type <code>exn</code></li>
  <li>But, this feature is rarely useful.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">ex</span> <span class="o">=</span> <span class="nc">Boom</span> <span class="s2">"oops"</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">ex</span> <span class="o">:</span> <span class="n">exn</span> <span class="o">=</span> <span class="nc">Boom</span><span class="p">(</span><span class="s2">"oops"</span><span class="p">)</span>
<span class="o">#</span> <span class="k">raise</span> <span class="n">ex</span><span class="p">;;</span>
<span class="nc">Exception</span><span class="o">:</span> <span class="nc">Boom</span><span class="p">(</span><span class="s2">"oops"</span><span class="p">)</span><span class="o">.</span>
</code></pre></div></div>

<h3 id="mutating-data-structures-in-core">Mutating data structures in <code>Core</code></h3>

<ul>
  <li>The <code>Stack</code> and <code>Queue</code> modules in <code>Core</code> are <em>mutable</em> data structures.</li>
  <li>(There are no immutable libraries for stack/queue - just use <code>list</code>s)</li>
  <li>(There is also <code>Hash_set</code> which is a (hashed) mutable set and <code>Hashtbl</code> which is a mutable hashtable; more on those later)</li>
  <li>Here is a simple example of playing around with a <code>Stack</code> for example.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">create</span><span class="bp">()</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">s</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak3</span> <span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span> <span class="c">(* Stack.t is the underlying implementation and is hidden *)</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello again"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">s</span> <span class="s2">"hello one more time"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">to_list</span> <span class="n">s</span><span class="p">;;</span> <span class="c">(* a handy function to see what is there; top on left *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"hello one more time"</span><span class="p">;</span> <span class="s2">"hello again"</span><span class="p">;</span> <span class="s2">"hello"</span><span class="p">]</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">"hello one more time"</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop_exn</span> <span class="n">s</span><span class="p">;;</span> <span class="c">(* exception raised if empty here *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"hello again"</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop_exn</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">exists</span> <span class="n">s</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">is_substring</span> <span class="n">s</span> <span class="s2">"time"</span><span class="p">);;</span> <span class="c">(* Stack has folds, maps, etc too *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</code></pre></div></div>

<h3 id="summing-up-effects-a-parentheses-matching-function">Summing Up Effects: A Parentheses Matching Function</h3>

<ul>
  <li>To show how to use effects and some of the trade-offs, we look at a small example</li>
  <li>See file <a href="../examples/matching.ml">matching.ml</a> which has several versions of a simple parenthesis matching function</li>
  <li>It shows uses of <code>Stack</code>, and some trade-offs of using exceptions vs option type.</li>
  <li>Lastly there is a pure functional version which is arguably simpler</li>
  <li>Yes you <strong>don’t</strong> need that mutation!</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
