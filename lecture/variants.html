<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://campuswire.com/c/G2FCCFD2B/feed">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h3 id="variants">Variants</h3>

<ul>
  <li>Variants build or-data (this or this or this); records build and-data (this and this and this)</li>
  <li>They are the fundamental data constructors</li>
  <li>We start with variants</li>
</ul>

<h3 id="variants-1">Variants</h3>
<ul>
  <li>The <code>option</code> and <code>result</code> types we have been using are simple forms of <em>variant types</em></li>
  <li>Variants let your data be one of several forms (either-or), with a label wrapping the data indicating the sort</li>
  <li>They are related to <code>union</code> types in C or <code>enums</code> in Java, but are more safe than C and more general than Java</li>
  <li>Like OCaml lists and tuples they are by default immutable</li>
</ul>

<p>Example variant type for doing mixed arithmetic (integers and floats)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ff_num</span> <span class="o">=</span> <span class="nc">Fixed</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Floating</span> <span class="k">of</span> <span class="kt">float</span><span class="p">;;</span>  <span class="c">(* read "|" as "or" *)</span>

<span class="nc">Fixed</span><span class="p">(</span><span class="mi">5</span><span class="p">);;</span> <span class="c">(* tag 5 as a Fixed *)</span>
<span class="nc">Floating</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span> <span class="c">(* tag 4.0 as a Floating *)</span>
</code></pre></div></div>

<ul>
  <li>Each case of the variant is wrapped with a ‘Constructor’ which serves for both
    <ul>
      <li>Constructing values of the variant type</li>
      <li>inspecting them by pattern matching</li>
    </ul>
  </li>
  <li>Constructors must start with a Capital Letter to distinguish from variables</li>
  <li>Variants must be declared but once declared type inference can infer them.</li>
  <li>The <code>of</code> indicates what type is under the wrapper</li>
  <li>Note constructors look like functions but they are <strong>not</strong> – you always need to give the argument</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ff_as_int</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span>    <span class="c">(* variants fit well into pattern matching syntax *)</span>
    <span class="o">|</span> <span class="nc">Floating</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">int_of_float</span> <span class="n">z</span><span class="p">;;</span>

<span class="n">ff_as_int</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">5</span><span class="p">);;</span>
</code></pre></div></div>

<p>A non-trivial function using the above variant type</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ff_add</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">n1</span><span class="o">,</span> <span class="n">n2</span> <span class="k">with</span>    <span class="c">(* note use of pair here to parallel-match on two variables  *)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Fixed</span> <span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span>  <span class="nc">Floating</span><span class="p">(</span><span class="kt">float</span> <span class="n">i1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span> <span class="c">(* need to coerce *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="kt">float</span> <span class="n">i2</span><span class="p">)</span>  <span class="c">(* ditto *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span>
<span class="p">;;</span>

<span class="n">ff_add</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">123</span><span class="p">)</span> <span class="p">(</span><span class="nc">Floating</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>No data item?  leave off the <code>of</code>.</li>
  <li>Multiple data items in a single variant clause?  Wrap with a tuple (or record once we cover them):</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">complex</span> <span class="o">=</span> <span class="nc">CZero</span> <span class="o">|</span> <span class="nc">Nonzero</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">com</span> <span class="o">=</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">zer</span> <span class="o">=</span> <span class="nc">CZero</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">ocaml_annoyance</span> <span class="o">=</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span> <span class="c">(* this is a parsing error; use @@ instead of " " *)</span>
</code></pre></div></div>

<h4 id="an-example-of-variants-plus-list-libraries">An Example of Variants plus List. libraries</h4>

<ul>
  <li>Here is a small Hamming distance calculator for DNA.</li>
  <li>Observe the <code>[@@deriving equal]</code>, this is a <em>macro</em> (called a “ppx extension” in OCaml)</li>
  <li>It automatically generates a function <code>equal_nucleotide</code> (<code>equal_the-types-name-here</code> in general)</li>
  <li>You will need to use this with <code>Core</code> since regular <code>=</code> will not work on <code>nucleotide</code>s.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Example derived from 
   https://exercism.io/tracks/ocaml/exercises/hamming/solutions/afce117bfacb41cebe5c6ebb5e07e7ca
   This code needs a #require "ppx_jane";; in top loop to load ppx extension for @@deriving equal 
   Or, in a dune file it will need   (preprocess (pps ppx_deriving.eq)) added to the library decl *)</span>

<span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="p">]</span>

<span class="k">let</span> <span class="n">hamming_distance</span> <span class="p">(</span><span class="n">left</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="p">(</span><span class="n">right</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="p">((</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span><span class="p">)</span><span class="o">=</span>
  <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">left</span><span class="o">,</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">right</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">"left and right strands must be of equal length"</span> <span class="c">(* "when" allows additional constraints *)</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="nc">Ok</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="n">equal_nucleotide</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span> <span class="c">(* _ is wild card match *)</span>
             <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="n">left</span> <span class="n">right</span><span class="p">)))</span> <span class="c">(* We already know this never fails - OK to _exn *)</span>

<span class="k">let</span> <span class="n">hamm_example</span> <span class="o">=</span> <span class="n">hamming_distance</span> <span class="p">[</span><span class="nc">A</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">C</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">T</span><span class="p">;</span><span class="nc">T</span><span class="p">]</span> <span class="p">[</span><span class="nc">A</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">G</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">C</span><span class="p">;</span><span class="nc">T</span><span class="p">]</span>
</code></pre></div></div>

<p>All the parens above are very hard to read, use pipes instead:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hamming_distance</span> <span class="p">(</span><span class="n">left</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="p">(</span><span class="n">right</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="p">((</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span><span class="p">)</span><span class="o">=</span>
  <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">left</span><span class="o">,</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">right</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="k">when</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">"left and right strands must be of equal length"</span> <span class="c">(* "when" allows additional constraints *)</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="n">left</span> <span class="n">right</span> 
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="n">equal_nucleotide</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span> 
      <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> 
      <span class="o">|&gt;</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">Ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">(* Unfortunately we can't just pipe to `Ok` since `Ok` is not a function in OCaml - make it one here *)</span>
</code></pre></div></div>

<h4 id="parametric-variant-types">Parametric variant types</h4>

<p>Here is the system’s declaration of the <code>option</code> type – the <code>#show_type</code> top loop directive (or just <code>#show</code>) will print it:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="n">option</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
</code></pre></div></div>
<ul>
  <li>The <code>'a</code> here is a <em>parameter</em>, which gets filled in by a concrete type to make an actual type.</li>
  <li>e.g. <code>Some("hello") : string option</code> – the <code>string</code> fills in the parameter <code>'a</code></li>
  <li><code>None : 'a option</code> type means instantiate the <code>'a</code> parameter with polymorphic/generic <code>'a</code></li>
  <li>This may have been more clear if OCaml used function notation for these types, e.g.<br />
 <code>type option('a) = None | Some of 'a</code> and  <code>Some("hello") : option(string)</code></li>
</ul>

<p>And here is <code>result</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="n">result</span><span class="p">;;</span>
<span class="k">type</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Error</span> <span class="k">of</span> <span class="k">'</span><span class="n">b</span>
</code></pre></div></div>

<ul>
  <li>Same idea but <em>a pair</em> of type parameters; <code>'b</code> is the type of the <code>Error</code>.</li>
  <li>Observe <code>Ok(4) : (int, 'a) result</code> and <code>Error("bad") : ('a, string) result</code></li>
</ul>

<h4 id="recursive-data-structures">Recursive data structures</h4>
<ul>
  <li>A common use of variant types: self-referential data structures</li>
  <li>Functional programming is fantastic for computing over tree-structured data</li>
  <li>Recursive types can refer to themselves in their own definition
    <ul>
      <li>similar in spirit to how C structs can be recursive (but, no pointers needed here)</li>
    </ul>
  </li>
  <li>Unlike with functions, no need for <code>rec</code> (in fact can use <code>nonrec</code> to let OCaml know it is <em>not</em> recursive)</li>
</ul>

<p>Homebrew lists as a warm-up - the built-in <code>list</code> type is in fact not needed</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">homebrew_list</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">homebrew_list</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">hb_eg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">)));;</span> <span class="c">(* analogous to 3 :: 5 :: 7 :: [] = [3;5;7] *)</span>
</code></pre></div></div>
<p>Coding over homebrew lists is basically identical to built-in lists.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">homebrew_map</span> <span class="p">(</span><span class="n">ml</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">homebrew_list</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">b</span> <span class="n">homebrew_list</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ml</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Mt</span> <span class="o">-&gt;</span> <span class="nc">Mt</span>
    <span class="o">|</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span><span class="n">tl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">f</span> <span class="n">hd</span><span class="o">,</span><span class="n">homebrew_map</span> <span class="n">tl</span> <span class="o">~</span><span class="n">f</span><span class="p">)</span>

<span class="k">let</span> <span class="n">map_eg</span> <span class="o">=</span> <span class="n">homebrew_map</span> <span class="n">hb_eg</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Lets look at the built-in <code>list</code> type:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="kt">list</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">|</span> <span class="p">(</span><span class="o">::</span><span class="p">)</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
</code></pre></div></div>
<p>Looks very similar to our homebrew one, eh??</p>

<h3 id="binary-trees">Binary trees</h3>

<ul>
  <li>Binary trees are like lists but with two self-referential sub-structures instead of one</li>
  <li>Binary trees also show how arbitrary recursive variants work; same idea but more variants.</li>
  <li>Here is a tree with data in the <em>nodes</em> but not the leaves.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span>
</code></pre></div></div>

<p>Here are some simple example trees</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bt0</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"whack!"</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">bt1</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">bt0</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">bt2</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">bt0</span><span class="p">);;</span>
<span class="c">(* Type error, like list, must have uniform type: *)</span>
<span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly"</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">);;</span>
</code></pre></div></div>

<h4 id="operations-on-binary-trees">Operations on Binary Trees</h4>

<ul>
  <li>Since lists are built-in we get a massive library of functions on them.</li>
  <li>For these binary trees (and in general for whatever variant types you roll yourself) there is no such luxury.</li>
  <li><strong>But</strong>, that doesn’t mean you should just code everything by recursing over the tree.  Instead
    <ol>
      <li>Define the combinators you need (maps, folds, node counts, etc.) using <code>let rec</code></li>
      <li>Use your combinators without needing <code>let rec</code></li>
    </ol>
  </li>
  <li>Here is a simple recursive function over binary trees for example:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">add_gobble</span> <span class="n">binstringtree</span> <span class="o">=</span>
 <span class="k">match</span> <span class="n">binstringtree</span> <span class="k">with</span>
 <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
 <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
     <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="s2">"gobble"</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">left</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">right</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Remember, like with lists this is not mutating the tree, its building a new one</li>
  <li>Observe: this is an instance of the general operation of building a tree with same structure but applying an operation on each node value</li>
  <li>i.e. it is a <strong>map</strong> operation over a tree.  Let us code it.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">map</span> <span class="p">(</span><span class="n">tree</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">b</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="nc">Node</span><span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="o">,</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">left</span><span class="o">,</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">right</span><span class="p">)</span>

<span class="c">(* using tree map to make a non-recursive add_gobble *)</span>
<span class="k">let</span> <span class="n">add_gobble</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">^</span> <span class="s2">"gobble"</span><span class="p">)</span> <span class="n">tree</span>
</code></pre></div></div>
<ul>
  <li>Fold is also natural on binary trees, apply operation f to node value and each subtree result.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold</span> <span class="p">(</span><span class="n">tree</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">leaf</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="n">f</span> <span class="n">y</span> <span class="p">(</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">leaf</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">leaf</span> <span class="n">right</span><span class="p">)</span>

<span class="c">(* using tree fold *)</span>
<span class="k">let</span> <span class="n">int_summate</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">ls</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">rs</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">+</span> <span class="n">ls</span> <span class="o">+</span> <span class="n">rs</span><span class="p">)</span> <span class="o">~</span><span class="n">leaf</span><span class="o">:</span><span class="mi">0</span> <span class="n">tree</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">bt</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">);;</span>
<span class="n">int_summate</span> <span class="n">bt</span><span class="p">;;</span>
<span class="c">(* fold can also do map-like operations - the folder can return a tree *)</span>
<span class="k">let</span> <span class="n">bump_nodes</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">ls</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">rs</span><span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">ls</span><span class="o">,</span><span class="n">rs</span><span class="p">))</span> <span class="o">~</span><span class="n">leaf</span><span class="o">:</span><span class="nc">Leaf</span> <span class="n">tree</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Many of the other <code>List</code> functions have analogues on binary trees and recursive variants in general
    <ul>
      <li><code>length</code> (<code>size</code> for a tree), <code>forall</code>, <code>exists</code>, <code>filter</code> (filter out a subtree), etc etc.</li>
    </ul>
  </li>
  <li>For some operations we need to know how to compare the tree elements,</li>
  <li>e.g. if it is a binary (sorted) tree an insertion requires comparison</li>
  <li>For integers at least this is easy as we have <code>&lt;=</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert_int</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">bt</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bt</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert_int</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert_int</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Like lists operations this is not mutating – it returns a whole new tree.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bt'</span> <span class="o">=</span> <span class="n">insert_int</span> <span class="mi">4</span> <span class="n">bt</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">bt''</span> <span class="o">=</span> <span class="n">insert_int</span> <span class="mi">0</span> <span class="n">bt'</span><span class="p">;;</span> <span class="c">(* thread in the most recent tree into subsequent insert *)</span>
</code></pre></div></div>

<ul>
  <li>For non-integers however, we need to explicitly supply any equal or comparison function.
    <ul>
      <li>recall <code>=</code> in <code>Core</code> works on integers only.</li>
    </ul>
  </li>
  <li>Library functions needing to compare will in fact take a comparision operation as argument</li>
  <li>For example in the <code>List</code> library, the <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/List/index.html#val-sort"><code>List.sort</code> function</a></li>
  <li>Here is an example of how to sort a string list with <code>List.sort</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="p">[</span><span class="s2">"Zoo"</span><span class="p">;</span><span class="s2">"Hey"</span><span class="p">;</span><span class="s2">"Abba"</span><span class="p">]</span> <span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">compare</span><span class="p">);;</span> <span class="c">(* pass string's comparison function as argument *)</span>
<span class="c">(* insight into OCaml expected behavior for compare: *)</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Ahh"</span><span class="p">;;</span> <span class="p">)(</span><span class="o">*</span> <span class="o">=</span>  <span class="n">returns</span> <span class="mi">0</span> <span class="o">*</span><span class="p">)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Bee"</span><span class="p">;;</span> <span class="c">(* &lt; returns -1 *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Ack"</span><span class="p">;;</span> <span class="c">(* &gt; returns 1 *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>So, a general tree insert would follow the lead of <code>List.sort</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">bt</span> <span class="n">compare</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bt</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">left</span> <span class="n">compare</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">right</span> <span class="n">compare</span><span class="p">)</span>
<span class="p">;;</span>
<span class="k">let</span> <span class="n">bt'</span> <span class="o">=</span> <span class="n">insert</span> <span class="mi">4</span> <span class="n">bt</span> <span class="p">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">compare</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>In general all the built-in types have both <code>compare</code> and <code>equal</code> (which is same as <code>(=)</code>) defined</li>
  <li>Define your own compare/equal for your own types if you need it</li>
  <li>Appending <code>[@@ppx_deriving equal]</code> to  type decl as we saw above in Hamming DNA example will automatically define function <code>equal_mytype</code> for your type <code>mytype</code></li>
  <li>Appending <code>[@@ppx_deriving compare]</code> is similar but will define function <code>compare_mytype</code>.</li>
</ul>

<h3 id="polymorphic-variants-briefly">Polymorphic Variants Briefly</h3>

<ul>
  <li>OCaml has an additional form of variant which has different syntax and is overlapping in uses: <em>polymorphic variants</em></li>
  <li>A better term would be “inferred variants” - you don’t need to declare them via <code>type</code>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nt">`Zinger</span><span class="p">(</span><span class="mi">3</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="o">=</span> <span class="nt">`Zinger</span> <span class="mi">3</span>
</code></pre></div></div>
<ul>
  <li>This looks a bit useless, it inferred a 1-ary variant type</li>
  <li>But the “<code>&gt;</code>” in the type means <em>there could be other variants showing up in the future</em>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">[</span><span class="nt">`Zinger</span> <span class="mi">3</span><span class="p">;</span> <span class="nt">`Zanger</span> <span class="s2">"hi"</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="nt">`Zinger</span> <span class="mi">3</span><span class="p">;</span> <span class="nt">`Zanger</span> <span class="s2">"hi"</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>We can of course pattern match as well:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">zing_zang</span> <span class="n">z</span> <span class="o">=</span> 
<span class="k">match</span> <span class="n">z</span> <span class="k">with</span>
<span class="o">|</span> <span class="nt">`Zinger</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="s2">"zing! "</span><span class="o">^</span><span class="p">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span> <span class="n">n</span><span class="p">)</span>
<span class="o">|</span> <span class="nt">`Zanger</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="s2">"zang! "</span><span class="o">^</span><span class="n">s</span>
<span class="k">val</span> <span class="n">zing_zang</span> <span class="o">:</span> <span class="p">[</span><span class="o">&lt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>Observe how the type now has a <code>&lt;</code> instead of a <code>&gt;</code>; the meaning is it is those fields or <em>fewer</em>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">zing_zang</span> <span class="o">@@</span> <span class="nt">`Zanger</span> <span class="s2">"wow"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"zang! wow"</span>
<span class="o">#</span> <span class="n">zing_zang</span> <span class="o">@@</span> <span class="nt">`Zuber</span> <span class="mi">1</span><span class="o">.</span><span class="mi">2</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">13</span><span class="o">-</span><span class="mi">23</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zuber</span> <span class="k">of</span> <span class="kt">float</span> <span class="p">]</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="p">[</span><span class="o">&lt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span>
       <span class="nc">The</span> <span class="n">second</span> <span class="n">variant</span> <span class="k">type</span> <span class="n">does</span> <span class="n">not</span> <span class="n">allow</span> <span class="n">tag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nt">`Zuber</span>
</code></pre></div></div>

<ul>
  <li>Generally you should use the non-polymorphic form by default</li>
  <li>The main advantage of the polymorphic form is sharing tags amongst different types
    <ul>
      <li>regular variants like <code>Ok(4)</code> <em>must</em> be in only one type, <code>result</code> for <code>Ok</code> in <code>Core</code></li>
      <li>variants like <code>`Zanger "f"</code> can be in <code>[&gt; `Zanger of string ]</code>, <code>[&gt; `Zanger of string | `Zinger of int ]</code>, etc</li>
      <li>really OCaml should just have one form; the two forms are historical baggage.</li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
