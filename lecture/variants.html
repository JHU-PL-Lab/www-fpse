<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/assignment6.html">Assignment 6</a></li>
                <li><a href="/fpse/assignments/assignment7.html">Assignment 7</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1192943254">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h3 id="variants">Variants</h3>

<ul>
  <li>Variants build or-data (this-or-this-or-this); records build and-data (this-and-this-and-this)</li>
  <li>All data combination is fundamentally either <em>and</em> or <em>or</em>, similar to the fundamental operators of boolean logic.</li>
  <li>We start with variants (or), and then do records (and) next.</li>
</ul>

<h3 id="variants-1">Variants</h3>
<ul>
  <li>The <code>option</code> and <code>result</code> types we have been using are simple forms of <em>variant types</em></li>
  <li>Variants let your data be one of several forms (either-or), with a label wrapping the data indicating the specific form</li>
  <li>They are related to <code>union</code> types in C or <code>enums</code> in Java, but are more safe than C and more general than Java</li>
  <li>Like lists and tuples they are by default immutable</li>
</ul>

<p>Example variant type for doing mixed arithmetic (integers and floats)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ff_num</span> <span class="o">=</span> <span class="nc">Fixed</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Floating</span> <span class="k">of</span> <span class="kt">float</span><span class="p">;;</span>  <span class="c">(* read "|" as "or" *)</span>

<span class="nc">Fixed</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* tag 5 as a Fixed *)</span>
<span class="nc">Floating</span> <span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="p">;;</span> <span class="c">(* tag 4.0 as a Floating *)</span>
</code></pre></div></div>

<ul>
  <li>Each case of the variant is wrapped with a <em>constructor</em> which serves for both
    <ul>
      <li>constructing values of the variant type</li>
      <li>inspecting them by pattern matching</li>
    </ul>
  </li>
  <li>Constructors must start with a Capital Letter to distinguish from variables</li>
  <li>Variants must be declared but once declared type inference can infer them.</li>
  <li>The <code>of</code> indicates what type is under the wrapper</li>
  <li>(Note constructors look like functions but they are <strong>not</strong> – you always need to give the argument)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ff_as_int</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span>    <span class="c">(* pattern match like with option/list/result - those types are also variants *)</span>
    <span class="o">|</span> <span class="nc">Floating</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">int_of_float</span> <span class="n">z</span><span class="p">;;</span>

<span class="n">ff_as_int</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">5</span><span class="p">);;</span>
</code></pre></div></div>

<p>A function using the above variant type</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ff_add</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">n1</span><span class="o">,</span> <span class="n">n2</span> <span class="k">with</span>    <span class="c">(* note use of pair here to parallel-match on two variables  *)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Fixed</span> <span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">)</span>
     <span class="o">|</span> <span class="nc">Fixed</span> <span class="n">i1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span>  <span class="nc">Floating</span><span class="p">(</span><span class="kt">float</span> <span class="n">i1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span> <span class="c">(* need to coerce *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Fixed</span> <span class="n">i2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="kt">float</span> <span class="n">i2</span><span class="p">)</span>  <span class="c">(* ditto *)</span>
     <span class="o">|</span> <span class="nc">Floating</span> <span class="n">f1</span><span class="o">,</span> <span class="nc">Floating</span> <span class="n">f2</span> <span class="o">-&gt;</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">f1</span> <span class="o">+.</span> <span class="n">f2</span><span class="p">)</span>
<span class="p">;;</span>

<span class="n">ff_add</span> <span class="p">(</span><span class="nc">Fixed</span> <span class="mi">123</span><span class="p">)</span> <span class="p">(</span><span class="nc">Floating</span> <span class="mi">3</span><span class="o">.</span><span class="mi">14159</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>No data item?  leave off the <code>of</code>.</li>
  <li>Multiple data items in a single variant clause?  Wrap with a tuple (or record once we cover them):</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">complex</span> <span class="o">=</span> <span class="nc">CZero</span> <span class="o">|</span> <span class="nc">Nonzero</span> <span class="k">of</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span>

<span class="k">let</span> <span class="n">com</span> <span class="o">=</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">zer</span> <span class="o">=</span> <span class="nc">CZero</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">ocaml_annoyance</span> <span class="o">=</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span> <span class="c">(* this is a parsing error, it views as (Fn.id Nonzero)(3.2,11.2) *)</span>
<span class="k">let</span> <span class="n">ocaml_annoyance</span> <span class="o">=</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="o">@@</span> <span class="nc">Nonzero</span><span class="p">(</span><span class="mi">3</span><span class="o">.</span><span class="mi">2</span><span class="o">,</span><span class="mi">11</span><span class="o">.</span><span class="mi">2</span><span class="p">);;</span> <span class="c">(* so use @@ instead of " " *)</span>
</code></pre></div></div>

<h4 id="an-example-of-variants-plus-list-libraries">An Example of Variants plus List. libraries</h4>

<ul>
  <li>Lets write Hamming distance calculator for DNA</li>
  <li>Goal beyond using variants is to cover some useful OCaml programming patterns.</li>
  <li><code>[@@deriving equal]</code> in the below is a <em>macro</em> (called a “ppx extension” in OCaml)</li>
  <li>It automatically generates a function <code>equal_nucleotide</code> (<code>equal_the-types-name-here</code> in general)</li>
  <li>You will need to use this with <code>Core</code> since regular <code>=</code> will not work on <code>nucleotide</code>s.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Example derived from 
   https://exercism.io/tracks/ocaml/exercises/hamming/solutions/afce117bfacb41cebe5c6ebb5e07e7ca
   This code needs a #require "ppx_jane";; in top loop to load ppx extension for @@deriving equal 
   Or, in a dune file it will need   (preprocess (pps ppx_deriving.eq)) added to the library decl *)</span>

<span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="p">]</span>

<span class="k">let</span> <span class="n">hamming_distance</span> <span class="p">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="kt">list</span><span class="p">)</span> <span class="p">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="p">((</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span><span class="p">)</span><span class="o">=</span>
  <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip</span> <span class="n">left</span> <span class="n">right</span> <span class="k">with</span> <span class="c">(* recall this returns Ok(list) or Unequal_lengths, another variant *)</span>
  <span class="o">|</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Unequal_lengths</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">"left and right strands must be of equal length"</span>
  <span class="o">|</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Ok</span> <span class="n">l</span> <span class="o">-&gt;</span>
    <span class="n">l</span>
    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="n">equal_nucleotide</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span>
    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> 
    <span class="o">|&gt;</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">Ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c">(* Unfortunately we can't just pipe to `Ok` since `Ok` is not a function in OCaml - make it one here *)</span>

<span class="k">let</span> <span class="n">hamm_example</span> <span class="o">=</span> <span class="n">hamming_distance</span> <span class="p">[</span><span class="nc">A</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">C</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">T</span><span class="p">;</span><span class="nc">T</span><span class="p">]</span> <span class="p">[</span><span class="nc">A</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">G</span><span class="p">;</span><span class="nc">A</span><span class="p">;</span><span class="nc">C</span><span class="p">;</span><span class="nc">T</span><span class="p">]</span>
</code></pre></div></div>
<p>Now let’s use <code>fold</code> instead of <code>filter</code>/<code>length</code></p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hamming_distance</span> <span class="p">(</span><span class="n">left</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="kt">list</span><span class="p">)</span> <span class="p">(</span><span class="n">right</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="p">((</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span><span class="p">)</span><span class="o">=</span>
  <span class="k">match</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip</span> <span class="n">left</span> <span class="n">right</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Unequal_lengths</span> <span class="o">-&gt;</span> <span class="nc">Error</span> <span class="s2">"left and right strands must be of equal length"</span>
  <span class="o">|</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Ok</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">l</span>
    <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="k">if</span> <span class="p">(</span><span class="n">equal_nucleotide</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="k">then</span> <span class="mi">0</span>  <span class="k">else</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="o">|&gt;</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">Ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>
<h4 id="parametric-variant-types">Parametric variant types</h4>
<p>We have used several of these but have not looked at the type too carefully.</p>

<p>Here is the system’s declaration of the <code>option</code> type – the <code>#show_type</code> top loop directive (or just <code>#show</code>) will print it:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="n">option</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span>
</code></pre></div></div>
<ul>
  <li>The <code>'a</code> here is a <em>parameter</em>, which gets filled in by a concrete type to make an actual type.</li>
  <li>e.g. <code>Some("hello") : string option</code> – the <code>string</code> fills in the parameter <code>'a</code></li>
  <li><code>None : 'a option</code> type means instantiate the <code>'a</code> parameter with polymorphic/generic <code>'a</code></li>
  <li>This may have been more clear if OCaml used function notation for these types, e.g.<br />
 <code>type option('a) = None | Some of 'a</code> and  <code>Some("hello") : option(string)</code></li>
</ul>

<p>And here is <code>result</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="n">result</span><span class="p">;;</span>
<span class="k">type</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Error</span> <span class="k">of</span> <span class="k">'</span><span class="n">b</span>
</code></pre></div></div>

<ul>
  <li>Same idea but <em>a pair</em> of type parameters; <code>'b</code> is the type of the <code>Error</code>.</li>
  <li>Observe <code>Ok(4) : (int, 'a) result</code> and <code>Error("bad") : ('a, string) result</code></li>
</ul>

<p>Lastly, <code>List.zip</code> has a special type for its return value which is very similar to <code>option</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Unequal_lengths</span>
</code></pre></div></div>

<h4 id="recursive-data-structures">Recursive data structures</h4>
<ul>
  <li>A common use of variant types is to build recursive data structures (trees)</li>
  <li>Functional programming is fantastic for computing over tree-structured data</li>
  <li>Recursive types can refer to themselves in their own definition
    <ul>
      <li>similar in spirit to how C structs can be recursive (but, no pointers needed here)</li>
    </ul>
  </li>
  <li>
    <p>Unlike with functions, no need for <code>rec</code></p>
  </li>
  <li>Homebrew lists <code>lizt</code> as a warm-up - the built-in <code>list</code> type is in fact not needed
    <ul>
      <li>Note this example is just for understanding, use the built-in lists if you just want lists.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">lizt</span> <span class="o">=</span> <span class="nc">Mt</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">lizt</span><span class="p">;;</span> <span class="c">(* the recursive "'a lizt" on the rhs is a lizt of 'a *)</span>
<span class="k">let</span> <span class="n">lizt_eg</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">)));;</span> <span class="c">(* analogous to 3 :: 5 :: 7 :: [] = [3;5;7] *)</span>
</code></pre></div></div>
<p>Coding over lizts is nearly identical to built-in lists; here is mapping:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">lizt_map</span> <span class="p">(</span><span class="n">ml</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">lizt</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">b</span> <span class="n">lizt</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">ml</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Mt</span> <span class="o">-&gt;</span> <span class="nc">Mt</span>
    <span class="o">|</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span><span class="n">tl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">f</span> <span class="n">hd</span><span class="o">,</span><span class="n">lizt_map</span> <span class="n">tl</span> <span class="o">~</span><span class="n">f</span><span class="p">)</span>

<span class="k">let</span> <span class="n">map_eg</span> <span class="o">=</span> <span class="n">lizt_map</span> <span class="p">(</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="nc">Mt</span><span class="p">))))</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Lets look at the built-in <code>list</code> type:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="kt">list</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">|</span> <span class="p">(</span><span class="o">::</span><span class="p">)</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
</code></pre></div></div>
<p>This is the exact same structure as <code>lizt</code></p>

<h3 id="binary-trees">Binary trees</h3>

<ul>
  <li>Binary trees are like lists but with two self-referential sub-structures instead of one</li>
  <li>Here is a tree with data in the intermediate <em>nodes</em> but not in the leaves.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span>
</code></pre></div></div>

<p>Here are some simple example trees</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bt0</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"whack!"</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">bt1</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">bt0</span><span class="p">);;</span>

<span class="k">let</span> <span class="n">bt2</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly "</span><span class="o">,</span>
            <span class="nc">Node</span><span class="p">(</span><span class="s2">"backer "</span><span class="o">,</span>
               <span class="nc">Leaf</span><span class="o">,</span>
               <span class="nc">Node</span><span class="p">(</span><span class="s2">"crack "</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="o">,</span>
                  <span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span>
            <span class="n">bt0</span><span class="p">);;</span>
<span class="c">(* Type error, like list, must have uniform type: *)</span>
<span class="nc">Node</span><span class="p">(</span><span class="s2">"fiddly"</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">);;</span>
</code></pre></div></div>

<h4 id="combinators-for-binary-trees">Combinators for Binary Trees</h4>

<ul>
  <li>Since lists are built-in we get a massive library of functions on them.</li>
  <li>For these binary trees (and in general for whatever variant types you roll yourself) there is no such luxury.
    <ul>
      <li>This is because there is no single canonical form of tree, there are many different kinds of trees used</li>
    </ul>
  </li>
  <li><strong>Still</strong>, that doesn’t mean you should just code everything by recursing over the tree.  Instead
    <ol>
      <li>Define the combinators you need (maps, folds, node counts, etc.) using <code>let rec</code></li>
      <li>Use your combinators without needing <code>let rec</code></li>
    </ol>
  </li>
  <li>Here is a simple recursive function over binary trees:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">add_gobble</span> <span class="n">binstringtree</span> <span class="o">=</span>
 <span class="k">match</span> <span class="n">binstringtree</span> <span class="k">with</span>
 <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
 <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
     <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="s2">"gobble"</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">left</span><span class="o">,</span><span class="n">add_gobble</span> <span class="n">right</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>(Remember, as with lists this is not mutating the tree, its building a new one)</li>
  <li>Observe: this is an instance of the general operation of building a tree with same structure but applying an operation on each node value</li>
  <li>i.e. it is a <strong>map</strong> operation over a tree.  Let us code <code>map</code> and use it to add gobbles.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">map</span> <span class="p">(</span><span class="n">tree</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">b</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="nc">Node</span><span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="o">,</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">left</span><span class="o">,</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">right</span><span class="p">)</span>

<span class="c">(* using tree map to make a non-recursive add_gobble *)</span>
<span class="k">let</span> <span class="n">add_gobble</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">^</span> <span class="s2">"gobble"</span><span class="p">)</span> <span class="n">tree</span>
</code></pre></div></div>
<ul>
  <li>Fold is also natural on binary trees, apply operation f to node value and each subtree result.
    <ul>
      <li>This is a fold right (post-processed), folding left on a tree isn’t sensible because there are two subtrees to go down in to.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold</span> <span class="p">(</span><span class="n">tree</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">acc</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">leaf</span> <span class="o">:</span> <span class="k">'</span><span class="n">acc</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">acc</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">tree</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">leaf</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="n">f</span> <span class="n">y</span> <span class="p">(</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">leaf</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">leaf</span> <span class="n">right</span><span class="p">)</span>

<span class="c">(* using tree fold *)</span>
<span class="k">let</span> <span class="n">int_summate</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">laccum</span> <span class="n">raccum</span> <span class="o">-&gt;</span> <span class="n">elt</span> <span class="o">+</span> <span class="n">laccum</span> <span class="o">+</span> <span class="n">raccum</span><span class="p">)</span> <span class="o">~</span><span class="n">leaf</span><span class="o">:</span><span class="mi">0</span> <span class="n">tree</span><span class="p">;;</span>
<span class="n">int_summate</span> <span class="o">@@</span> <span class="nc">Node</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Node</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">Leaf</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">))</span><span class="o">,</span><span class="nc">Leaf</span><span class="p">);;</span>
<span class="c">(* fold can also do map-like operations - the folder can return a tree *)</span>
<span class="k">let</span> <span class="n">inc_nodes</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">la</span> <span class="n">ra</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">elt</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">la</span><span class="o">,</span><span class="n">ra</span><span class="p">))</span> <span class="o">~</span><span class="n">leaf</span><span class="o">:</span><span class="nc">Leaf</span> <span class="n">tree</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Many of the other <code>List</code> functions have analogues on binary trees and recursive variants in general
    <ul>
      <li><code>length</code> (<code>size</code> or <code>depth</code> for a tree), <code>forall</code>, <code>exists</code>, <code>filter</code> (filter out a subtree), etc etc.</li>
    </ul>
  </li>
  <li>For some operations we need to know how to compare the tree elements
    <ul>
      <li>e.g. if it is a binary (sorted) tree an insertion requires comparison</li>
      <li>here for example we compare node elements for integer node values</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert_int</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">bt</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="n">bin_tree</span><span class="p">)</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bt</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert_int</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert_int</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>Like list operations this is not mutating – it returns a whole new tree.</li>
  <li><strong>But</strong>, recall for lists that if we have a list <code>l</code> then <code>0 :: l</code> can share the <code>l</code> due to immutability</li>
  <li>So, for here, only one path through tree is not shared: on average only log n new nodes need to be made.  <a href="efficiency.html">More later in lecture on efficiency</a>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bt'</span> <span class="o">=</span> <span class="n">insert_int</span> <span class="mi">4</span> <span class="n">bt</span><span class="p">;;</span>
<span class="k">let</span> <span class="n">bt''</span> <span class="o">=</span> <span class="n">insert_int</span> <span class="mi">0</span> <span class="n">bt'</span><span class="p">;;</span> <span class="c">(* thread in the most recent tree into subsequent insert *)</span>
</code></pre></div></div>

<ul>
  <li>For non-integers, we need to explicitly supply any equal or comparison function.</li>
  <li>Library functions needing to compare will in fact take a comparision operation as argument</li>
  <li>For example in the <code>List</code> library, the <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/List/index.html#val-sort"><code>List.sort</code> function</a></li>
  <li>Here is an example of how to sort a string list with <code>List.sort</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="p">[</span><span class="s2">"Zoo"</span><span class="p">;</span><span class="s2">"Hey"</span><span class="p">;</span><span class="s2">"Abba"</span><span class="p">]</span> <span class="o">~</span><span class="n">compare</span><span class="o">:</span><span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">compare</span><span class="p">);;</span> <span class="c">(* pass string's comparison function as argument *)</span>
<span class="c">(* insight into OCaml expected behavior for compare: *)</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Ahh"</span><span class="p">;;</span> <span class="c">(* =  returns 0 : equal *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Bee"</span><span class="p">;;</span> <span class="c">(* &lt; returns -1 : less *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">#</span> <span class="nn">String</span><span class="p">.</span><span class="n">compare</span> <span class="s2">"Ahh"</span> <span class="s2">"Ack"</span><span class="p">;;</span> <span class="c">(* &gt; returns 1 : greater *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>So, our more general tree insert should follow the lead of <code>List.sort</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">bt</span> <span class="o">~</span><span class="n">compare</span> <span class="o">=</span>
   <span class="k">match</span> <span class="n">bt</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span><span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span>
   <span class="o">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">compare</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">left</span> <span class="n">compare</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>
       <span class="k">else</span> <span class="nc">Node</span><span class="p">(</span><span class="n">y</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">right</span> <span class="n">compare</span><span class="p">)</span>
<span class="p">;;</span>
<span class="k">let</span> <span class="n">bt'</span> <span class="o">=</span> <span class="n">insert</span> <span class="mi">4</span> <span class="n">bt</span> <span class="o">~</span><span class="n">compare</span><span class="o">:</span><span class="p">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">compare</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>In general all the built-in types have both <code>compare</code> and <code>equal</code> (which is same as <code>(=)</code>) defined</li>
  <li>Define your own compare/equal for your own types if you need it</li>
  <li>Appending <code>[@@ppx_deriving equal]</code> to  type decl as we saw above in Hamming DNA example will automatically define function <code>equal_mytype</code> for your type <code>mytype</code></li>
  <li>Appending <code>[@@ppx_deriving compare]</code> is similar but will define function <code>compare_mytype</code>.</li>
  <li>Appending <code>[@@ppx_deriving equal compare]</code> will get both</li>
</ul>

<h3 id="polymorphic-variants-briefly">Polymorphic Variants Briefly</h3>

<ul>
  <li>OCaml has an additional form of variant which has different syntax and is overlapping in uses: <em>polymorphic variants</em></li>
  <li>A better term would be “inferred variants” - you don’t need to declare them via <code>type</code>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nt">`Zinger</span><span class="p">(</span><span class="mi">3</span><span class="p">);;</span> <span class="c">(* prefix constructors with a backtick for the inferred variants *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="o">=</span> <span class="nt">`Zinger</span> <span class="mi">3</span>
</code></pre></div></div>
<ul>
  <li>This looks a bit useless, it inferred a 1-ary variant type</li>
  <li>But the “<code>&gt;</code>” in the type means <em>there could be other variants showing up in the future</em>.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="n">b</span> <span class="o">=</span> <span class="k">if</span> <span class="n">b</span> <span class="k">then</span> <span class="p">[</span><span class="nt">`Zinger</span> <span class="mi">3</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="nt">`Zanger</span> <span class="s2">"hi"</span><span class="p">];;</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>We can of course pattern match as well:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">zing_zang</span> <span class="n">z</span> <span class="o">=</span> 
<span class="k">match</span> <span class="n">z</span> <span class="k">with</span>
<span class="o">|</span> <span class="nt">`Zinger</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="s2">"zing! "</span><span class="o">^</span><span class="p">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span> <span class="n">n</span><span class="p">)</span>
<span class="o">|</span> <span class="nt">`Zanger</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="s2">"zang! "</span><span class="o">^</span><span class="n">s</span>
<span class="k">val</span> <span class="n">zing_zang</span> <span class="o">:</span> <span class="p">[</span><span class="o">&lt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>Observe how the type now has a <code>&lt;</code> instead of a <code>&gt;</code>; the meaning is it is those fields or <em>fewer</em>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">zing_zang</span> <span class="o">@@</span> <span class="nt">`Zanger</span> <span class="s2">"wow"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"zang! wow"</span>
<span class="o">#</span> <span class="n">zing_zang</span> <span class="o">@@</span> <span class="nt">`Zuber</span> <span class="mi">1</span><span class="o">.</span><span class="mi">2</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">13</span><span class="o">-</span><span class="mi">23</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="p">[</span><span class="o">&gt;</span> <span class="nt">`Zuber</span> <span class="k">of</span> <span class="kt">float</span> <span class="p">]</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="p">[</span><span class="o">&lt;</span> <span class="nt">`Zanger</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nt">`Zinger</span> <span class="k">of</span> <span class="kt">int</span> <span class="p">]</span>
       <span class="nc">The</span> <span class="n">second</span> <span class="n">variant</span> <span class="k">type</span> <span class="n">does</span> <span class="n">not</span> <span class="n">allow</span> <span class="n">tag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="nt">`Zuber</span>
</code></pre></div></div>

<ul>
  <li>Generally you should use the non-polymorphic form by default</li>
  <li>The main advantage of the polymorphic form is sharing tags amongst different types
    <ul>
      <li>regular variants like <code>Ok(4)</code> <em>must</em> be in only one type, <code>result</code> for <code>Ok</code> in <code>Core</code></li>
      <li>variants like <code>`Zanger "f"</code> can be in <code>[&gt; `Zanger of string ]</code>, <code>[&gt; `Zanger of string | `Zinger of int ]</code>, etc</li>
      <li>really OCaml should just have one form; the two forms are historical baggage.</li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
