<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://campuswire.com/c/G2FCCFD2B/feed">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="more-modules-and-libraries">More Modules and Libraries</h2>

<h3 id="tangent-ish-ppx_jane-and-deriving">Tangent-ish: <code>ppx_jane</code> and <code>deriving</code></h3>

<ul>
  <li>Recall <code>[@@deriving equal]</code> in the nucleotide example to get an <code>=</code> on that type:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Needs #require "ppx_jane";; in top loop, 
   and (preprocess (pps (ppx_jane))) in as part of the library declaration 
   (i.e. it is (library (name ..)  .. (preprocess ... )) - one of the library decl components) *)</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="p">];;</span>
<span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span>
<span class="k">val</span> <span class="n">equal_nucleotide</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">fun</span>
</code></pre></div></div>

<ul>
  <li>The <code>[@@zibbo...]</code> indicates the type declaration is processed by the macro named <code>ppx_zibbo</code></li>
  <li>The <code>equal</code> is a parameter to the macro, here it is which <code>deriving</code> extension is added</li>
  <li>The <code>[@@deriving equal]</code> in particular causes an <code>equal_nucleotide</code> function to be automatically generated</li>
  <li>Without this function we would have to use pattern matching to write our own equality.</li>
</ul>

<h4 id="composing-deriving-equal">Composing <code>deriving equal</code></h4>

<ul>
  <li>If we have an <code>xyy_equal</code> function on component types, <code>deriving</code> can derive <code>equal</code> for a type built from those components:<br />
```ocaml
    <h1 id="type-n_list--nucleotide-list-deriving-equal">type n_list = nucleotide list [@@deriving equal];;</h1>
    <p>type n_list = nucleotide list<br />
val equal_n_list : n_list -&gt; n_list -&gt; bool = fun</p>
    <h1 id="equal_n_list-aaa-aga">equal_n_list [A;A;A] [A;G;A];;</h1>
  </li>
  <li>: bool = false
    <h1 id="type-n_queue--nucleotide-queuet-deriving-equal">type n_queue = nucleotide Queue.t [@@deriving equal];;</h1>
    <p>type n_queue = nucleotide Core_kernel.Queue.t<br />
val equal_n_queue : n_queue -&gt; n_queue -&gt; bool = fun<br />
```</p>
  </li>
  <li>Notice that the <code>Core</code> libraries are designed to play well as they have <code>List.equal</code>, <code>Queue.equal</code> built in</li>
  <li>Generally for a component type that is the <code>t</code> of a module, the name looked for is <code>My_module.equal</code> instead of <code>t_equal</code></li>
  <li>Similarly, if we are making our own module with its carrier type <code>t</code> it will also generate <code>My_module.equal</code> if we use <code>[@@deriving equal]</code></li>
</ul>

<h3 id="some-other-useful-deriving-type-accessor-extensions-in-ppx_jane">Some other useful <code>@@deriving</code> type accessor extensions in ppx_jane</h3>

<ul>
  <li><code>sexp</code> generates S-expression printable representations of types which is handy for displaying data internals</li>
  <li>S-expressions are a general data format like JSON or XML, in fact they are the first such format</li>
  <li>For some reason the <code>Core</code> libraries make heavy use of S-expressions instead of JSON - a mistake really.</li>
  <li>It is not too hard to read S-expressions after a bit of staring</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="o">,</span> <span class="n">sexp</span><span class="p">];;</span>
<span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span>
<span class="k">val</span> <span class="n">equal_nucleotide</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">fun</span>
<span class="k">val</span> <span class="n">nucleotide_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="k">fun</span>
<span class="k">val</span> <span class="n">sexp_of_nucleotide</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">fun</span>
 <span class="k">type</span> <span class="n">n_list</span> <span class="o">=</span> <span class="n">nucleotide</span> <span class="kt">list</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="o">,</span> <span class="n">sexp</span><span class="p">];;</span>
<span class="k">type</span> <span class="n">n_list</span> <span class="o">=</span> <span class="n">nucleotide</span> <span class="kt">list</span>
<span class="k">type</span> <span class="n">n_list</span> <span class="o">=</span> <span class="n">nucleotide</span> <span class="kt">list</span>
<span class="k">val</span> <span class="n">equal_n_list</span> <span class="o">:</span> <span class="n">n_list</span> <span class="o">-&gt;</span> <span class="n">n_list</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="k">fun</span>
<span class="k">val</span> <span class="n">n_list_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">n_list</span> <span class="o">=</span> <span class="k">fun</span>
<span class="k">val</span> <span class="n">sexp_of_n_list</span> <span class="o">:</span> <span class="n">n_list</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">fun</span>
<span class="o">#</span> <span class="n">sexp_of_n_list</span> <span class="p">[</span><span class="nc">A</span><span class="p">;</span><span class="nc">G</span><span class="p">;</span><span class="nc">G</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="nc">A</span> <span class="nc">G</span> <span class="nc">G</span><span class="p">)</span> <span class="c">(* this is the "S-Expression" version of a list.. parens and spaces *)</span>
</code></pre></div></div>

<ul>
  <li><code>[@@deriving compare]</code> is analogous to <code>equal</code> except it makes a <code>compare</code> function instead of <code>equal</code><br />
```ocaml
    <h1 id="type-nucleotide--a--c--g--t-deriving-compare">type nucleotide = A | C | G | T [@@deriving compare];;</h1>
    <p>type nucleotide = A | C | G | T<br />
val compare_nucleotide : nucleotide -&gt; nucleotide -&gt; int = fun</p>
    <h1 id="compare_nucleotide-a-c">compare_nucleotide A C;;</h1>
  </li>
  <li>: int = -1<br />
utop # compare_nucleotide C A;;</li>
  <li>: int = 1<br />
```</li>
  <li><code>Core</code> does have some libraries for dealing with JSON as well fortunately.</li>
  <li>For the homework there is a to/from JSON format function you can add to any type</li>
  <li>this will save wear and tear on your fingers, no need to convert.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">"ppx_deriving_yojson"</span><span class="p">;;</span> <span class="c">(* see the ppx_deriving_yojson docs linked in HW for `dune` use *)</span>
<span class="o">#</span> <span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">yojson</span><span class="p">];;</span>
<span class="k">type</span> <span class="n">nucleotide</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span>
<span class="k">val</span> <span class="n">nucleotide_to_yojson</span> <span class="o">:</span> <span class="n">nucleotide</span> <span class="o">-&gt;</span> <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="k">fun</span>
<span class="k">val</span> <span class="n">nucleotide_of_yojson</span> <span class="o">:</span>
  <span class="nn">Yojson</span><span class="p">.</span><span class="nn">Safe</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">nucleotide</span> <span class="nn">Ppx_deriving_yojson_runtime</span><span class="p">.</span><span class="n">error_or</span> <span class="o">=</span> <span class="k">fun</span>
</code></pre></div></div>

<h2 id="defining-modules-in-the-top-loop">Defining Modules in the top loop</h2>

<ul>
  <li>We will now cover how you can define modules in the top loop.</li>
  <li>The main reason we are covering this is it will help us understand nested modules and functors
    <ul>
      <li>generally the file-based method of defining a module we have done thus far is how modules are defined.</li>
    </ul>
  </li>
  <li>Basic idea to input a module in top-loop: write <code>module My_module = struct ... end</code> with file in the `..</li>
  <li><code>struct</code> stands for structure, modules used to be called that in OCaml; view a struct as = to a module.</li>
  <li>Modules are by default not expressions, so we normally can’t define with <code>let</code></li>
  <li>Simple set example put in top-loop syntax:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">Simple_set</span> <span class="o">=</span> <span class="k">struct</span> 
<span class="k">open</span> <span class="nc">Core</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
<span class="k">let</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="p">)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">remove</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">equal</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"item is not in set"</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">equal</span> <span class="n">hd</span> <span class="n">x</span> <span class="k">then</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove</span> <span class="n">x</span> <span class="n">tl</span> <span class="n">equal</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">equal</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">equal</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">tl</span> <span class="n">equal</span>
<span class="k">end</span><span class="p">;;</span>
<span class="k">module</span> <span class="nc">Simple_set</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="nn">Simple_set</span><span class="p">.</span><span class="n">emptyset</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="bp">[]</span>
</code></pre></div></div>

<ul>
  <li>Notice how it infers a module type (aka signature – <code>sig</code> at the start is for signature)</li>
  <li>We can also declare module types and explicitly declare along with the module</li>
  <li>Use <code>module type Type_name_here = ... type here ...</code> to declare module types:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Simple_set</span> <span class="o">=</span> <span class="c">(* module and module type namespaces are distinct, can re-use name *)</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Then can replace <code>module Simple_set = struct .. end</code> with</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Simple_set</span> <span class="o">:</span> <span class="nc">Simple_set</span> <span class="o">=</span> <span class="k">struct</span> <span class="o">...</span> <span class="k">end</span>
</code></pre></div></div>

<p>and it will define the module with the above signature on it</p>

<h2 id="nested-modules">Nested modules</h2>

<ul>
  <li>OK generally we will use file-defined modules, why this detour into how to define them in top loop?</li>
  <li>Answer: the real use of the above syntax is it also lets us define <em>modules within modules</em> in files
    <ul>
      <li>which is in fact very useful</li>
    </ul>
  </li>
  <li>We are using many of those already, e.g. <code>Core.List.map</code> means <code>List</code> is just a module inside <code>Core</code>.</li>
  <li>Modules nest exactly as you would expect, just write a <code>module My_module = struct .. end</code> declaration<br />
 within a (file-based <em>or</em> top-loop-defined) module</li>
  <li>Here is an example
    <ul>
      <li>(note we will do top-loop version here, could remove top/bottom two lines and put in file)</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Super_simple_core</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">module</span> <span class="nc">Simple_set</span> <span class="o">=</span> <span class="k">struct</span> <span class="c">(* insert above code here ... *)</span> <span class="k">end</span>

  <span class="k">module</span> <span class="nc">List</span> <span class="o">=</span> <span class="nn">Core</span><span class="p">.</span><span class="nc">List</span> <span class="c">(* just borrow Core's list for our Super_simple_core *)</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="basic-functors">Basic Functors</h3>

<ul>
  <li>Functors are simply parametric modules, i.e. functions from modules to modules</li>
  <li>They let us define a generic code library to which we can plug in some concrete code
    <ul>
      <li>in other words, just like what higher-order functions do except for modules</li>
    </ul>
  </li>
  <li>Like modules they are also “top-level-definable” only in basic OCaml
    <ul>
      <li>they are not expressions</li>
    </ul>
  </li>
</ul>

<h4 id="simple-functors-example">Simple Functors Example</h4>

<ul>
  <li>Lets fix the problem of the <code>equal</code> function needed as a parameter to <code>remove</code> and <code>contains</code> on our <code>Simple_set</code> module.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Eq</span> <span class="o">=</span> <span class="k">sig</span> 
<span class="k">type</span> <span class="n">t</span>
<span class="k">val</span> <span class="n">equal</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span> 
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Simple_set_functor</span> <span class="p">(</span><span class="nc">M</span><span class="o">:</span> <span class="nc">Eq</span><span class="p">)</span> <span class="o">=</span> 
<span class="k">struct</span>
<span class="k">open</span> <span class="nc">Core</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
<span class="k">let</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="p">)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">remove</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"item is not in set"</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">equal</span> <span class="n">hd</span> <span class="n">x</span> <span class="k">then</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove</span> <span class="n">x</span> <span class="n">tl</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">equal</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">tl</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>Notice how the type that was polymorphic, <code>'a</code> in the original <code>Simple_set</code>, is <code>M.t</code> here – we are<br />
taking the type from the <code>Eq</code> module – that is the type we need, the type over the <code>equal</code> operation.</li>
  <li>
    <p>To use the functor, just define a specific module by applying the functor to a module that has a type <code>t</code> and a function <code>equal : t -&gt; t-&gt; bool</code>.</p>
  </li>
  <li>Alternate syntax for functors - anonymous form like with expression’s “<code>function x -&gt; ...</code>”</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Simple_set_functor</span> <span class="o">=</span> <span class="k">functor</span> <span class="p">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">Eq</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">struct</span>  <span class="p">(</span><span class="n">stuff</span> <span class="n">above</span> <span class="o">...</span><span class="p">)</span> <span class="k">end</span>
</code></pre></div></div>
<ul>
  <li>(Can also make higher-order functors: pass and return functors from functors)</li>
</ul>

<h4 id="types-of-functors">Types of functors</h4>

<ul>
  <li>Functors also have types, OCaml inferred a type for <code>Simple_set_functor</code> but we can also declare it:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">SSF</span> <span class="o">=</span> <span class="k">functor</span> <span class="p">(</span><span class="nc">M</span> <span class="o">:</span> <span class="nc">Eq</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">sig</span>
      <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
      <span class="k">val</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
      <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
    <span class="k">end</span><span class="p">;;</span>
</code></pre></div></div>
<ul>
  <li>Observe the type is generally <code>functor (M : Module_type) -&gt; sig ... end</code></li>
  <li>Notice how the argument module <code>M</code> occurs in the result type since it has types in it</li>
  <li>Such a type is called a <em>dependent type</em></li>
</ul>

<h3 id="using-functors">Using functors</h3>

<ul>
  <li>Pass a module to a functor to make a module specializing the parameter to what was passed</li>
  <li>In other words, just like a function but on modules</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">String_set</span> <span class="o">=</span> <span class="nc">Simple_set_functor</span><span class="p">(</span><span class="nc">String</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">String_set</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span>
</code></pre></div></div>
<ul>
  <li>Note that we passed in a <code>String</code> module where the parameter had the <code>Eq</code> module type</li>
  <li><code>String.t</code> is the underlying type of the string, and <code>String.equal</code> exists as an equality operation on strings, so <code>String</code> matches the <code>Eq</code> module type</li>
  <li>(<code>utop</code> command <code>#show_module String</code> will dump the full module if you want to verify <code>t</code> and <code>equal</code> are there)</li>
  <li>Note <code>String</code> also has a whole <strong>ton</strong> of other functions, types, etc
    <ul>
      <li>but like with subclasses or Java interfaces you match if you have “at least” the stuff needed.</li>
    </ul>
  </li>
  <li>Here is one way you can test if a module matches a module type:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">String2</span> <span class="o">=</span> <span class="p">(</span><span class="nc">String</span> <span class="o">:</span> <span class="nc">Eq</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">String2</span> <span class="o">:</span> <span class="nc">Eq</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">String2</span> <span class="o">:</span> <span class="nc">Eq</span> <span class="o">=</span> <span class="nc">String</span><span class="p">;;</span> <span class="c">(* Equivalent way to write the above *)</span>
<span class="k">module</span> <span class="nc">String2</span> <span class="o">:</span> <span class="nc">Eq</span>
</code></pre></div></div>
<ul>
  <li>This declares a new module <code>String2</code> which is <code>String</code> matched against the <code>Eq</code> type.</li>
  <li>
    <p>Note that <code>String2</code> is restricted to <em>only</em> have <code>t</code>/<code>equal</code> with this declaration (<code>String</code> of course keeps everything, no mutuation!)</p>
  </li>
  <li>Here is how we could instantiate the <code>Simple_set_functor</code> with our own data type</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">"ppx_jane"</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Nucleotide</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">equal</span><span class="p">]</span> <span class="k">end</span><span class="p">;;</span>
<span class="k">module</span> <span class="nc">Nucleotide</span> <span class="o">:</span> <span class="k">sig</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">A</span> <span class="o">|</span> <span class="nc">C</span> <span class="o">|</span> <span class="nc">G</span> <span class="o">|</span> <span class="nc">T</span> <span class="k">val</span> <span class="n">equal</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">Nuc_set</span> <span class="o">=</span> <span class="nc">Simple_set_functor</span><span class="p">(</span><span class="nc">Nucleotide</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">Nuc_set</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">remove</span> <span class="o">:</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="nn">Nucleotide</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>Note this requires us to make a module out of our type</li>
  <li>(also note that we used <code>[@@deriving equal]</code> to make the <code>equal</code> for free)
    <ul>
      <li>(and note it is given the name <code>Nucleotide.equal</code> and not <code>Nucleotide.equal_nucleotide</code>, since it is in a module and is the type <code>t</code> there)</li>
    </ul>
  </li>
</ul>

<h3 id="cores-set-map-hash-table-etc"><code>Core</code>’s Set, Map, Hash table, etc</h3>

<ul>
  <li>The <code>Core</code> advanced data structures support something similar to what we did above
    <ul>
      <li>“plug in the comparison in an initialization phase and then forget about it”</li>
    </ul>
  </li>
  <li>Here for example is how you make a map where the key is a built-in type (which has an associated module)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">FloatMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">Float</span><span class="p">);;</span> <span class="c">(* Or Char/Int/String/Bool/etc *)</span>
<span class="k">module</span> <span class="nc">FloatMap</span> <span class="o">:</span>
  <span class="k">sig</span> <span class="o">...</span> <span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>Note it requires a bit more than just the type and comparison to be in <code>Float</code> for this to work</li>
  <li>to/from S-expression conversions needed; use <code>[@@deriving compare, sexp]</code> on your own type:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="n">require</span> <span class="s2">"ppx_jane"</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">IntPair</span> <span class="o">=</span> <span class="k">struct</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">compare</span><span class="o">,</span> <span class="n">sexp</span><span class="p">]</span>
<span class="k">end</span><span class="p">;;</span>
<span class="k">module</span> <span class="nc">IntPair</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexplib0</span><span class="p">.</span><span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">IPMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPair</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">IPMap</span> <span class="o">:</span>
  <span class="k">sig</span> <span class="o">...</span> <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">IPSet</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPair</span><span class="p">);;</span>  <span class="c">(* Sets in Core also need compare (sorts internally) *)</span>
<span class="o">...</span>
<span class="o">#</span> <span class="nn">IPSet</span><span class="p">.(</span><span class="n">empty</span> <span class="o">|&gt;</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">flip</span> <span class="n">add</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">flip</span> <span class="n">add</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">Fn</span><span class="p">.</span><span class="n">flip</span> <span class="n">add</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">to_list</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="nn">IntPair</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="p">)]</span>
</code></pre></div></div>

<p>Observe that only non-parametric types can be keys for maps:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">FloatMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">List</span><span class="p">);;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">27</span><span class="o">-</span><span class="mi">31</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">Signature</span> <span class="n">mismatch</span><span class="o">:</span>
       <span class="o">...</span>
       <span class="nc">Type</span> <span class="n">declarations</span> <span class="k">do</span> <span class="n">not</span> <span class="k">match</span><span class="o">:</span>
         <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
       <span class="n">is</span> <span class="n">not</span> <span class="n">included</span> <span class="k">in</span>
         <span class="k">type</span> <span class="n">t</span>
       <span class="nc">They</span> <span class="n">have</span> <span class="n">different</span> <span class="n">arities</span><span class="o">.</span>
       <span class="nc">File</span> <span class="s2">"src/map_intf.ml"</span><span class="o">,</span> <span class="n">line</span> <span class="mi">29</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">2</span><span class="o">-</span><span class="mi">35</span><span class="o">:</span> <span class="nc">Expected</span> <span class="n">declaration</span>
       <span class="nc">File</span> <span class="s2">"src/list.mli"</span><span class="o">,</span> <span class="n">line</span> <span class="mi">12</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">48</span><span class="o">:</span> <span class="nc">Actual</span> <span class="n">declaration</span>
</code></pre></div></div>

<ul>
  <li>Mildly annoying solution: explictly make a module for the list type you care about:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">SList</span> <span class="o">=</span> <span class="k">struct</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span> <span class="kt">list</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">compare</span><span class="o">,</span><span class="n">sexp</span><span class="p">]</span> <span class="k">end</span><span class="p">;;</span>
<span class="k">module</span> <span class="nc">SList</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span> <span class="kt">list</span>
    <span class="k">val</span> <span class="n">compare</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
    <span class="k">val</span> <span class="n">t_of_sexp</span> <span class="o">:</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">sexp_of_t</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="nn">Sexp</span><span class="p">.</span><span class="n">t</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="k">module</span> <span class="nc">SListMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">SList</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">SListMap</span> <span class="o">:</span>
  <span class="k">sig</span> <span class="o">...</span> <span class="k">end</span>
</code></pre></div></div>
<p>Simpler way to do above: can inline the module definition, no need to name it</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">SListMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="k">struct</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span> <span class="kt">list</span> <span class="p">[</span><span class="o">@@</span><span class="n">deriving</span> <span class="n">compare</span><span class="o">,</span><span class="n">sexp</span><span class="p">]</span> <span class="k">end</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">SListMap</span> <span class="o">:</span>
  <span class="k">sig</span> <span class="o">..</span> <span class="k">end</span>
</code></pre></div></div>
<ul>
  <li>The above is a map where the <em>keys</em> are lists of strings</li>
  <li>The above examples show how non-trivial data structures can be map keys</li>
  <li>Here is the opposite, how we can make e.g. a variant with maps in it.</li>
  <li>This assumes the keys are integer pairs, and the values can be any type (<code>'a</code>)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="nn">IPMap</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span><span class="p">;;</span> 
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span> <span class="o">=</span>
    <span class="nc">Leaf</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="nn">IPMap</span><span class="p">.</span><span class="n">t</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">intpairmaptree</span>
</code></pre></div></div>

<h3 id="larger-example-using-coremap">Larger Example Using Core.Map</h3>
<ul>
  <li>We will go over the code of <a href="../examples/school.ml">school.ml</a>, simple code that uses a <code>Core.Map</code>.</li>
  <li>Note that there is a fancier way than <code>Map.Make</code> using advanced features we have not covered yet: <em>first-class modules</em>.
    <ul>
      <li>We will peek at <a href="../examples/cool_school.ml">cool_school.ml</a> which re-writes the <code>school.ml</code> example to use first-class modules</li>
      <li>The advantage of this code is you don’t need to make a new module for every type you use it at</li>
      <li>Imagine if for every <code>List</code> type we had to make an <code>IntList</code>, <code>StringList</code> etc module - painful!</li>
      <li>(<code>List</code> itself avoids this problem by not being comparison-friendly, we had to pass in <code>compare</code> to <code>List.sort</code> for example)</li>
    </ul>
  </li>
</ul>

<h3 id="a-few-other-module-features-include-and-with">A few other module features: <code>include</code> and <code>with</code></h3>

<h4 id="include"><code>include</code></h4>

<ul>
  <li><code>include</code> is pretty straightforward, it “copies/pastes” one module or module type’s definitions inside a new definition.
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">Sized_set</span> <span class="o">=</span> <span class="k">struct</span> 
<span class="k">include</span> <span class="nc">Simple_set</span> 
<span class="k">let</span> <span class="n">size</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span>
<span class="k">end</span>
</code></pre></div>    </div>
  </li>
  <li>This will make a new module <code>Sized_set</code> which is the same as <code>Simple_set</code> but with an added <code>size</code> function.</li>
  <li>Observe how <code>'a t</code> works to refer to a type in <code>Simple_set</code>, just like we had pasted all that stuff in.</li>
</ul>

<p>Similarly module types (and also functors) can use <code>include</code></p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Size_set</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">include</span> <span class="nc">Simple_set</span>
    <span class="k">val</span> <span class="n">size</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">int</span>
  <span class="k">end</span>
</code></pre></div></div>

<h4 id="with"><code>with</code></h4>

<ul>
  <li><code>with</code> is needed when you have a module type with an abstract <code>type</code> in it (so values in the type will be <code>&lt;abstr&gt;</code> to outsiders)</li>
  <li>
    <p><strong>but</strong> you need to see the concrete type.</p>
  </li>
  <li>Example: here is a type of modules which contain pairs (a non-useful but small example)</li>
  <li>Note we want this to be generic over any type of pair so we let <code>l</code> and <code>r</code> be undefined</li>
  <li>But, the downside is we are going to also make them <code>&lt;abstr&gt;</code> by doing this which is not always what we want…
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">Pair_hidden</span> <span class="o">=</span> 
<span class="k">sig</span>
  <span class="k">type</span> <span class="n">l</span>
  <span class="k">type</span> <span class="n">r</span>
  <span class="k">val</span> <span class="n">left</span> <span class="o">:</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">l</span>
  <span class="k">val</span> <span class="n">right</span> <span class="o">:</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span>
<span class="k">end</span><span class="p">;;</span>
</code></pre></div>    </div>
    <p>OK lets make a concrete example of the above on <code>int</code> and <code>string</code></p>
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Pair</span> <span class="o">=</span> <span class="k">struct</span> 
 <span class="k">type</span> <span class="n">l</span> <span class="o">=</span> <span class="kt">int</span>
 <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">string</span>
 <span class="k">let</span> <span class="n">left</span> <span class="p">((</span><span class="n">l</span><span class="o">:</span><span class="n">l</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span><span class="n">r</span><span class="p">))</span> <span class="o">=</span> <span class="n">l</span>
 <span class="k">let</span> <span class="n">right</span> <span class="p">((</span><span class="n">l</span><span class="o">:</span><span class="n">l</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="n">r</span><span class="o">:</span><span class="n">r</span><span class="p">))</span> <span class="o">=</span> <span class="n">r</span>
<span class="k">end</span><span class="p">;;</span>
</code></pre></div>    </div>
    <p>Now the problem is if we put the above signature on the module, we hid too much!</p>
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">Matched_pair</span> <span class="o">=</span> <span class="p">(</span><span class="nc">Pair</span> <span class="o">:</span> <span class="nc">Pair_hidden</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">Matched_pair</span> <span class="o">:</span> <span class="nc">Pair_hidden</span>
<span class="o">#</span> <span class="nn">Matched_pair</span><span class="p">.</span><span class="n">left</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="s2">"hi"</span><span class="p">);;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">19</span><span class="o">-</span><span class="mi">20</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
       <span class="nn">Matched_pair</span><span class="p">.</span><span class="n">l</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>The solution is you can instantiate abstract types in module types by <code>with</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="nc">Matched_pair</span> <span class="o">=</span> <span class="p">(</span><span class="nc">Pair</span> <span class="o">:</span> <span class="nc">Pair_hidden</span> <span class="k">with</span> <span class="k">type</span> <span class="n">l</span> <span class="o">=</span> <span class="kt">int</span> <span class="k">with</span> <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">string</span><span class="p">);;</span>
<span class="k">module</span> <span class="nc">Matched_pair</span> <span class="o">:</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">l</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">string</span>
    <span class="k">val</span> <span class="n">left</span> <span class="o">:</span> <span class="n">l</span> <span class="o">*</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="k">val</span> <span class="n">right</span> <span class="o">:</span> <span class="n">l</span> <span class="o">*</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span>
  <span class="k">end</span>
<span class="o">#</span> <span class="nn">Matched_pair</span><span class="p">.</span><span class="n">left</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="s2">"hi"</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div></div>
<p>Usually <code>with</code> is inlined like above, but it is just defining a new module type:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">module</span> <span class="k">type</span> <span class="nc">Pair_unhidden</span> <span class="o">=</span> <span class="nc">Pair_hidden</span> <span class="k">with</span> <span class="k">type</span> <span class="n">l</span> <span class="o">=</span> <span class="kt">int</span> <span class="k">with</span> <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">string</span><span class="p">;;</span>
<span class="k">module</span> <span class="k">type</span> <span class="nc">Pair_unhidden</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">l</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">type</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">string</span>
    <span class="k">val</span> <span class="n">left</span> <span class="o">:</span> <span class="n">l</span> <span class="o">*</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">l</span>
    <span class="k">val</span> <span class="n">right</span> <span class="o">:</span> <span class="n">l</span> <span class="o">*</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span>
  <span class="k">end</span>
</code></pre></div></div>

<h3 id="other-data-structures-in-core">Other Data Structures in <code>Core</code></h3>

<ul>
  <li><code>Core</code> has complete implementations of many classic data structures, many of which are built similarly with functor like <code>Map.Make</code></li>
  <li>Be careful on imperative vs functional, difference is not well-documented or consistently-named</li>
  <li>Functional data structures in <code>Core</code>:
    <ul>
      <li><code>Set</code>, <code>Map</code>, <code>Doubly_linked</code> (list), <code>Fqueue</code>, <code>Fdeque</code> (functional (double-ended) queue)</li>
    </ul>
  </li>
  <li>Imperative data structures:
    <ul>
      <li><code>Stack</code> and <code>Queue</code> as we previously discussed (which don’t need <code>Make</code>/<code>compare</code>), plus <code>Hash_queue</code>, <code>Hash_set</code>, <code>Hashtbl</code> (mutable hashed queue/set/map),  <code>Linked_queue</code>,  <code>Bag</code> (a multi-set)</li>
    </ul>
  </li>
</ul>

<h3 id="tangent--summary-of-important-directives-for-utop">Tangent:  Summary of Important Directives for <code>utop</code></h3>
<ul>
  <li><code>show_val</code> - shows the type of a value</li>
  <li><code>#show_type</code> - expands a type definition (if it has an expansion)</li>
  <li><code>#show_module</code> - shows all the elements inside a particular module <em>or functor</em></li>
  <li><code>#show_module_type</code> - as previous but for module types</li>
  <li><code>#show</code> - the above four condensed into one command</li>
  <li><code>#require</code> - loads a library (does not <code>open</code> it, just loads the module)</li>
  <li><code>#use "afile.ml"</code> - loads code file as if it was copied and pasted into the top loop.</li>
  <li><code>#mod_use</code> - like <code>#use</code> but loads the file like it was a module (name of file as a module name)</li>
  <li><code>#load "blah.cmo"</code>, <code>#load "blahlib.cma"</code> - load a compiled binary or library file.</li>
  <li><code>#use_output "dune top"</code> - run a command and assume output is top loop input commands.
    <ul>
      <li>The particular argument <code>dune top</code> here generates top loop commands to load the current project.</li>
      <li>If <code>dune utop</code> is not working this is very similar but less glitchy.</li>
    </ul>
  </li>
  <li><code>#directory adir</code> - adds <code>adir</code> to the list of directories to search for files.</li>
  <li><code>#pwd</code> - shows current working directory.</li>
  <li><code>#cd</code> - changes directory for loads etc.</li>
  <li><code>#trace afun</code> - subsequent calls and returns to <code>afun</code> will now be dumped to top level - a simple debugging tool.</li>
  <li><code>#help</code> - in case you forget one of the above</li>
</ul>

<p>Also, standard edit/search keys work in <code>utop</code>:</p>
<ul>
  <li>control-R searches for a previous input with a certin string in it</li>
  <li>control-P / control-N go up and down to edit, control-A is start of line, control-E is end, control-D deletes current</li>
  <li>up/down arrow go to previous/next inputs</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
