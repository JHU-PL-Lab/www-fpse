<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="more-modules-and-libraries">More Modules and Libraries</h2>

<h3 id="tangent-ppx_jane-and-deriving">Tangent: <code>ppx_jane</code> and <code>deriving</code></h3>

<ul>
  <li>Recall <code>[@@deriving equal]</code> in the nucleotide example to get an <code>=</code> on that type:</li>
</ul>

<pre><code class="language-ocaml">(* Needs #require "ppx_jane";; in top loop, 
   and (preprocess (pps (ppx_jane))) in as part of the library declaration 
   (i.e. it is (library (name ..)  .. (preprocess ... )) - one of the library decl components) *)
# type nucleotide = A | C | G | T [@@deriving equal];;
type nucleotide = A | C | G | T
val equal_nucleotide : nucleotide -&gt; nucleotide -&gt; bool = &lt;fun&gt;
</code></pre>

<ul>
  <li>The <code>[@@zibbo...]</code> indicates the type declaration is processed by the macro named <code>ppx_zibbo</code></li>
  <li>The <code>equal</code> is a parameter to the macro, here it is which <code>deriving</code> extension is added</li>
  <li>The <code>[@@deriving equal]</code> in particular causes an <code>equal_nucleotide</code> function to be automatically generated</li>
  <li>Without this function we would have to use pattern matching to write our own equality.</li>
</ul>

<h4 id="composing-deriving-equal">Composing <code>deriving equal</code></h4>

<ul>
  <li>If we have an <code>xyy_equal</code> function on component types, <code>deriving</code> can derive <code>equal</code> for a type built from those components:</li>
</ul>

<pre><code class="language-ocaml"># type n_list = nucleotide list [@@deriving equal];;
type n_list = nucleotide list
val equal_n_list : n_list -&gt; n_list -&gt; bool = &lt;fun&gt;
# equal_n_list [A;A;A] [A;G;A];;
- : bool = false
# type n_queue = nucleotide Queue.t [@@deriving equal];;
type n_queue = nucleotide Core_kernel.Queue.t
val equal_n_queue : n_queue -&gt; n_queue -&gt; bool = &lt;fun&gt;
</code></pre>
<ul>
  <li>Notice that the <code>Core</code> libraries are designed to play well as they have <code>List.equal</code>, <code>Queue.equal</code> built in</li>
  <li>Generally for a component type that is the <code>t</code> of a module, the name looked for is <code>My_module.equal</code> instead of <code>t_equal</code></li>
  <li>Similarly, if we are making our own module with its carrier type <code>t</code> it will also generate <code>My_module.equal</code> if we use <code>[@@deriving equal]</code></li>
</ul>

<h3 id="some-other-useful-deriving-type-accessor-extensions-in-ppx_jane">Some other useful <code>@@deriving</code> type accessor extensions in ppx_jane</h3>

<ul>
  <li><code>sexp</code> generates S-expression printable representations of types which is handy for displaying data internals</li>
  <li>S-expressions are a general data format like JSON or XML, in fact they are the first such format</li>
</ul>

<pre><code class="language-ocaml"># type nucleotide = A | C | G | T [@@deriving equal, sexp];;
type nucleotide = A | C | G | T
val equal_nucleotide : nucleotide -&gt; nucleotide -&gt; bool = fun
val nucleotide_of_sexp : Sexp.t -&gt; nucleotide = fun
val sexp_of_nucleotide : nucleotide -&gt; Sexp.t = fun
 type n_list = nucleotide list [@@deriving equal, sexp];;
type n_list = nucleotide list
type n_list = nucleotide list
val equal_n_list : n_list -&gt; n_list -&gt; bool = fun
val n_list_of_sexp : Sexp.t -&gt; n_list = fun
val sexp_of_n_list : n_list -&gt; Sexp.t = fun
# sexp_of_n_list [A;G;G];;
- : Sexp.t = (A G G) (* this is the "S-Expression" version of a list.. parens and spaces *)
</code></pre>

<ul>
  <li><code>[@@deriving compare]</code> is analogous to <code>equal</code> except it makes a <code>compare</code> function instead of <code>equal</code></li>
</ul>

<pre><code class="language-ocaml"># type nucleotide = A | C | G | T [@@deriving compare];;
type nucleotide = A | C | G | T
val compare_nucleotide : nucleotide -&gt; nucleotide -&gt; int = fun
# compare_nucleotide A C;;
- : int = -1
utop # compare_nucleotide C A;;
- : int = 1
</code></pre>
<ul>
  <li><code>Core</code> does not have libraries for dealing with JSON unfortunately.</li>
  <li>But, someone else has made such a macro library, <code>ppx_deriving_yojson</code> which works with the <code>yojson</code> library to do something like what <code>deriving sexp</code> above did.</li>
  <li>With these libraries you can trivially define a to/from JSON format function on any type</li>
  <li>this will save wear and tear on your fingers, no need to convert.</li>
</ul>

<pre><code class="language-ocaml"># #require "ppx_deriving_yojson";; (* see the ppx_deriving_yojson docs linked in HW for `dune` use *)
# type nucleotide = A | C | G | T [@@deriving yojson];;
type nucleotide = A | C | G | T
val nucleotide_to_yojson : nucleotide -&gt; Yojson.Safe.t = fun
val nucleotide_of_yojson :
  Yojson.Safe.t -&gt; nucleotide Ppx_deriving_yojson_runtime.error_or = &lt;fun&gt;
# nucleotide_to_yojson A;;
- : Yojson.Safe.t = `List [`String "A"] (* This is an OCaml inferred variant type *)
</code></pre>

<p><strong>Aside</strong>: <code>ppx_deriving_yojson</code> is not currently compatible with <code>ppx_jane</code> so if you want to derive equality and comparisons along with <code>yojson</code> you need to use <code>#require "ppx_deriving.eq";; / [@@deriving eq]</code> and <code>#require "ppx_deriving.ord";; / [@@deriving ord]</code> in place of the <code>equal/compare</code> deriving in <code>ppx_jane</code>.</p>
<h2 id="defining-modules-in-the-top-loop">Defining Modules in the top loop</h2>

<ul>
  <li>We will now cover how you can define modules in the top loop.</li>
  <li>The main reason we are covering this is it will help us understand nested modules and functors (functions on modules), even when in files</li>
  <li>Basic idea to input a module in top-loop: write <code>module My_module = struct ... end</code> with file contents inserted into the “..” part</li>
  <li><code>struct</code> stands for structure, modules used to be called that in OCaml; view a <code>struct</code> as a synonym of a module.</li>
  <li>Simple set example put in top-loop syntax:</li>
</ul>

<pre><code class="language-ocaml"># module Simple_set = struct 
open Core
type 'a t = 'a list
let emptyset : 'a t = []
let add (x : 'a) (s : 'a t) = (x :: s)
let rec remove (x : 'a) (s: 'a t) (equal : 'a -&gt; 'a -&gt; bool) =
  match s with
  | [] -&gt; failwith "item is not in set"
  | hd :: tl -&gt;
    if equal hd x then tl
    else hd :: remove x tl equal
let rec contains (x: 'a) (s: 'a t) (equal : 'a -&gt; 'a -&gt; bool) =
  match s with
  | [] -&gt; false
  | hd :: tl -&gt;
    if equal x hd then true else contains x tl equal
end;;
module Simple_set :
  sig
    type 'a t = 'a list
    val emptyset : 'a t
    val add : 'a -&gt; 'a t -&gt; 'a t
    val remove : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; 'a t
    val contains : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; bool
  end
# Simple_set.emptyset;;
- : 'a list = []
</code></pre>

<ul>
  <li>Notice how it infers a module type (aka signature – <code>sig</code> at the start is for signature)</li>
  <li>We can also declare module types and explicitly declare along with the module</li>
  <li>Use <code>module type Type_name_here = ... type here ...</code> to declare module types (<code>.mli</code> file equivalents):</li>
</ul>

<pre><code class="language-ocaml">module type Simple_set = (* module and module type namespaces are distinct, can re-use name *)
  sig
    type 'a t (* Do some type hiding here *)
    val emptyset : 'a t
    val add : 'a -&gt; 'a t -&gt; 'a t
    val remove : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; 'a t
    val contains : 'a -&gt; 'a t -&gt; ('a -&gt; 'a -&gt; bool) -&gt; bool
  end
</code></pre>

<p>Then can replace <code>module Simple_set = struct .. end</code> with</p>
<pre><code class="language-ocaml">module Simple_set : Simple_set = struct ... end
</code></pre>

<p>and it will define the module with the above signature on it</p>

<h2 id="nested-modules">Nested modules</h2>

<ul>
  <li>Lets define <em>modules within modules</em>, which are very useful when libraries / applications are larger</li>
  <li>We are using many nested modules already, e.g. <code>Core.List.map</code> means <code>List</code> is just a module inside <code>Core</code>.</li>
  <li>Modules nest exactly as you would expect, just write a <code>module My_module = struct .. end</code> declaration<br />
 within a (file-based <em>or</em> top-loop-defined) module</li>
  <li>Here is an example
    <ul>
      <li>(note we will do top-loop version here, could remove top/bottom two lines and put in file)</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">module Super_simple_core = struct
  module Simple_set = Simple_set (* previously typed in above *)
  module List = Core.List (* just borrow Core's list for our Super_simple_core *)
end
</code></pre>

<h3 id="functors">Functors</h3>

<ul>
  <li>Functors are simply parametric modules, i.e. functions from modules to modules</li>
  <li>They let us define a generic code library to which we can plug in some concrete code
    <ul>
      <li>in other words, just like what higher-order functions do except for modules</li>
    </ul>
  </li>
  <li>Note that you don’t want to make every dependent module a parameter, instead use the normal convention in most PLs of referencing one module in another
    <ul>
      <li><code>dune</code> automatically makes referenced libraries available</li>
    </ul>
  </li>
  <li>Functors are needed when the parameter module can be more than one thing.
    <h4 id="simple-functors-example">Simple Functors Example</h4>
  </li>
  <li>Lets use a functor to fix the problem of the <code>equal</code> function needed as a parameter to <code>remove</code> and <code>contains</code> on our <code>Simple_set</code> module.</li>
  <li>(Note the <code>Core</code> libraries also do this for <code>Core.Set</code> for example)</li>
</ul>

<pre><code class="language-ocaml">(* The following module type is "some data type plus = on it" *)
module type Eq = sig 
type t
val equal: t -&gt; t -&gt; bool 
end

module Simple_set_functor (M: Eq) = 
struct
open Core
type t = M.t list
let emptyset : t = []
let add (x : M.t) (s : t) = (x :: s)
let rec remove (x : M.t) (s: t) =
  match s with
  | [] -&gt; failwith "item is not in set"
  | hd :: tl -&gt;
    if M.equal hd x then tl
    else hd :: remove x tl
let rec contains (x: M.t) (s: t) =
  match s with
  | [] -&gt; false
  | hd :: tl -&gt;
    if M.equal x hd then true else contains x tl
end
</code></pre>

<ul>
  <li>Notice how the type that was polymorphic, <code>'a</code> in the original <code>Simple_set</code>, is <code>M.t</code> here – we are taking the type from the <code>Eq</code> module, that is the type we need.
    <ul>
      <li>In general there are many such programming patterns where types are treated more like data in OCaml – adds to the power.</li>
    </ul>
  </li>
  <li>This is a great example of the usefulness of functors - many different possible types and their equivalences could be supplied with different <code>M</code>’s.
    <h3 id="using-functors">Using functors</h3>
  </li>
  <li>Pass a module to a functor to make a new module</li>
  <li>In other words, just like function application but on modules</li>
</ul>

<pre><code class="language-ocaml"># module String_set = Simple_set_functor(String);;
module String_set :
  sig
    type t = string list
    val emptyset : t
    val add : string -&gt; t -&gt; string list
    val remove : string -&gt; t -&gt; string list
    val contains : string -&gt; t -&gt; bool
  end
</code></pre>
<ul>
  <li>Note that we passed in a <code>String</code> module where the parameter had the <code>Eq</code> module type - why did this work?</li>
  <li>Answer: <code>String.t</code> is the underlying type of the string, and <code>String.equal</code> exists as an equality operation on strings, so <code>String</code> matches the <code>Eq</code> module type</li>
  <li>(<code>utop</code> command <code>#show_module String</code> will dump the full module if you want to verify <code>t</code> and <code>equal</code> are there)</li>
  <li>Note <code>String</code> also has a whole <strong>ton</strong> of other functions, types, etc
    <ul>
      <li>but like with subclasses or Java interfaces you match a <code>sig</code> if you have “at least” the stuff needed.</li>
    </ul>
  </li>
  <li>Here is one way you can test if a module matches a module type:</li>
</ul>

<pre><code class="language-ocaml"># module String2 = (String : Eq);;
module String2 : Eq
# module String2 : Eq = String;; (* Equivalent way to write the above *)
module String2 : Eq
</code></pre>
<ul>
  <li>This declares a new module <code>String2</code> which is <code>String</code> matched against the <code>Eq</code> type.</li>
  <li>Note that <code>String2</code> is restricted to <em>only</em> have <code>t</code>/<code>equal</code> with this declaration</li>
</ul>

<h3 id="instantiating-functors-with-our-own-custom-type">Instantiating functors with our own custom type</h3>
<p>Here is how we could instantiate the <code>Simple_set_functor</code> with our own data type</p>

<pre><code class="language-ocaml"># #require "ppx_jane";;
# module Nucleotide = struct type t = A | C | G | T [@@deriving equal] end;;
module Nucleotide : sig type t = A | C | G | T val equal : t -&gt; t -&gt; bool end
# module Nuc_set = Simple_set_functor(Nucleotide);;
module Nuc_set :
  sig
    type t = Nucleotide.t list
    val emptyset : t
    val add : Nucleotide.t -&gt; t -&gt; Nucleotide.t list
    val remove : Nucleotide.t -&gt; t -&gt; Nucleotide.t list
    val contains : Nucleotide.t -&gt; t -&gt; bool
  end
</code></pre>

<ul>
  <li>Note this requires us to make a module out of our type</li>
  <li>(also note that we used <code>[@@deriving equal]</code> to make the <code>equal</code> for free)
    <ul>
      <li>(and note it is given the name <code>Nucleotide.equal</code> and not <code>Nucleotide.equal_nucleotide</code>, since it is in a module and is the type <code>t</code> there)</li>
    </ul>
  </li>
</ul>

<h4 id="types-of-functors">Types of functors</h4>

<ul>
  <li>Functors also have types; OCaml inferred a type for <code>Simple_set_functor</code> above but we can also declare it:</li>
</ul>

<pre><code class="language-ocaml"># module type SSF = functor (M : Eq) -&gt;
    sig
      type t = M.t list
      val emptyset : t
      val add : M.t -&gt; t -&gt; t
      val remove : M.t -&gt; t -&gt; t
      val contains : M.t -&gt; t -&gt; bool
    end;;
</code></pre>
<ul>
  <li>Observe the type is generally <code>functor (M : Module_type) -&gt; sig ... end</code></li>
  <li>Notice how the argument module <code>M</code> occurs in the result type since it has types in it</li>
  <li>Such a type is called a <em>dependent type</em></li>
</ul>

<h3 id="type-hiding">Type Hiding</h3>

<ul>
  <li>The above implemetation of our simple set functor does not hide the fact that the underlying implementation is lists</li>
  <li>Recall the goal of “abstract data types (ADTS)” is for programmers to avoid exposing implementations</li>
  <li>But, hiding is harder here than in the non-functor version: once we supply the <code>=</code> we have also fixed the type.  So e.g. <code>emptyset</code> is not polymorphic, it cannot be type <code>'a t</code> any more.</li>
  <li>One solution is to hide the type completely in the functor type:</li>
</ul>

<pre><code class="language-ocaml">module type SSF_hidden = functor (M : Eq) -&gt;
    sig
      type t (* hide the type completely, no longer 'a t *)
      val emptyset : t
      val add : M.t -&gt; t -&gt; t
      val remove : M.t -&gt; t -&gt; t
      val contains : M.t -&gt; t -&gt; bool
    end;;
    module Simple_set_functor_hidden = (Simple_set_functor : SSF_hidden)
    module String_set_hidden = Simple_set_functor_hidden(String);;
</code></pre>

<h3 id="cores-set-map-hash-table-etc"><code>Core</code>’s Set, Map, Hash table, etc</h3>

<ul>
  <li>The <code>Core</code> advanced data structures support something similar to what we did above
    <ul>
      <li>“plug in the comparison in an initialization phase and then forget about it”</li>
    </ul>
  </li>
  <li>Here for example is how you make a map where the key is a built-in type (which has an associated module)</li>
</ul>

<pre><code class="language-ocaml"># module FloatMap = Map.Make(Float);; (* Or Char/Int/String/Bool/etc *)
module FloatMap :
  sig ... end
</code></pre>

<ul>
  <li>Note it requires a bit more than just the type and comparison to be in <code>Float</code> for this to work with <code>Core</code></li>
  <li>to/from S-expression conversions needed; use <code>[@@deriving compare, sexp]</code> on your own type:</li>
</ul>

<pre><code class="language-ocaml">#require "ppx_jane";;
# module IntPair = struct
type t = int * int [@@deriving compare, sexp]
end;;
module IntPair :
  sig
    type t = int * int
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexplib0.Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
# module IPMap = Map.Make(IntPair);;
module IPMap :
  sig ... end
# module IPSet = Set.Make(IntPair);;  (* Sets in Core also need compare (sorts internally) *)
...
# IPSet.(empty |&gt; Fn.flip add (1,2) |&gt; Fn.flip add (3,2) |&gt; Fn.flip add (3,2) |&gt; to_list);;
- : IntPair.t list = [(1, 2); (3, 2)]
</code></pre>

<p>Observe that only non-parametric types can be keys for maps:</p>

<pre><code class="language-ocaml"># module FloatMap = Map.Make(List);;
Line 1, characters 27-31:
Error: Signature mismatch:
       ...
       Type declarations do not match:
         type 'a t = 'a list
       is not included in
         type t
       They have different arities.
       File "src/map_intf.ml", line 29, characters 2-35: Expected declaration
       File "src/list.mli", line 12, characters 0-48: Actual declaration
</code></pre>

<ul>
  <li>Mildly annoying solution: explictly make a module for the list type you care about:</li>
</ul>

<pre><code class="language-ocaml"># module SList = struct type t = string list [@@deriving compare,sexp] end;;
module SList :
  sig
    type t = string list
    val compare : t -&gt; t -&gt; int
    val t_of_sexp : Sexp.t -&gt; t
    val sexp_of_t : t -&gt; Sexp.t
  end
# module SListMap = Map.Make(SList);;
module SListMap :
  sig ... end
</code></pre>
<p>Simpler way to do above: can inline the module definition, no need to name it</p>
<pre><code class="language-ocaml"># module SListMap = Map.Make(struct type t = string list [@@deriving compare,sexp] end);;
module SListMap :
  sig .. end
</code></pre>
<ul>
  <li>The above is a map where the <em>keys</em> are lists of strings</li>
  <li>The above examples show how non-trivial data structures can be map keys</li>
  <li>Here is the opposite, how we can make e.g. a variant with maps in it.</li>
  <li>This assumes the keys are integer pairs, and the values can be any type (<code>'a</code>)</li>
</ul>

<pre><code class="language-ocaml"># type 'a intpairmaptree = Leaf | Node of ('a IPMap.t) * 'a intpairmaptree * 'a intpairmaptree;; 
type 'a intpairmaptree =
    Leaf
  | Node of 'a IPMap.t * 'a intpairmaptree * 'a intpairmaptree
</code></pre>

<h3 id="larger-example-using-coremap">Larger Example Using Core.Map</h3>
<ul>
  <li>We will go over the code of <a href="../examples/school.ml">school.ml</a>, simple code that uses a <code>Core.Map</code>.</li>
  <li>Note that there is a fancier way than <code>Map.Make</code> using advanced features we will cover in detail later: <em>first-class modules</em>.
    <ul>
      <li>We will look at <a href="../examples/cool_school.ml">cool_school.ml</a> which re-writes the <code>school.ml</code> example to use first-class modules</li>
      <li>The advantage of this code is you don’t need to make a new module for every type you use it at</li>
      <li>Imagine if for every <code>List</code> type we had to make an <code>IntList</code>, <code>StringList</code> etc module - painful!</li>
      <li>(<code>List</code> itself avoids this problem by not being comparison-friendly, we had to pass in <code>compare</code> to <code>List.sort</code> for example)</li>
    </ul>
  </li>
</ul>

<h3 id="a-few-other-module-features-include-and-with">A few other module features: <code>include</code> and <code>with</code></h3>

<h4 id="include"><code>include</code></h4>

<ul>
  <li><code>include</code> is pretty straightforward, it “copies/pastes” one module or module type’s definitions inside a new definition.
    <pre><code class="language-ocaml"># module Sized_set = struct 
include Simple_set 
let size (s : 'a t) = List.length s
end
</code></pre>
  </li>
  <li>This will make a new module <code>Sized_set</code> which is the same as <code>Simple_set</code> but with an added <code>size</code> function.</li>
  <li>Observe how <code>'a t</code> works to refer to a type in <code>Simple_set</code>, just like we had pasted all that stuff in.</li>
</ul>

<p>Similarly module types (and also functors) can use <code>include</code></p>

<pre><code class="language-ocaml">module type Size_set =
  sig
    include Simple_set
    val size : 'a t -&gt; int
  end
</code></pre>

<h4 id="with"><code>with</code></h4>

<ul>
  <li><code>with</code> is sometimes needed when you have a module type with an abstract <code>type t</code> (just the type name, no explicit definition)</li>
  <li>Sometimes you made it just <code>type t</code> not to hide it like we did in <code>simple_set.mli</code>, but because <strong>we didn’t know it</strong> - it is a generic type.</li>
  <li>This is common in functor parameter module types in particular, e.g. our <code>Eq</code> above has a <code>type t</code> which is intended to be generic, not hidden.</li>
  <li>
    <p>Above everything worked fine because <code>t</code> was only a parameter, but if the functor result module type had a <code>type t</code> in it, it would be hidden and that might not be desired.</p>
  </li>
  <li>Example: here is a type of modules which contain pairs (a toy example)</li>
  <li>We want this to be generic over any type of pair so we let <code>l</code> and <code>r</code> be undefined
    <pre><code class="language-ocaml">module type Pair = 
sig
  type l
  type r
  type t = l * r
  val left : t -&gt; l
  val right : t -&gt; r
end;;
</code></pre>
    <p>OK lets make a concrete example of the above on <code>int</code> and <code>string</code></p>
    <pre><code class="language-ocaml">module Pair = struct 
 type l = int
 type r = string
 type t = l * r
 let left ((l:l), (r:r)) = l
 let right ((l:l), (r:r)) = r
end;;
</code></pre>
    <p>Now the problem is if we put the above signature on the module, we hid too much!<br />
```ocaml</p>
    <h1 id="module-matched_pair--pair--pair">module Matched_pair = (Pair : Pair);;</h1>
    <p>module Matched_pair : Pair</p>
    <h1 id="matched_pairleft-4hi">Matched_pair.left (4,”hi”);;</h1>
    <p>Line 1, characters 19-20:<br />
Error: This expression has type int but an expression was expected of type<br />
       Matched_pair.l</p>
    <h1 id="pairleft4hi--problem-was-the-module-type-pair-">Pair.left(4,”hi”);; (* problem was the module type Pair *)</h1>
  </li>
  <li>: int = 4<br />
```</li>
</ul>

<p>The solution is you can specialize abstract types in module types via <code>with</code>:</p>

<pre><code class="language-ocaml"># module Matched_pair = (Pair : Pair with type l = int with type r = string);;
module Matched_pair :
  sig
    type l = int
    type r = string
    type t = l * r
    val left : l * r -&gt; l
    val right : l * r -&gt; r
  end
# Matched_pair.left (4,"hi");;
- : int = 4
</code></pre>
<p>Usually <code>with</code> is inlined like above, but it is just shorthand for defining a new module type:</p>

<pre><code class="language-ocaml"># module type Pair_int_string = Pair with type l = int with type r = string;;
module type Pair_int_string =
  sig
    type l = int
    type r = string
    type t = l * r
    val left : l * r -&gt; l
    val right : l * r -&gt; r
  end
</code></pre>

<h3 id="other-data-structures-in-core">Other Data Structures in <code>Core</code></h3>

<ul>
  <li><code>Core</code> has complete implementations of many classic data structures, many of which are built similarly with functor like <code>Map.Make</code></li>
  <li>Be careful on imperative vs functional, look carefully to see which it is</li>
  <li>Functional data structures in <code>Core</code>:
    <ul>
      <li><code>Set</code>, <code>Map</code>, <code>Doubly_linked</code> (list), <code>Fqueue</code>, <code>Fdeque</code> (functional (double-ended) queue)</li>
    </ul>
  </li>
  <li>Imperative data structures:
    <ul>
      <li><code>Stack</code> and <code>Queue</code> as we previously discussed (which don’t need <code>Make</code>/<code>compare</code>), plus <code>Hash_queue</code>, <code>Hash_set</code>, <code>Hashtbl</code> (mutable hashed queue/set/map),  <code>Linked_queue</code>,  <code>Bag</code> (a multi-set)</li>
    </ul>
  </li>
</ul>

<h3 id="tangent--summary-of-important-directives-for-utop">Tangent:  Summary of Important Directives for <code>utop</code></h3>
<ul>
  <li><code>#show_val</code> - shows the type of a value</li>
  <li><code>#show_type</code> - expands a type definition (if it has an expansion)</li>
  <li><code>#show_module</code> - shows all the elements inside a particular module <em>or functor</em></li>
  <li><code>#show_module_type</code> - as previous but for module types</li>
  <li><code>#show</code> - the above four condensed into one command</li>
  <li><code>#require</code> - loads a library (does not <code>open</code> it, just loads the module)</li>
  <li><code>#use "afile.ml"</code> - loads code file as if it was copied and pasted into the top loop.</li>
  <li><code>#mod_use</code> - like <code>#use</code> but loads the file like it was a module (i.e. like we typed <code>module Filename = struct ... contents of filename.ml ... end</code>)</li>
  <li><code>#load "blah.cmo"</code>, <code>#load "blahlib.cma"</code> etc - load a compiled binary or library file (only the <code>.cmo/a</code> versions, the bytecode compiler).</li>
  <li><code>#use_output "dune top"</code> - run a command and assume output is top loop input commands.
    <ul>
      <li>The particular argument <code>dune top</code> here generates top loop commands to load the current project.</li>
      <li>If <code>dune utop</code> is not working this is very similar but less glitchy.</li>
    </ul>
  </li>
  <li><code>#directory adir</code> - adds <code>adir</code> to the list of directories to search for files.</li>
  <li><code>#pwd</code> - shows current working directory.</li>
  <li><code>#cd</code> - changes directory for loads etc.</li>
  <li><code>#trace afun</code> - subsequent calls and returns to <code>afun</code> will now be dumped to top level - a simple debugging tool.</li>
  <li><code>#help</code> - in case you forget one of the above</li>
</ul>

<p>Also, standard edit/search keys work in <code>utop</code>:</p>
<ul>
  <li>control-R searches for a previous input with a certin string in it</li>
  <li>control-P / control-N go up and down to edit, control-A is start of line, control-E is end, control-D deletes current</li>
  <li>up/down arrow go to previous/next inputs</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
