<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="efficiency-in-functional-programming">Efficiency in Functional Programming</h2>

<ul>
  <li>Functional data structures:
    <ul>
      <li>at first they may feel super-inefficient</li>
      <li>but they are usually in practice fine even if asymptotic behavior is worse</li>
      <li>and, they are better in a few cases because past states “persist for free”</li>
    </ul>
  </li>
</ul>

<h3 id="functional-lists">Functional lists</h3>
<p>Let us review the most common OCaml data structure, <code>'a list</code>.</p>

<ul>
  <li><code>hd</code> and <code>tl</code> are O(1)</li>
  <li><code>List.nth</code> is O(n) – lists are not random access</li>
  <li><code>append l1 l2</code> is O(<code>length l1</code>) - cons each <code>l1</code> elt onto <code>l2</code> one by one</li>
</ul>

<p>Remember that sub-lists are shared since they are immutable</p>

<pre><code class="language-ocaml">let l1 = [1;2;3;... n] in
let l2 = 0    :: l1 in
let l3 = (-1) :: l1 in ..
</code></pre>

<ul>
  <li><code>l2</code> and <code>l3</code> share <code>l1</code> and all the above is O(1)</li>
  <li>if lists were mutable such sharing would not usually be possible!</li>
  <li>In general this shows there is a trade-off in that in some cases functional wins
    <ul>
      <li>more on this below
        <h3 id="case-study-monadic-minesweeper">Case Study: Monadic Minesweeper</h3>
      </li>
    </ul>
  </li>
  <li>Let us analyze the complexity of different implementations of the imperative Minesweeper.</li>
  <li>Assume a grid of n elements (a square-root n by square-root n grid)</li>
</ul>

<p>Our imperative implementation using a 2D array (<a href="../examples/mine_array.ml">this one</a>)</p>
<ul>
  <li>O(1) for each inc operation so O(n) in total.</li>
</ul>

<p>Hypothetic monadic state version</p>
<ul>
  <li>Take the imperative 2D array version, implement as state monad on list-of-strings (<a href="../examples/mine_monadic.ml">code in fact is here</a>)</li>
  <li>Each grid square increment will take O(n) since the whole grid has to be rebuilt with one change
    <ul>
      <li>can in fact share rhs of parts not incremented (as in append above) but means 1/2 n = O(n)</li>
    </ul>
  </li>
  <li>O(n) inc’s are performed total so it will be O(n^2).</li>
</ul>

<p>Alternative monad implementation as a Core.Map from keys (i,j) to characters:</p>
<ul>
  <li>lookup and increment will be O(log n) on average since Core.Map is implemented as a balanced search tree
    <ul>
      <li>one change to a Map’s tree is only log n because only one path in tree is changed, rest can be re-used</li>
      <li>(yes, one path down a binary tree is only 1/(log n)-th of the tree nodes, and the sub-trees can be reused)</li>
    </ul>
  </li>
  <li>So total time is O(n log n)</li>
</ul>

<p>Conclusion</p>
<ul>
  <li>For Minesweeper, O(n^2) is in fact fine as the grids are always “tiny” in a CPU sense</li>
  <li>But clearly in your “big data” app such a penalty could be intolerable</li>
  <li>In general there are some results indicating it should be possible to “only” pay a log n penalty on any data structure if one is clever.</li>
  <li>But, sometimes you need to get out the imperative <code>Array</code> and <code>Hashset</code> etc in OCaml.</li>
</ul>

<h4 id="when-fp-wins-many-related-worlds-algorithms">When FP wins: Many Related Worlds Algorithms</h4>
<ul>
  <li>Portions of immutable data structures can be shared without conflict
    <ul>
      <li>alluded to in the list sharing example above</li>
    </ul>
  </li>
  <li>So if an algorithm has many related stores in it the FP version can be superior</li>
  <li>Example: a simple transactional store monad (here is pseudocode)</li>
</ul>

<pre><code class="language-ocaml">module Transactional_store = struct
    type store = (* The type of the heap data here, say it is a Map *)
    (* In the monad type, pass two stores, one in-use one saved *)
    type 'a t = store * store -&gt; 'a * store * store 
    let bind (x : 'a t) ~(f: 'a -&gt; 'b t) : 'b t =
      fun (s : store * store) -&gt; let (x', s1', s2') = x s in f x' (s1', s2')
    let return (x : 'a) : 'a t = fun ss -&gt; (x, ss)
    let set (v : data) =
      fun (s1, s2) -&gt; ((),store_put s1 v,s2) (* update s1, pass along s2 *)
    let get () =
      fun (s1, s2) -&gt; (store_get s1,s1,s2) (* fetch data from s1 *)
    let save () = 
      fun (s1, s2) -&gt; ((),s1,s1) (* save the current store *)
    let rollback () = 
      fun (s1, s2) -&gt; ((),s2,s2) (* toss s1, rollback to the saved store s2 *)
  end
end
</code></pre>

<ul>
  <li>If the <code>store</code> in the above is say a Map, the <code>s1</code> and <code>s2</code> maps should be “nearly all shared” on average.</li>
  <li>So, copying and memory use minimized.</li>
  <li>The real benefit comes when there are <code>n</code> stores <code>s1</code>, …, <code>sn</code> with sharing</li>
  <li>Real World OCaml has a similar example comparing an <a href="https://dev.realworldocaml.org/maps-and-hashtables.html#time-complexity-of-hash-tables">(immutable) Map vs a (mutable) Hashtable</a></li>
</ul>

<h4 id="fp-and-paralellism">FP and paralellism</h4>

<ul>
  <li>If we know there are no side effects, any independent computation can be done in parallel</li>
  <li>Common example: <code>List.map</code> and other <code>.map</code>’s can apply <code>f</code> in parallel</li>
  <li>Multiple function arguments can be evaluated in parallel if they contain no effects</li>
  <li>… Referential transparency in general makes parallelism much easier</li>
  <li>Multicore OCaml is in beta, and will be released soon.</li>
</ul>

<h3 id="writing-more-efficient-functions">Writing more efficient functions</h3>

<ul>
  <li>We already covered some of this with tail recursion
    <ul>
      <li>tail recursion principle: if the last action in a function is a recursive call, compiler can optimize away the call stack</li>
    </ul>
  </li>
  <li>Let us consider that and a few other topics now.</li>
</ul>

<h4 id="memoization">Memoization</h4>

<ul>
  <li>If a function has no side effects it can easily be <em>memoized</em>
    <ul>
      <li>we saw in HW, took exponential fibbonicci to linear</li>
      <li>in general works when there are no effects in the function (and, we have an <code>=</code> defined on the arguments)</li>
      <li>As you know, implement by keeping a history of past input -&gt; output pairs and look up input in table first</li>
      <li>if the function is expensive and is often invoked on the same argument it will be very effective</li>
    </ul>
  </li>
  <li>Note that memoization implicitly needs a store for this past history</li>
  <li>Could use mutable store, but could also do the “state monad thing”
    <ul>
      <li>pass in and return the store in the memoized function</li>
    </ul>
  </li>
</ul>

<h3 id="coding-with-tail-recursion">Coding with tail recursion</h3>

<ul>
  <li>As we discussed earlier in the <a href="idiomatic-fp.html#tail-recursion">idiomatic fp topic</a>, left fold is tail-recursive whereas right fold is not</li>
  <li>In general it is somewhat random whether a given algorithm is tail-recursive or not</li>
  <li>But, we can re-factor many algorithms to be tail recursive</li>
  <li>A classic technique for this is <em>continuation passing style</em> aka CPS</li>
</ul>

<h4 id="continuation-passing-style-cps">Continuation Passing Style (CPS)</h4>

<ul>
  <li>Idea: pass the “rest of the computation” as an additional argument <code>c</code> to a function</li>
  <li>The last line of the function will be <code>c(..)</code> – call <code>c</code>.</li>
  <li>If <code>c</code> is the current function itself, it will be a tail call - efficient!
    <ul>
      <li>in general, if a whole series of calls is in CPS, no stack is needed.</li>
    </ul>
  </li>
  <li>See file <a href="../examples/continuation-trees.ml">continuation-trees.ml</a> for how to code tree fold using CPS.</li>
</ul>

<h4 id="cps-and-coroutines">CPS and coroutines</h4>

<ul>
  <li>We also saw continuations in <code>Lwt</code> where the “callback code” after an I/O operation was a function invoked later:</li>
</ul>

<pre><code class="language-ocaml">let* () = Lwt_io.printl "Hello," in
let* () = Lwt_io.printl "world!" in
Lwt.return ()
</code></pre>

<p>is really</p>

<pre><code class="language-ocaml">bind(Lwt_io.printl "Hello,") 
    (fun () -&gt; bind(Lwt_io.printl "world!") 
                   (fun () -&gt; Lwt.return ()))
</code></pre>

<p>– each of the 2nd arguments to bind is “the rest of the work”, the continuation.</p>

<ul>
  <li>In Algebraic Effects world we had explicit <code>'a continuation</code> types: the system packed up all the “rest of the work” code for us
    <ul>
      <li>they are not <em>encoded</em> as functions there, the continuations are <em>built-in</em></li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
