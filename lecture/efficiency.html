<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1191913911">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="efficiency-in-functional-programming">Efficiency in Functional Programming</h2>

<p>Functional data structures: <br />
    - Feel very inefficient at first<br />
    - This is supported by asymptotics<br />
    - But they are often fine in practice even if asymptotic behavior is worse<br />
    - in a few cases they are better because past states “persist for free”</p>

<p>We covered some of this in the <a href="https://pl.cs.jhu.edu/fpse/lecture/idiomatic-fp.html#efficiency">idiomatic FP lecture</a></p>

<h3 id="functional-lists">Functional lists</h3>
<p>Let us warm up reviewing <code>'a list</code> efficiency</p>

<ul>
  <li><code>hd</code> and <code>tl</code> are O(1)</li>
  <li><code>List.nth</code> is O(n) – lists are not random access</li>
  <li><code>append l1 l2</code> is O(<code>length l1</code>) - cons each <code>l1</code> elt onto <code>l2</code> one by one</li>
</ul>

<p>Remember that sub-lists are shared since they are immutable</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="o">...</span> <span class="n">n</span><span class="p">]</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span>    <span class="o">::</span> <span class="n">l1</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">::</span> <span class="n">l1</span> <span class="k">in</span> <span class="o">..</span>
</code></pre></div></div>

<ul>
  <li><code>l2</code> and <code>l3</code> share <code>l1</code> and all the above is O(1)</li>
  <li>if lists were mutable such sharing would not generally be possible!</li>
  <li>In general this shows there is a trade-off in that in some cases functional wins
    <ul>
      <li>more on this below
        <h3 id="case-study-monadic-minesweeper">Case Study: Monadic Minesweeper</h3>
      </li>
    </ul>
  </li>
  <li>Let us analyze the complexity of different implementations of the imperative Minesweeper.</li>
  <li>Assume a grid of n elements (a square-root n by square-root n grid)</li>
</ul>

<p>Our imperative implementation using a 2D array (<a href="https://pl.cs.jhu.edu/fpse/examples/mine_array.ml">this one</a>)</p>
<ul>
  <li>O(1) for each inc operation so O(n) in total.</li>
</ul>

<p>Hypothetic monadic state version</p>
<ul>
  <li>Take the imperative 2D array version, implement as state monad on list-of-strings (<a href="https://pl.cs.jhu.edu/fpse/examples/mine_monadic.ml">code is here, we will glimpse</a>)</li>
  <li>Each grid square increment will take O(n) since the whole grid has to be rebuilt with one change
    <ul>
      <li>there is some functional sharing of parts not incremented (as in list append above) but means 1/2 n = O(n)</li>
    </ul>
  </li>
  <li>O(n) inc’s are performed total so it will be O(n^2).</li>
</ul>

<p>Imagine an alternative monad implementation using a <code>Board</code> implemented as a <code>Core.Map</code> from keys <code>(i,j)</code> to characters:</p>
<ul>
  <li>lookup and increment will be O(log n) on average since <code>Core.Map</code> is implemented as a balanced binary search tree
    <ul>
      <li>one change to a Map’s tree is only log n because only one path in tree is changed, rest can be re-used</li>
      <li>(yes, one path down a binary tree is only 1/(log n)-th of the tree nodes, and the sub-trees can be reused)</li>
    </ul>
  </li>
  <li>So total time is O(n log n)</li>
</ul>

<p>Conclusion</p>
<ul>
  <li>For Minesweeper, O(n^2) is in fact fine as the grids are always “tiny” in a CPU sense</li>
  <li>But if this grid was instead a large image (pixel grid) this would be intolerable</li>
  <li>With correct functional data structure choices you can usually pay a log n “fee” which will often be fine</li>
  <li>But, sometimes you just need to get out the imperative <code>Array</code>, <code>Hashset</code> etc.</li>
</ul>

<h4 id="when-fp-wins-many-related-worlds-algorithms">When FP wins: Many Related Worlds Algorithms</h4>
<ul>
  <li>Portions of immutable data structures can be shared without conflict
    <ul>
      <li>alluded to in the list sharing example above</li>
    </ul>
  </li>
  <li>So if an algorithm has many related stores in it the FP version can be superior</li>
  <li>Example: a simple transactional store monad (here is pseudocode)
    <ul>
      <li>a transactional store is a memory where you might want to undo (“roll back”) some writes</li>
      <li>it is what is at the heart of a database implementation: if transactions conflict, roll back to past store</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Transactional_store</span> <span class="o">=</span> <span class="k">struct</span>
    <span class="k">type</span> <span class="n">store</span> <span class="o">=</span> <span class="c">(* The type of the heap data here, say it is a Map *)</span>
    <span class="c">(* In the monad type, pass two stores, one in-use one saved *)</span>
    <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="n">store</span> <span class="o">*</span> <span class="n">store</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="n">store</span> <span class="o">*</span> <span class="n">store</span> 
    <span class="k">let</span> <span class="n">bind</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="n">t</span> <span class="o">=</span>
      <span class="k">fun</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">store</span> <span class="o">*</span> <span class="n">store</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="p">(</span><span class="n">x'</span><span class="o">,</span> <span class="n">s1'</span><span class="o">,</span> <span class="n">s2'</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="n">s</span> <span class="k">in</span> <span class="n">f</span> <span class="n">x'</span> <span class="p">(</span><span class="n">s1'</span><span class="o">,</span> <span class="n">s2'</span><span class="p">)</span>
    <span class="k">let</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">ss</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ss</span><span class="p">)</span>
    <span class="k">let</span> <span class="n">set</span> <span class="p">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="o">=</span>
      <span class="k">fun</span> <span class="p">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(()</span><span class="o">,</span><span class="n">store_put</span> <span class="n">s1</span> <span class="n">v</span><span class="o">,</span><span class="n">s2</span><span class="p">)</span> <span class="c">(* update s1, pass along s2 *)</span>
    <span class="k">let</span> <span class="n">get</span> <span class="bp">()</span> <span class="o">=</span>
      <span class="k">fun</span> <span class="p">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">store_get</span> <span class="n">s1</span><span class="o">,</span><span class="n">s1</span><span class="o">,</span><span class="n">s2</span><span class="p">)</span> <span class="c">(* fetch data from s1 *)</span>
    <span class="k">let</span> <span class="n">save</span> <span class="bp">()</span> <span class="o">=</span> 
      <span class="k">fun</span> <span class="p">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(()</span><span class="o">,</span><span class="n">s1</span><span class="o">,</span><span class="n">s1</span><span class="p">)</span> <span class="c">(* save the current store *)</span>
    <span class="k">let</span> <span class="n">rollback</span> <span class="bp">()</span> <span class="o">=</span> 
      <span class="k">fun</span> <span class="p">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(()</span><span class="o">,</span><span class="n">s2</span><span class="o">,</span><span class="n">s2</span><span class="p">)</span> <span class="c">(* toss s1, rollback to the saved store s2 *)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>If the <code>store</code> in the above is say a Map, the <code>s1</code> and <code>s2</code> maps should be “nearly all shared” on average.</li>
  <li>So, copying and memory use minimized.</li>
  <li>The real benefit comes when there are <code>n</code> stores <code>s1</code>, …, <code>sn</code> with sharing</li>
  <li>Real World OCaml has a similar example comparing an <a href="https://dev.realworldocaml.org/maps-and-hashtables.html#time-complexity-of-hash-tables">(immutable) Map vs a (mutable) Hashtable</a> which we looked at earlier</li>
</ul>

<h4 id="fp-and-paralellism">FP and paralellism</h4>

<ul>
  <li>In pure FP with no side effects, any independent computation can be done in parallel</li>
  <li>Example: <code>List.map</code> could apply <code>f</code> on the list elements in parallel
    <ul>
      <li>but, reconstructing the list has to be in-order so only useful for slow-running <code>f</code>’s</li>
      <li>Also <code>fold</code> and the like can’t be easily parallelized since the <code>accum</code> needs to be passed along sequentially</li>
    </ul>
  </li>
  <li>Multiple function arguments can be evaluated in parallel if they contain no effects
    <ul>
      <li>Referential transparency in general makes parallelism much easier to get right</li>
    </ul>
  </li>
  <li>OCaml 5 has parallelism (threads with shared memory); we will take a <a href="https://github.com/ocaml-multicore/parallel-programming-in-multicore-ocaml">glimpse at a tutorial</a> to see how <code>Task</code> pools and <code>parallel_for</code> work.</li>
</ul>

<h3 id="writing-more-efficient-functions">Writing more efficient functions</h3>

<ul>
  <li>We already covered some of this with tail recursion
    <ul>
      <li>tail recursion principle: if the last action in a function is a recursive call, compiler can optimize away the call stack</li>
    </ul>
  </li>
  <li>Let us consider that and a few other topics now.</li>
</ul>

<h4 id="memoization">Memoization</h4>

<ul>
  <li>If a function has no side effects it can easily be <em>memoized</em>
    <ul>
      <li>we saw in HW, took exponential fibbonicci to linear</li>
      <li>in general works when there are no effects in the function (and, we have an <code>=</code> defined on the arguments)</li>
      <li>As you know, implement by keeping a history of past input -&gt; output pairs and look up input in table first</li>
      <li>if the function is expensive and is often invoked on the same argument it will be very effective</li>
    </ul>
  </li>
  <li>Note that memoization implicitly needs a store for this past history</li>
  <li>Could use mutable store, but could also use a state monad
    <ul>
      <li>pass in and return the store in the memoized function</li>
    </ul>
  </li>
</ul>

<h3 id="tail-recursion-and-cps">Tail recursion and CPS</h3>

<ul>
  <li>As we discussed earlier in the <a href="idiomatic-fp.html#tail-recursion">idiomatic fp topic</a>, left fold is tail-recursive whereas right fold is not</li>
  <li>And tail-recursive functions get optimized to not make call frames
    <ul>
      <li>Not only is memory saved but cache coherency is better so faster!</li>
    </ul>
  </li>
  <li>Moral: if efficiency is important try to re-factor to be tail recursive</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
