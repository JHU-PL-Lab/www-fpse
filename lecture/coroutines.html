<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="coroutines-for-asynchronous-concurrent-programming">Coroutines for Asynchronous Concurrent Programming</h2>

<p>Concurrency is needed for two main reasons</p>
<ol>
  <li>You want to run things in parallel for speed gain (multi-core, cluster, etc)</li>
  <li>You are waiting for a result from an I/O action
    <ul>
      <li>Disk read/write, network request, remote API call, etc</li>
      <li>(Sometimes also awaiting for internal actions such as time-outs)</li>
    </ul>
  </li>
</ol>

<p>In OCaml</p>
<ul>
  <li>Concurrency for speed gain is a work in progress: <strong>multi-core OCaml</strong>
    <ul>
      <li>Should be released in a year or so</li>
      <li>We plan on covering parts of the beta</li>
    </ul>
  </li>
  <li>
    <p>Concurrency to support asynchronous waiting: The <code>Lwt</code> and <code>Async</code> libraries</p>
  </li>
  <li>Local concurrency for speed is usually done via <em>threads</em>
    <ul>
      <li>fork off another computation with its own runtime stack etc but share the heap</li>
    </ul>
  </li>
  <li>But, threads are notoriously difficult to debug due to number of interleavings
    <ul>
      <li>100’s of patches have been added to help (channels, monitors, locks, ownership types, etc etc etc) but still hard</li>
    </ul>
  </li>
  <li>So, often better to use a simpler system focused on waiting for I/O if that is all you really need</li>
  <li>Key difference is no preemption - routine runs un-interrupted until it <em>chooses</em> to “yield”/”pause”.</li>
  <li>Means that computations are still <em>deterministic</em>, much easier to debug!</li>
  <li>Such an approach is known as <em>coroutines</em></li>
</ul>

<h3 id="coroutines-in-different-languages">Coroutines in different languages</h3>

<p>Coroutines are found in most modern PLs</p>
<ul>
  <li>Python has the built-in <a href="https://docs.python.org/3/library/asyncio-task.html">asyncio library</a></li>
  <li>JavaScript has built-in <code>async/await</code> syntax</li>
  <li>All other commonly-used languages have some third-party library</li>
</ul>

<p>In OCaml there are currently two competing libraries</p>
<ul>
  <li><code>Async</code> - a Jane Street library, very compatible with <code>Core</code> but not widely used so fewer other libraries use it.</li>
  <li><code>Lwt</code> - the standard library for coroutines in OCaml.</li>
  <li>We will cover <code>Lwt</code> primarily since you will likely have the most success with it on your projects.</li>
  <li>They are more or less the same in principle</li>
</ul>

<h3 id="principles-of-coroutines">Principles of Coroutines</h3>

<ul>
  <li>The key use of coroutines is for I/O operations which may block</li>
  <li><em>and</em>, they are not required to be run in a dependent sequence.
    <ul>
      <li>For example if you need to read one file and write a tranform to another file and that is it, there is no concurrency, no need for coroutines.</li>
      <li>But if there are some independent actions or events they are very useful, it will allow the actions to proceed concurrently in the OS layer.</li>
    </ul>
  </li>
</ul>

<h4 id="motivating-the-need">Motivating the Need</h4>

<ul>
  <li>Suppose you want to read a bunch of images from different places on the Internet.</li>
  <li>You can process them in the order they show up, no need to wait for all the images to come in</li>
  <li>Also (<strong>key</strong>), if one load is slow don’t block all the subsequent loads
    <ul>
      <li>kick them all off at the start, then process as they come in.</li>
    </ul>
  </li>
  <li>There could also be some sequencing requirements as well
    <ul>
      <li>e.g. once all images are in and processed or timed out, a collage is created.</li>
      <li>(note that implicit in the “timed out” is a timer which can abort some loads as well)</li>
    </ul>
  </li>
</ul>

<h4 id="idea-of-the-implementation">Idea of the implementation</h4>

<p>Q: How do we allow these loads to happen concurrently without fork/threads/parallelism?<br />
A: Split such I/O actions in two:</p>
<ol>
  <li>Issue image request and <code>pause</code></li>
  <li>Package up the processing code (the <em>continuation</em>) which will run when the load completes as a function</li>
  <li>Run the function when the load is done.</li>
</ol>

<p>It might seem awkward to package up the continuation as a function but we already did that!</p>

<p>Monad-think on the above:</p>

<pre><code class="language-ocaml">let img_load url =
bind (* code to issue image request and pause *) 
     (fun img -&gt; (* processing code to run after this image loaded*)
</code></pre>
<p>which is, in <code>let%bind</code> notation,</p>
<pre><code class="language-ocaml">let img_load url =
let%bind img = (* code to issue image request and pause *) in
  (* processing code to run after this image loaded*)
</code></pre>

<p>(Note, <code>Lwt</code> uses <code>let*</code> or <code>let%lwt</code> instead of <code>let%bind</code>; <code>Async</code> uses <code>let%bind</code>)</p>

<ul>
  <li>Observe how <code>bind</code> is naturally making the continuation a function</li>
  <li>So we will be using <code>bind</code> a lot when writing coroutine code in OCaml</li>
</ul>

<h3 id="the-full-loading-task-here">The full loading task here</h3>
<ul>
  <li>Suppose for simplicity there are only two images.</li>
  <li>We eventually need to wait for these loads to finish, here is how.</li>
</ul>

<pre><code class="language-ocaml">let p1 = img_load url1 in
let p2 = img_load url2 in
(* We immediately get to this line, the above just kicks off the requests *)
(* p1 and p2 are called "promises" for the actual values *)
(* They are the underlying monadic values, we will see that below *)
(* .. we can do any other processing here .. *)
(* When we finally need the results of the above we again use bind: *)
let* load1 = p1 in
let* load2 = p2 in ...
(* ... we will get here once both loads are finished -- promises fulfulled *)
</code></pre>

<ul>
  <li>The monad behind the scenes has a data structure holding all the continuations<br />
(the two image processing actions in this case)</li>
  <li>It will call those continuations when the low-level URL load has completed</li>
</ul>

<h2 id="lwt"><code>Lwt</code></h2>

<ul>
  <li>The above is some high level idea of the use of coroutines</li>
  <li>We will now fire up <code>Lwt</code> and get into the details
    <ul>
      <li>It is the most commonly used coroutine library; <code>Async</code> is part of <code>Core</code> but has much less usage.</li>
    </ul>
  </li>
</ul>

<p><a name="lwt"></a></p>

<p>To run <code>Lwt</code> you need to install it from the shell first:</p>

<pre><code class="language-sh">opam install lwt
</code></pre>

<p>Then in <code>utop</code> do</p>
<pre><code class="language-ocaml">#require "lwt";;
</code></pre>

<p>And you might also want to do this to put the functions at the top level and to enable <code>let*</code>.</p>
<pre><code class="language-ocaml"># open Lwt;;
# open Syntax;;
</code></pre>

<p>We will now review</p>

<ul>
  <li><a href="https://ocsigen.org/lwt/latest/manual/manual">Some of the manual</a></li>
  <li><a href="https://raphael-proust.github.io/code/lwt-part-1.html">this <code>Lwt</code> tutorial</a> which gets into how the internals work in Part 2.</li>
</ul>

<p><a name="async"></a></p>

<h2 id="async"><code>Async</code></h2>

<p>Here are some notes on <code>Async</code> which we don’t plan on covering in lecture.</p>

<ul>
  <li><code>Async</code> is another Jane Street library</li>
  <li>It is based on the notion of a <em>promise</em></li>
  <li>Promises have been around for a very long time but are gaining in popularity</li>
  <li>Many languages have libraries implementing some form</li>
  <li>In <code>Async</code> they are called deferreds, of type <code>Deferred.t</code></li>
</ul>

<h4 id="deferreds">Deferreds</h4>

<ul>
  <li>A <code>Deferred.t</code> is an action returning a result</li>
  <li>Until the action is forced, it won’t run (like laziness)</li>
  <li>When it is forced a result will be returned which is an <code>option</code>
    <ul>
      <li><code>None</code> will mean failure; I/O always needs failure case</li>
    </ul>
  </li>
  <li>Here is an example using <code>Async.Reader.file_contents</code>
    <ul>
      <li>reads a whole file into a string</li>
      <li>but, calls to it <em>immediately</em> return</li>
      <li>The file is not in fact read until the deferred is run</li>
      <li>This is a special file operation function part of <code>Async</code> to support deferreds.</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml"># #require "async";;
# #require "ppx_jane";;
# open Async;;
# let eventual_string = Reader.file_contents "update.py";;
val eventual_string : string Deferred.t = &lt;abstr&gt;
# Deferred.peek eventual_string;;
- : string option = None (* nothing has been done to force the Deferred to run *)
# eventual_string;; (* .. utop forces it to run implicitly - like Lazy.force but implicit *)
- : string =
"#!/usr/bin/python\...\n\n"
# Deferred.peek eventual_string;;
- : string option =
Some
 "#!/usr/bin/python\...\n\n"
</code></pre>
<ul>
  <li>An odd thing about the above is let-defining a <code>Deferred</code> will not run it
    <ul>
      <li>but, if it is directly fed into the top loop it will implicitly run</li>
      <li>this is becuase <code>utop</code> when it sees a direct deferred will run it and return the result</li>
    </ul>
  </li>
</ul>

<p>(Note the <code>Async</code> examples we base on <a href="https://dev.realworldocaml.org/concurrent-programming.html">Real World OCaml Chapter 15</a> which has a lot more than what we are covering)</p>

<h4 id="the-async-monad">The Async monad</h4>

<ul>
  <li><code>Lazy</code> and <code>Option</code> we saw it was often not hard to avoid the <code>bind</code>/<code>return</code> view</li>
  <li>This is also possible with <code>Async</code> but often I/O actions are sequenced and <code>bind</code>/<code>return</code> is thus very helpful.</li>
</ul>

<pre><code class="language-ocaml"># let uppercase_file (filename : string) : (unit Deferred.t) =
    let%bind s = Reader.file_contents filename in
        Writer.save filename ~contents:(String.uppercase s)
# uppercase_file "t.txt" (* this will implicitly run the Deferred above *)
- : unit = ()
# Reader.file_contents "t.txt"
- : string = "HELLO FOLKS!"
</code></pre>

<p><code>Deferred.return</code> does the normal wrapping thing, it defers a normal value</p>
<pre><code class="language-ocaml">let d = return(10);;
val d : int Deferred.t = &lt;abstr&gt;
# d;;
- : int = 10
</code></pre>

<h3 id="ivars">Ivars</h3>

<ul>
  <li>Deferred’s are in fact implemented with <code>Ivars</code></li>
  <li>Think of it as “the implementation of a promise”</li>
  <li>Often you can use library functions that are <code>Deferred</code> aware</li>
  <li>But using <code>Ivar</code> you can write your own</li>
  <li>Here is an example based on RWOC:</li>
</ul>

<pre><code class="language-ocaml"># let ivar = Ivar.create () (* Create an Ivar; think of it like a ref cell *)
val ivar : '_weak1 Ivar.t =
  {Async_kernel__.Types.Ivar.cell = Async_kernel__Types.Cell.Empty}
# let def = Ivar.read ivar  (* Read the contents of the promise -- an empty one now! *)
val def : '_weak2 Deferred.t = &lt;abstr&gt;
# Deferred.peek def
- : '_weak3 option = None (* It is nothing.  Typing `def;;` now will loop forever! *)
# Ivar.fill ivar "Hello" (* Fill a promise explicitly *)
- : unit = ()
# Deferred.peek def
- : string option = Some "Hello" (* Indeed it got filled *)
def;;
- : string = "Hello"
</code></pre>

<h3 id="making-the-monadic-bind-and-return">Making the monadic <code>bind</code> and return`</h3>

<ul>
  <li>Let us show how <code>bind</code> can be defined with <code>Ivar</code>s</li>
  <li>This will give us the complete picture of the monad</li>
  <li>Uses <code>upon : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit</code>
    <ul>
      <li>takes an <code>Ivar</code> (a promise), and when it is fulfilled runs the <code>('a -&gt; unit)</code> code</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">let bind' (d: 'a Deferred.t) ~(f:('a -&gt; 'b Deferred.t)) : 'b Deferred.t =
    let i = Ivar.create () in
    upon d (fun x -&gt; (* Run this first function when d is determined *)
             upon (f x) (* then run f x *)
                  (fun y -&gt; Ivar.fill i y)
           ); (* call the promise "filled" when f x is determined *)
    Ivar.read i (* this returns a Deferred so users can pull on it *)
</code></pre>

<p>We covered the basic concepts of <code>Async</code> above. See <a href="https://dev.realworldocaml.org/concurrent-programming.html">Real World OCaml Chapter 15</a> for larger examples including asynchronous http.</p>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
