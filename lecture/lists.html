<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1191913911">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="list-programming">List programming</h2>
<ul>
  <li>First we will do a few more recursive functions over lists</li>
  <li>Then we will show how the <code>Core.List</code> library functions allow a great many (most?) operations to be written without recursion</li>
  <li>This is <em>combinator programming</em>, solve a task by composing operations on a few standard combinators (‚Äúcombiners‚Äù)</li>
  <li>(Note for Assignment 1 Part I you will not be able to use the library combinators, they are for Part II)</li>
</ul>

<h4 id="reversing-a-list">Reversing a list</h4>

<ul>
  <li>Let us write a somewhat more interesting function, reversing a list.</li>
  <li>Lists are immutable so it is going to create a completely new list, not change the original.</li>
  <li>This style of programming is called ‚ÄúData structure corresponds to control flow‚Äù - the program needs to touch and reconstruct the whole data structure as it runs.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span>  <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">rev</span> <span class="n">tl</span> <span class="o">@</span> <span class="p">[</span><span class="n">hd</span><span class="p">]</span>
<span class="p">;;</span>
<span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* recall input list is the tree 1 :: ( 2 :: ( 3 :: [])) *)</span>
</code></pre></div></div>

<ul>
  <li>Correctness of a recursive function by induction: assume recursive call does what you expect in arguing it is overall correct.</li>
  <li>For this example, can assume <code>rev tl</code> always reverses the tail of the list,
    <ul>
      <li>(e.g. in computing <code>rev [1;2;3]</code> we match <code>hd</code> = <code>1</code> and <code>tl</code> = <code>[2;3]</code> and can assume <code>rev [2;3]</code> = <code>[3;2]</code> )</li>
    </ul>
  </li>
  <li>Given that fact, <code>rev tl @ [hd]</code> should clearly reverse the whole list
    <ul>
      <li>(e.g. <code>[3;2] @ [1]</code> = <code>[3;2;1]</code> for the example)</li>
    </ul>
  </li>
  <li>QED, the function is proved correct! (actually partially correct, this induction argument does not rule out infinite loops)</li>
</ul>

<p>Of course <code>rev</code> is also in <code>Core.List</code> since it is a common operation:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p><strong>Another Example: zero out all the negative elements in a list of numbers</strong></p>

<ul>
  <li>C solution: <code>for</code>-loop over it and mutate all negatives to 0</li>
  <li>OCaml immutable list solution: recurse on list structure, building the new list as we go</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">zero_negs</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span>  <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">if</span> <span class="n">hd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">hd</span><span class="p">)</span> <span class="o">::</span> <span class="n">zero_negs</span> <span class="n">tl</span>
<span class="k">in</span>
<span class="n">zero_negs</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
</code></pre></div></div>

<h3 id="corelist-library-functions">Core.List library functions</h3>

<ul>
  <li>We already saw a few of these previously, e.g. <code>List.rev</code> and <code>List.nth</code>.</li>
  <li><code>List</code> is a <strong>module</strong>, think fancy package.  It contains functions <em>plus</em> values <em>plus</em> types <em>plus</em> even other modules</li>
  <li><code>List</code> is itself in the module <code>Core</code> so the full name for <code>rev</code> is <code>Core.List.rev</code>
    <ul>
      <li>but we put an <code>open Core</code> in our <code>.ocamlinit</code> (and in the template for A1) so you can just write e.g. <code>List.rev</code></li>
    </ul>
  </li>
  <li>(Note that <code>List.hd</code> is also available, but you should nearly always be pattern matching to take apart lists; don‚Äôt use <code>List.hd</code> on the homework.)</li>
  <li>Let us peek at the documentation <a href="https://ocaml.org/p/core/v0.15.0/doc/Core/List/index.html"><code>Core.List</code></a> to see what is available; we will cover a few of them now.</li>
</ul>

<h4 id="some-simple-but-very-handy-list-library-functions">Some simple but very handy <code>List</code> library functions</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="p">[</span><span class="s2">"d"</span><span class="p">;</span><span class="s2">"ss"</span><span class="p">;</span><span class="s2">"qwqw"</span><span class="p">];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">is_empty</span> <span class="bp">[]</span><span class="p">;;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">last_exn</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* get last element; raises an exception if list is empty *)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">join</span> <span class="p">[[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];[</span><span class="mi">22</span><span class="p">;</span><span class="mi">33</span><span class="p">];[</span><span class="mi">444</span><span class="p">;</span><span class="mi">5555</span><span class="p">]];;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span> <span class="c">(* Usually the infix @ syntax is used for append *)</span>
</code></pre></div></div>
<h4 id="-and-their-types">‚Ä¶ And their types</h4>

<ul>
  <li>The types of the functions are additional hints to their purpose, get used to reading them</li>
  <li>Much of the time when you mis-use a function you will get a type error</li>
  <li>Recall that <code>'a list</code> etc is a polymorphic aka generic type, <code>'a</code> can be <em>any</em> type</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">is_empty</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">last_exn</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">join</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span><span class="p">;;</span>  <span class="c">(* We will do this one below *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>We coded <code>nth</code> and <code>rev</code> before, here is one more, <code>join</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">join</span> <span class="p">(</span><span class="n">l</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="kt">list</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span> <span class="c">(* "joining together a list of no-lists is an empty list" *)</span>
  <span class="o">|</span> <span class="n">l</span> <span class="o">::</span> <span class="n">ls</span> <span class="o">-&gt;</span> <span class="n">l</span> <span class="o">@</span> <span class="n">join</span> <span class="n">ls</span> <span class="c">(* "by induction assume (join ls) will turn list-of-lists to single list" *)</span>
</code></pre></div></div>

<h4 id="ocaml-tuples-and-some-list-library-functions-using-tuples">OCaml tuples and some <code>List</code> library functions using tuples</h4>

<ul>
  <li>Along with lists <code>[1;2;3]</code> OCaml has tuples, <code>(1,2.,"3")</code></li>
  <li>It is like a fixed-length list, but tuple elements <strong>can have different types</strong></li>
  <li>You can also pattern match on tuples</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">.,</span><span class="s2">"3"</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span> <span class="o">*</span> <span class="kt">string</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">.,</span> <span class="s2">"3"</span><span class="p">)</span>
<span class="o">#</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* a common error, parens not always needed so this is a singleton list of a 3-tuple, not a list of ints *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)]</span>
</code></pre></div></div>

<ul>
  <li>Here is a simple function to break a list in half using the <code>List.split_n</code> function
    <ul>
      <li>a pair of lists is returned by <code>split_n</code>, dividing it at the nth position</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">split_in_half</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">split_n</span> <span class="n">l</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);;</span>
<span class="n">split_in_half</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">99</span><span class="p">];;</span>
</code></pre></div></div>

<ul>
  <li>Now, using the <code>List.cartesian_product</code> function we can make all possible pairs of (front,back) elements
    <ul>
      <li>(Also observe how these OCaml combinators have overlap with math combinators we already knew)</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">all_front_back_pairs</span> <span class="n">l</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">front</span><span class="o">,</span> <span class="n">back</span> <span class="o">=</span> <span class="n">split_in_half</span> <span class="n">l</span> <span class="k">in</span> 
    <span class="nn">List</span><span class="p">.</span><span class="n">cartesian_product</span> <span class="n">front</span> <span class="n">back</span><span class="p">;;</span> <span class="c">(* observe how let can itself pattern match pairs *)</span>
<span class="k">val</span> <span class="n">all_front_back_pairs</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">all_front_back_pairs</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="o">=</span>
<span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="p">);</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="p">)]</span>
</code></pre></div></div>

<ul>
  <li>Fact: lists of pairs are isomorphic to pairs of lists (of the same length)</li>
  <li>zipping and unzipping library functions can convert between these two equivalent forms.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">unzip</span> <span class="o">@@</span> <span class="n">all_front_back_pairs</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">];;</span>
</code></pre></div></div>

<ul>
  <li>Note the use of <code>@@</code> here, recall it is function application but with ‚Äúloosest binding‚Äù, avoids need for parens</li>
  <li>Here is an even cooler way to write the same thing, with pipe operation <code>|&gt;</code> (based on shell pipe <code>|</code>)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">all_front_back_pairs</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">unzip</span><span class="p">;;</span>
</code></pre></div></div>
<ul>
  <li>In a series of pipes, the leftmost argument is data, and all the others are functions</li>
  <li>The data is fed into first function, output of first function fed as input to second, etc</li>
  <li>This is exactly what the shell <code>|</code> does with standard input / standard output.</li>
  <li>
    <p>Please use pipes as much as possible on Part II of Assignment 1 - will make the code more readable</p>
  </li>
  <li><code>List.zip</code> is the opposite of unzip: take two lists and make a single list pairing elements</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="nn">Core</span><span class="p">.</span><span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Ok</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="p">)]</span>
</code></pre></div></div>
<ul>
  <li>The strange result type is dealing with the case where the lists supplied may not be same length</li>
  <li>This type and value are hard to read, let us take a crack at it.</li>
  <li><code>((int * int) list) List.Or_unequal_lengths.t</code> is the proper parentheses.</li>
  <li><code>List.Or_unequal_lengths.t</code> is referring to the type <code>t</code> found in the <code>List.Or_unequal_lengths</code> module (a small module within the <code>List</code> module)
    <ul>
      <li>one of the great things about modules is they can also contain types (like C .h files but more principled)</li>
    </ul>
  </li>
  <li>We can use the <code>#show_type</code> directive in the top loop to see what <code>t</code> actually is:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">show_type</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span><span class="p">;;</span>
<span class="k">type</span> <span class="k">nonrec</span> <span class="k">'</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">'</span><span class="n">a</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Unequal_lengths</span>
</code></pre></div></div>
<ul>
  <li>This means the value is either <code>Ok(..)</code> or <code>Unequal_lenghts</code>, very similar to <code>result</code> or <code>option</code>
    <ul>
      <li>(Why don‚Äôt they just use one of those two here instead?? No idea!)</li>
    </ul>
  </li>
  <li>The <code>'a</code> here is the type parameter, more on those later so don‚Äôt sweat it now</li>
  <li>The latter case is for zipping lists of different lengths:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
<span class="nn">Core</span><span class="p">.</span><span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="nc">Unequal_lengths</span>
</code></pre></div></div>

<ul>
  <li>In the original same-length case we got the result from the first clause in this type, <code>Core.List.Or_unequal_lengths.Ok [(1, 4); (2, 5); (3, 6)]</code>.</li>
  <li>Note <code>List.zip_exn</code> will just raise an exception for unequal-length lists, avoiding all of this wrapper ugliness
    <ul>
      <li>but in larger programs we want to avoid exceptions at a distance so it is often worth the suffering</li>
    </ul>
  </li>
</ul>

<h4 id="zipunzip-and-currying">zip/unzip and Currying</h4>

<p>We should be able to zip and then unzip as a no-op, one should undo the other (we will use the <code>_exn</code> version to avoid the above error wrapper issue).</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">unzip</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">];;</span>
</code></pre></div></div>
<p>And the reverse should also work as it is an isomorphism:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">unzip</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">)];;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">16</span><span class="o">-</span><span class="mi">43</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">*</span> <span class="kt">int</span> <span class="kt">list</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span>
</code></pre></div></div>

<ul>
  <li>Oops! It fails.  What happened here?</li>
  <li><code>List.zip_exn</code> takes two curried arguments, lists to zip (its type is <code>'a list -&gt; 'b list -&gt; ('a * 'b) list </code>), whereas <code>List.unzip</code> returns a <em>pair of lists</em>.</li>
  <li>No worries, we can write a wrapper (an <em>adapter</em>) turning <code>List.zip_exn</code> into a version taking a pair of lists:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">zip_pair</span> <span class="p">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span> <span class="n">l</span> <span class="n">r</span> <span class="k">in</span> 
<span class="n">zip_pair</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">unzip</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">)];;</span>
<span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">)]</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">unzip</span><span class="o">|&gt;</span> <span class="n">zip_pair</span> <span class="p">;;</span> <span class="c">(* Pipe equivalent form *)</span>
</code></pre></div></div>
<ul>
  <li>Congratulations, we just wrote a fancy no-op function üòÅ</li>
  <li>The general principle here is a <em>curried</em> 2-argument function like <code>int -&gt; int -&gt; int</code> is <strong>isomorphic</strong> to <code>int * int -&gt; int</code></li>
  <li>The latter form looks more like a standard function taking multiple arguments and is the <strong>uncurried</strong> form.</li>
  <li>And we sometimes need to interconvert between the two representations</li>
  <li>This conversion is called <em>uncurrying</em> (curried to pair/triple/etc form) or <em>currying</em> (putting it into curried form)</li>
</ul>

<h4 id="curryuncurry-are-themselves-functions">Curry/Uncurry are themselves functions</h4>
<ul>
  <li>We can even write combinators which generically convert between these two forms - !</li>
  <li><code>curry</code>   - takes in uncurried 2-arg function and returns a curried version</li>
  <li><code>uncurry</code> - takes in curried 2-arg function and returns an non-curried version</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">curry</span> <span class="n">f</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">uncurry</span> <span class="n">f</span> <span class="o">=</span> <span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="p">;;</span>
</code></pre></div></div>
<p>Observe the types themselves in fact fully define their behavior:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">curry</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span>
<span class="n">uncurry</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span>
</code></pre></div></div>

<p>We can now use our new combinator to build <code>zip_pair</code> directly:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">zip_pair</span>  <span class="o">=</span> <span class="n">uncurry</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip_exn</span><span class="p">;;</span>
</code></pre></div></div>

<h4 id="one-last-higher-order-function-compose">One last higher-order function: compose</h4>

<p>Composition function g o f: take two functions, return their composition</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">));;</span>
<span class="n">compose</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>The type says it all again, <code>('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b</code></li>
  <li>Equivalent ways to code <code>compose</code> in OCaml:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>  <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">);;</span>
<span class="k">let</span> <span class="n">compose</span> <span class="n">g</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span>  <span class="n">x</span> <span class="o">|&gt;</span> <span class="n">f</span> <span class="o">|&gt;</span> <span class="n">g</span><span class="p">;;</span> <span class="c">(* This is the readability winner: feed x into f and f's result into g *)</span>
<span class="k">let</span> <span class="n">compose</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))));;</span>
</code></pre></div></div>

<ul>
  <li>We can express the Zip/unzip composition explicitly with <code>compose</code>:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="n">compose</span> <span class="n">zip_pair</span> <span class="nn">List</span><span class="p">.</span><span class="n">unzip</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">)];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">)]</span>
</code></pre></div></div>

<h4 id="list-module-functions-which-take-function-arguments"><code>List</code> module functions which take function arguments</h4>

<ul>
  <li>So far we have done the ‚Äúeasier‚Äù functions in <code>List</code>; the real meat are the functions taking other functions</li>
  <li>Think of these as ‚Äúrecursion patterns‚Äù, they will recurse over the list so you don‚Äôt have to <code>let rec</code>
    <ul>
      <li>makes functional code a lot easier to read once you are familiar with these ‚Äúrecursion combinators‚Äù</li>
    </ul>
  </li>
  <li>Lets warm up with <code>List.filter</code>: remove all elements not meeting a condition which we supply a function to check</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">]</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);;</span>
</code></pre></div></div>

<ul>
  <li>Cool, we can ‚Äúglue in‚Äù any checking function (boolean-returning, i.e. a <em>predicate</em>) and <code>List.filter</code> will do the rest</li>
  <li>Observe <code>List.filter</code> has type <code>'a list -&gt; f:('a -&gt; bool) -&gt; 'a list</code> ‚Äì the <code>f:</code> is declaring a <em>named argument</em>, we can put args out of order if we give name via <code>~f:</code> syntax:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">];;</span>
</code></pre></div></div>
<ul>
  <li>And, since OCaml functions are Curried we can leave off the list argument to make a generic remove-negatives function.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">remove_negatives</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);;</span>
<span class="n">remove_negatives</span>  <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">];;</span>
</code></pre></div></div>

<p>Note that you can either inline the function as a <code>fun</code> or can declare it in advance:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">gtz</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;;</span>
<span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="n">gtz</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">];;</span>
</code></pre></div></div>
<p>Usually for short functions it is better to inline them, it makes the code more readable.</p>

<p>Let us use <code>filter</code> to write a function determining if a list has any negative elements:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">has_negs</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">is_empty</span> <span class="o">|&gt;</span> <span class="n">not</span><span class="p">;;</span>
</code></pre></div></div>
<ul>
  <li>The example shows the power of pipelining, it is easier to see the processing order with <code>|&gt;</code></li>
  <li>This is a common operation so there is a library function for it as well: does there <em>exist</em> any element in the list where predicate holds?</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">has_negs</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">l</span><span class="p">;;</span>
</code></pre></div></div>
<p>Similarly, <code>List.for_all</code> checks if it holds for <em>all</em> elements.</p>

<h4 id="listmap">List.map</h4>

<ul>
  <li><code>List.map</code> is  super powerful, apply some operation we supply to every element of a list:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">]</span>
<span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="mi">0</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="kt">list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">true</span><span class="p">;</span> <span class="bp">false</span><span class="p">;</span> <span class="bp">true</span><span class="p">;</span> <span class="bp">false</span><span class="p">;</span> <span class="bp">true</span><span class="p">]</span>
<span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">)];;</span> <span class="c">(* turns list of number pairs into list of their sums *)</span>
</code></pre></div></div>

<h3 id="folding">Folding</h3>
<ul>
  <li>Some of the most powerful combinators are the folds: <code>fold_right</code>, and <code>fold_left</code> aka simply <code>fold</code>.</li>
  <li>They ‚Äúfold together‚Äù list data using an operator.</li>
  <li>Here for example is how we can summate all elements in a list using <code>fold_right</code></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">];;</span> <span class="c">(* this computes 3 + (5 + (7 + 0))  *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div></div>

<ul>
  <li>The <code>~f</code>  parameter is the binary operation to put between list elements, <code>+</code> in this example;</li>
  <li>The <code>~init</code> is needed because <code>+</code> is a binary operator so an initial value is needed to fold for 0/1 length lists</li>
  <li>For <code>fold_right</code> the <code>+</code> is parenthesized in <strong>right</strong>-associative form, that is the ‚Äúright‚Äù.  There is also a <code>fold_left</code>, below</li>
  <li>For the list <code>[1;2;3]</code>, <code>fold_right [1;2;3] ~f ~init</code> generally computes <code>f 1 (f 2 (f 3 init))</code></li>
  <li>In general, <code>fold_right [a1; ...; an] ~f ~init</code> computes <code>f a1 (f a2 (... (f an init) ...))</code>.</li>
</ul>

<h4 id="left-folding">Left folding</h4>
<ul>
  <li><code>List.fold_left</code> aka <code>List.fold</code> (use the latter syntax) puts the <code>~init</code> on the left:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">];;</span> <span class="c">(* this is ((0 + 3) + 5) + 7 *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">15</span>
</code></pre></div></div>

<ul>
  <li>For list <code>[1;2;3]</code>, <code>fold [1;2;3] ~init ~f</code> generally computes <code>f (f (f init 1) 2) 3</code></li>
  <li>
    <p>In general, <code>fold [e1;...;en] ~init ~f</code> computes <code>f (... f (f (f init e1) e2) e3 ...) en</code></p>
  </li>
  <li>Note that in the case above folding left or right gives the same answer;
    <ul>
      <li>that is because <code>+</code> is <em>commutative and associative</em>.</li>
    </ul>
  </li>
  <li>But e.g. <code>List.fold ~f:(-) ~init:0 [1;2]</code> is <code>(0 - 1) - 2</code> is <code>-3</code> and <code>List.fold_right ~f:(-) ~init:0 [1;2]</code> is <code>1 - (2 - 0)</code> is <code>-1</code></li>
</ul>

<h4 id="folds-over-more-general-functions-not-just-operators">Folds over more general functions, not just operators</h4>

<ul>
  <li>The type of <code>List.fold</code> is <code>'a list -&gt; init:'accum -&gt; f:('accum -&gt; 'a -&gt; 'accum) -&gt; 'accum</code></li>
  <li>Note how the two parameters of <code>f</code> need not be the same type</li>
  <li>The <code>'a</code> here is the type of the list elements</li>
  <li>The <code>'accum</code> is the type of the result being accumulated, which <em>could be different</em> than the type of list elements</li>
</ul>

<p>Here is a simple fold example where these types are different (here <code>'a</code> is <code>string</code> and <code>'accum</code> is <code>int</code>):</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"b"</span><span class="p">;</span><span class="s2">"c"</span><span class="p">]</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span><span class="err">`</span>
</code></pre></div></div>

<ul>
  <li>Recall using the above expansion that this <code>fold</code> computes <code>f (f (f 0 "a") "b") "c"</code> <br />
where <code>f</code> is <code>(fun accum -&gt; fun elt -&gt; accum + 1)</code></li>
  <li>Parameter <code>elt</code> is the list <em>element</em> and <code>accum</code> is the <em>accumulator</em>, the result thus far.</li>
  <li>Let us incrementally compute the above: <code>f 0 "a"</code> is going to throw away the <code>"a"</code> and return <code>0+1</code> so it is <code>1</code>.</li>
  <li>this result <code>1</code> is then the first parameter to <code>f</code> in the next call, <code>f (1) "b"</code> - it is the <code>accum</code>-ulated value.</li>
  <li>each call to <code>f</code> returns accum incremented by one and in the end we have computed the length of the initial list.</li>
</ul>

<p>We can also compute length with <code>fold_right</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span><span class="s2">"b"</span><span class="p">;</span><span class="s2">"c"</span><span class="p">]</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span><span class="err">`</span>
</code></pre></div></div>

<ul>
  <li>Notice that the arguments to <code>f</code> are swapped here compared to the <code>fold</code> left version
    <ul>
      <li>in <code>fold</code> <code>f</code> should be a <code>fun accum elt -&gt; ...</code> of type <code>('accum -&gt; 'a -&gt; 'accum)</code> and</li>
      <li>in <code>fold_right</code> it should be <code>fun elt accum -&gt; ...</code> of type <code>('a -&gt; 'accum -&gt; 'accum)</code></li>
    </ul>
  </li>
</ul>

<h4 id="a-few-more-fold-examples">A few more fold examples</h4>

<p>Here is more general use of <code>fold</code> where the accumulator is a different type than the list elements:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">map</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">@</span> <span class="p">[</span><span class="n">f</span> <span class="n">elt</span><span class="p">])</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="n">l</span>
</code></pre></div></div>

<p>This function is identical to <code>List.map</code> described above.  We can also implement <code>List.exists</code> above with fold:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">exists</span> <span class="n">l</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>  <span class="c">(* Note: ~f is **declaring** a named argument f *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">l</span>    <span class="c">(* ~f as an argument is shorthand for ~f:f *)</span>
  <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">false</span><span class="p">;;</span>
<span class="o">#</span> <span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">false</span>
<span class="o">#</span> <span class="n">exists</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span><span class="p">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</code></pre></div></div>

<h4 id="folding-and-efficiency">Folding and efficiency</h4>

<p>Here is possible code for <code>fold_right</code> to help understand it:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span> <span class="n">l</span> <span class="o">~</span><span class="n">init</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">hd</span> <span class="p">(</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span> <span class="n">tl</span> <span class="o">~</span><span class="n">init</span><span class="p">)</span>
</code></pre></div></div>

<p>Code for <code>fold</code> aka <code>fold_left</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold</span> <span class="n">l</span> <span class="o">~</span><span class="n">init</span> <span class="o">~</span><span class="n">f</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">fold</span> <span class="n">tl</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="p">(</span><span class="n">f</span> <span class="n">init</span> <span class="n">hd</span><span class="p">)</span> <span class="o">~</span><span class="n">f</span>
</code></pre></div></div>

<ul>
  <li>Note that the first parameter to f in <code>fold</code> is the accumulated value passed <em>down</em> and the second parameter is the current list value</li>
  <li>In <code>fold_right</code> on the other hand the <code>f</code> computation happens <em>after</em> the recursive call is complete.</li>
  <li>Fold left/right are good example contrasts of how you can accumulate a value up (<code>fold_right</code>) vs down (<code>fold</code>) the recursion</li>
</ul>

<p><code>fold</code> is in fact more efficient than <code>fold_right</code> so it is preferred all things being equal:</p>
<ul>
  <li>Observe how the value of the <code>fold</code> function above is what is directly returned from the recursion</li>
  <li>Such a function is <em>tail recursive</em></li>
  <li>The compiler doesn‚Äôt need to use a call stack for such functions since nothing happens upon return</li>
  <li>Important when lists get really long that you don‚Äôt use stack unless required.</li>
  <li>Observe that <code>fold_right</code> is not tail recursive, so it needs the stack and will be slower</li>
</ul>

<h4 id="fold_until"><code>fold_until</code></h4>

<ul>
  <li>Let us end on perhaps the most powerful <code>List</code> combinator of all, <code>fold_until</code>.</li>
  <li>This is an extention to <code>fold</code> adding the functionality of <code>break</code> of C etc looping but in a functional style.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">summate_til_zero</span> <span class="n">l</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_until</span> <span class="n">l</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span>
    <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="k">match</span> <span class="n">i</span><span class="o">,</span> <span class="n">acc</span> <span class="k">with</span>
        <span class="o">|</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span> <span class="nc">Stop</span> <span class="n">sum</span>
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="n">sum</span> <span class="o">-&gt;</span> <span class="nc">Continue</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">sum</span><span class="p">))</span>
    <span class="o">~</span><span class="n">finish</span><span class="o">:</span><span class="nn">Fn</span><span class="p">.</span><span class="n">id</span>
<span class="k">let</span> <span class="n">stz_example</span> <span class="o">=</span> <span class="n">summate_til_zero</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>The <code>Stop</code> variant is like break, here take <code>sum</code> as the final value</li>
  <li><code>Continue</code> wraps the continue-folding case, which adds <code>i</code> to running <code>sum</code> here.</li>
  <li><code>~finish</code> can post-process the result if the <code>Stop</code> case was not hit; <code>Fn.id</code> is <code>fun x -&gt; x</code>, no additional processing here.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
