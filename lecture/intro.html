<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h1 id="introduction-and-background">Introduction and Background</h1>

<h2 id="course-outline">Course Outline</h2>

<p>See the <a href="../dateline.html">Dateline</a></p>

<h2 id="what-is-functional-programming-fp">What is Functional Programming (FP)?</h2>

<ul>
  <li>It is a style of programming where functions are the centerpiece</li>
  <li>A key dimension is functions-as-data aka higher-order functions: functions can be passed to and returned from functions</li>
  <li>It emphasizes <em>immutability</em>: data structures that cannot be changed after being created</li>
  <li>Mathematical functions are implicitly immutable so FP aligns closely with math
    <ul>
      <li>Think about creating an <em>algebra</em> for the domain you are coding over</li>
      <li>It is much easier to write completely correct programs in an FP style for this reason</li>
    </ul>
  </li>
</ul>

<h3 id="history-in-brief">History in brief</h3>

<ul>
  <li>λ-calculus, 1930’s - developed by logicians (Church, Turing, Kleene, Curry, etc)
    <ul>
      <li>Logic proofs are formal constructions, expressed as programs in the λ-calculus</li>
      <li>The 1930’s λ-calculus is the core of a modern functional programming language</li>
      <li>But before computers existed so no running, only hand-calculation - !</li>
    </ul>
  </li>
  <li>Lisp, 1960’s (McCarthy)
    <ul>
      <li>λ-calculus is elegant, build a PL around it</li>
      <li>Goal application space: artificial intelligence programming</li>
      <li>Added list data to λ functions: <strong>Lis</strong>t <strong>P</strong>rocessing</li>
    </ul>
  </li>
  <li>Typed functional languages, 70’s &amp; 80’s: Milner’s ML and its descendents Haskell and OCaml
    <ul>
      <li>We will be using OCaml</li>
    </ul>
  </li>
  <li>Modern era: add FP as possibility in mainstream PLs: Python, JavaScript, Java, C++, etc.</li>
</ul>

<h3 id="imperative-vs-object-oriented-vs-higher-order-functional">Imperative vs Object-Oriented vs Higher-Order Functional</h3>

<ul>
  <li>Oversimplifying but these are the three modern schools</li>
  <li>More oversimplifying: “Imperative = C, OO = Java, FP = OCaml”</li>
  <li>Note many O-O languages now have functions, often called lambdas for the historical reference</li>
  <li>Goal of this course is to get deeply into the FP mode of programming, which can then be used in your favorite PL - Java, Python, C++, JavaScript, OCaml, etc.</li>
</ul>

<h3 id="imperative">Imperative</h3>

<ul>
  <li>Imperative also has functions, but there functions often have side effects (e.g. mutate some shared data structures)</li>
  <li>C has function pointers to pass around functions as data but they are not widely used and lack needed expressiveness (a topic we will cover later).</li>
</ul>

<h3 id="object-oriented-oo">Object-Oriented (OO)</h3>

<ul>
  <li>Objects tend to have “their” state encapsulated within their boundary</li>
  <li>It is usually mutable state - changes over time</li>
  <li>A function is like an object with one method, <code>call</code>, and with no fields</li>
  <li>But, that analogy doesn’t fully capture higher-order functions which is why <code>lambda</code> added to Java.</li>
</ul>

<h3 id="functional-fp">Functional (FP)</h3>

<ul>
  <li>As mentioned above, a key aspect is lack of mutation: more like a mathematical function, the output only depends on the input and it’s only output is the codomain value, not any side effects like printing, mutating, raising exceptions, etc.</li>
  <li>Lack of side effects is called “referential transparency” - variable values don’t change out from under you (follows how math behaves).</li>
  <li>Standard data structures not too different from imperative case: dictionaries, lists, etc, but can be <em>immutable</em> - instead of mutating, make a fresh copy.</li>
  <li>Allows for powerful new programming paradigms using functions as data.
    <ul>
      <li>Simple example is function composition operation: <code>g o f (x) = g(f(x))</code>: <code>o</code> takes two functions and returns a new function, their composition</li>
    </ul>
  </li>
  <li>Less good at supporting extension, no notion of subclass in common functional paradigms</li>
</ul>

<h3 id="who-wins">Who wins?</h3>
<p>Thesis:</p>
<ul>
  <li>Imperative often wins for low-level code: underlying machine instructions are in the imperative domain, will run faster.</li>
  <li>O-O often wins for super large apps with fairly shallow logic: UI’s, etc.</li>
  <li>Functional often wins for complex algorithms with deep inner logic, and also for data manipulation focus
    <ul>
      <li>Gets too confusing with mutation, and better composition of functions makes code easier to understand.</li>
    </ul>
  </li>
  <li>Of course this choice is never made in a vacuum: existing codebases and libraries, programmer experience, etc.</li>
</ul>

<h3 id="typed-functional-vs-untyped-functional">Typed Functional vs Untyped Functional</h3>

<ul>
  <li>There are typed FP languages (OCaml, Haskell, TypeScript, etc) and uptyped ones (Scheme, Clojure, Python, JavaScript)</li>
  <li>We are clearly in the types camp here with OCaml but there are trade offs
    <ul>
      <li>With types we have <em>type-directed programming</em>: types serve as a skeleton of the code structure, and often once all the type errors are fixed the code .. works!</li>
      <li>The downside is types can get in the way both in terms of code maintenance and in terms of expressiveness.</li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
