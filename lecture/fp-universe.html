<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h1 id="the-functional-programming-language-universe">The Functional Programming Language Universe</h1>

<ul>
  <li>“This is the Dawn of the Age of FP”, there are now many choices of FP languages</li>
  <li>There are both viable functional-focused languages as well as FP extensions to existing languages</li>
  <li>We review the landscape here so you can throw in some FP on your next Python/Java/C++/… project</li>
</ul>

<h2 id="functional-focused-languages">Functional-focused languages</h2>

<ul>
  <li>These are languages designed with FP in mind from the start</li>
  <li>Key features include
    <ul>
      <li>Immutable variables by default</li>
      <li>Libraries have immutable data structures</li>
      <li>Full higher-order functions (can pass and return functions to functions), currying, anonymous (<code>fun x -&gt; </code> functions), etc.</li>
      <li>Often also includes pattern matching and type inference</li>
    </ul>
  </li>
  <li>Note that you may see the term “persistent data structure”, we have been calling these “pure functional” or “immutable” data structures.
    <ul>
      <li>The term “persistent” has a longstanding meaning of surviving over multiple runs of a program so I  view “persistent data structure” as a very misleading term for immutable structure.</li>
    </ul>
  </li>
  <li>There are roughly two “schools”
    <ul>
      <li>ML school: static types, type-directed programming, type inference, polymorphism, pattern matching (OCaml, Standard ML, ReScript, Haskell, F#, Elm, etc)</li>
      <li>Lisp school: dynamically typed, flexible but no type-directed programming (Lisp, Scheme, Clojure, etc)</li>
    </ul>
  </li>
  <li>All of these functional languages should be very easy to learn now that you know OCaml.</li>
</ul>

<h2 id="ml-dialects">ML Dialects</h2>

<ul>
  <li>OCaml .. perhaps you have heard of that? :-)</li>
  <li>Standard ML is another variant of ML, but it has limited popularity these days</li>
  <li>F#, ReScript, and Elm are other ML-descended languages we cover briefly now</li>
</ul>

<h3 id="f">F#</h3>

<ul>
  <li><a href="https://fsharp.org">F#</a> is Microsoft’s ML-style language, it has all the main features of OCaml</li>
  <li>It integrates well with the MSFT toolchain, probably the main point of interest</li>
  <li>Here is an example from their tutorial; looks familiar, eh?</li>
</ul>

<div class="language-fsharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">square</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span>
<span class="k">let</span> <span class="n">isOdd</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">&lt;&gt;</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">sumOfOddSquares</span> <span class="n">nums</span> <span class="p">=</span>
    <span class="n">nums</span>
    <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">isOdd</span>
    <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">sumBy</span> <span class="n">square</span>

<span class="k">let</span> <span class="n">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">sumOfOddSquares</span> <span class="n">numbers</span>
<span class="n">printfn</span> <span class="s2">"The sum of the odd squares in %A is %d"</span> <span class="n">numbers</span> <span class="n">sum</span>

<span class="k">type</span> <span class="nc">Shape</span> <span class="p">=</span>
    <span class="p">|</span> <span class="nc">Square</span> <span class="k">of</span> <span class="n">side</span><span class="p">:</span> <span class="n">double</span>
    <span class="p">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="n">width</span><span class="p">:</span> <span class="n">double</span> <span class="p">*</span> <span class="n">length</span><span class="p">:</span> <span class="n">double</span>

<span class="k">let</span> <span class="n">getArea</span> <span class="n">shape</span> <span class="p">=</span>
    <span class="k">match</span> <span class="n">shape</span> <span class="k">with</span>
    <span class="p">|</span> <span class="nc">Square</span> <span class="n">side</span> <span class="p">-&gt;</span> <span class="n">side</span> <span class="p">*</span> <span class="n">side</span>
    <span class="p">|</span> <span class="nc">Rectangle</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">width</span> <span class="p">*</span> <span class="n">length</span>

<span class="k">let</span> <span class="n">square</span> <span class="p">=</span> <span class="nc">Square</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span>
<span class="n">printfn</span> <span class="s2">"The area of the square is %f"</span> <span class="p">(</span><span class="n">getArea</span> <span class="n">square</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="rescript-ex-reason">ReScript (ex-Reason)</h3>

<ul>
  <li><a href="https://rescript-lang.org">ReScript</a> is an interesting beast, it is a fork of OCaml in terms of features
    <ul>
      <li>But, with a somewhat different syntax not so loaded with historical oddities and kludges</li>
      <li>Compiler takes <code>.res</code> to <code>.bs.js</code> which can in turn run in a browser</li>
      <li><a href="https://rescript-lang.org/try">Here</a> is a playground where you can see how <code>.res</code> is turned into <code>.js.bs</code>.</li>
      <li><a href="https://reasonml.github.io/en/try">This playground</a> shows the close relation of ReScript and OCaml (and JavaScript) (it is in fact a Reason playground, the predecessor of ReScript)</li>
      <li><a href="https://rescript-lang.org/docs/manual/latest/newcomer-examples">Some small code examples</a> to get an idea of the syntax</li>
    </ul>
  </li>
</ul>

<h4 id="rescriptreact">ReScriptReact</h4>

<ul>
  <li>The main thrust behind ReScript is use of soundly-typed FP in web UI programming
    <ul>
      <li>Compare to TypeScript which is not sound and lacks type inference</li>
    </ul>
  </li>
  <li>ReScriptReact is the ReScript version of Facebook’s excellent React UI library</li>
  <li><a href="https://github.com/jihchi/rescript-react-realworld-example-app">Here</a> is an example of a full browser app written in ReScriptReact.
    <ul>
      <li>ReScriptReact counts as “OCaml” for the course projects, an option to consider if you already know React.</li>
    </ul>
  </li>
</ul>

<h3 id="elm">Elm</h3>

<ul>
  <li><a href="https://elm-lang.org">Elm</a> is an ML-school language</li>
  <li>Designed for writing web apps, it runs in the browser via translation to JS.
    <ul>
      <li>Similar to ReScriptReact in goal</li>
    </ul>
  </li>
</ul>

<h3 id="scala">Scala</h3>

<ul>
  <li>Scala is a hybrid of Java and ML which runs on the JVM so can link with Java libraries</li>
  <li>It is easier to do FP in compared to Java since it was built-in from the start: pattern matching, type inference, etc.</li>
</ul>

<h3 id="haskell">Haskell</h3>

<ul>
  <li>Haskell is an ML descendant, it shares a lot of the same syntax</li>
  <li>It is hard-core FP: no direct side effects at all, must use monads for every side-effect (ouch!)</li>
  <li>It was gaining in popularity but not as much recently, too hard-core for your average programmer</li>
  <li>Has some very cool features that OCaml does not have, e.g. type classes for principled operator overloading
    <h3 id="lisp--scheme--racket">Lisp / Scheme / Racket</h3>
  </li>
  <li>Lisp was the very first functional programming language, from the late 50’s
    <ul>
      <li>inspired by Church’s Lambda Calculus, circa 1934 - functional programming on paper</li>
      <li>Lisp is dynamically typed, the ancestor of all modern dynamically-typed languages such as Python, JavaScript, etc.  No type-directed programming in any of these!!</li>
      <li>Allows mutation everywhere (no immutable <code>let</code> or immutable lists), but “only mutate when really needed”.</li>
    </ul>
  </li>
  <li>Scheme was a clean-up of Lisp in the 70’s-80’s, there were several errors in the Lisp design
    <ul>
      <li>e.g. dynamic scoping – closures were not computed in Lisp. (see <a href="./fp-universe.html#closures">closures tangent below</a>)</li>
    </ul>
  </li>
  <li><a href="https://racket-lang.org">Racket</a> is a popular modern dialect of Scheme with many added features including types</li>
  <li><a href="https://clojure.org">Clojure</a> is another more modern Lisp dialect
    <ul>
      <li>Has more immutablility by default than Scheme and so can more cleanly support parallelism
        <ul>
          <li>Avoids race conditions on stateful data strutures</li>
        </ul>
      </li>
      <li>Runs on the Java JVM so lots of libraries</li>
    </ul>
  </li>
  <li>Additionally, Smalltalk, Ruby, Python, and JavaScript are descended from Lisp (more below on those)</li>
  <li>The Lisp school is generally in decline these days, <code>(the syntax (sucks) (since everything is just an s-expression (like this)))</code></li>
</ul>

<h2 id="fp-in-yourfavoritelang">FP in YourFavoriteLang</h2>

<ul>
  <li>It is now possible to do FP-style programming in Java, C++, Python, JavaScript, etc.</li>
  <li>All of these languages support higher-order functions with Currying, etc.
    <ul>
      <li>(Currying is usually not the default multi-arg approach as in OCaml, though)</li>
    </ul>
  </li>
  <li>There is not necessarily good library support or integration
    <ul>
      <li>So, at this point more “checking the FP box” than actual “doing FP”</li>
      <li>To “really do” FP you need immutable data structures and default-immutable variables</li>
    </ul>
  </li>
</ul>

<h3 id="fp-in-java">FP in Java</h3>

<p>Java 8+ has <strong>Lambdas</strong></p>

<ul>
  <li>Lambdas are clunky to use due to how they were patched in.</li>
  <li>Java 8 higher-order functions  “pun” as an interface with only one method in it, <code>apply</code>.
    <ul>
      <li>the function is taken to be the body of that single method, no need to write the method name when declaring the function then.</li>
    </ul>
  </li>
  <li>There is also some (limited) type inference for Lambda parameters (plus type inference in general via <code>var</code>)</li>
  <li>Currying in Java, somewhat painfully: <a href="https://gist.github.com/timyates/7674005">Gist currying example</a>. For that example here is the <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html">Function</a> and <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/BiFunction.html">BiFunction</a> type.</li>
  <li>Use <code>final</code> to declare variables immutable in Java - use it!</li>
  <li>There are no immutable data structures in the Java standard library unfortunately</li>
</ul>

<h3 id="fp-in-c11">FP in C++11</h3>

<ul>
  <li>Everyone is joining the Lambda party!</li>
  <li>Details <a href="http://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29">here</a>.</li>
  <li>Closures are a headache in C++ due to different low-level ways data can be accessed in C++.</li>
  <li>Use <code>const</code> declarations to get immutable variables</li>
  <li>C++ also has some type inference a la OCaml  <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference">C++ local type inference </a>
    <ul>
      <li>e.g. <code>auto mydata = 22;</code>. <code>auto</code> is like <code>var</code> in Java.</li>
    </ul>
  </li>
  <li>C++14 adds <a href="http://en.wikipedia.org/wiki/C++14#Generic_lambdas">generic lambdas</a> which look like the polymorphic types of OCaml/Java but are really just fancy macros.</li>
</ul>

<h3 id="fp-in-python">FP In Python</h3>

<ul>
  <li>Python “already has” FP including closures and Currying.  Here is a Curried add function.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
     <span class="k">def</span> <span class="nf">uni_adder</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
     <span class="k">return</span> <span class="n">uni_adder</span>
 
<span class="k">print</span> <span class="n">adder</span><span class="p">(</span><span class="mi">4</span><span class="p">)(</span><span class="mi">18</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>The above is a bit clunky since the intermediate function must be named</li>
  <li><code>map</code>, <code>filter</code>, <code>reduce</code> etc are already in the core libraries</li>
  <li>In addition, the <a href="https://docs.python.org/3/library/functools.html"><code>functools</code></a> standard library supports other convenience higher-order function operations</li>
  <li>Plus, if you want even more FP-ism, there are additional libraries such as <a href="https://toolz.readthedocs.io/en/latest/index.html">PyToolz</a></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">toolz</span> <span class="kn">import</span> <span class="n">curry</span>
<span class="o">@</span><span class="n">curry</span>
 <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">plusfour</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>     
</code></pre></div></div>

<ul>
  <li>PyToolz is a port of the Clojure FP libraries to Python</li>
  <li>Python is weak on immutable variables, there is no <code>const</code>/<code>final</code>
    <ul>
      <li>but the tuples and <code>frozenset</code> are immutable data structures</li>
      <li>and Python 3.8 finally has <code>final</code></li>
    </ul>
  </li>
  <li>Python 3.10 (finally!) has pattern matching - released Oct 2021.
    <ul>
      <li><a href="https://www.python.org/dev/peps/pep-0636/">tutorial</a></li>
    </ul>
  </li>
</ul>

<h3 id="fp-in-javascript-or-typescript">FP In JavaScript or TypeScript</h3>

<ul>
  <li>JavaScript is similar to Python, it has the basics built-in already</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">adder</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> 
<span class="p">{</span> <span class="k">return</span> <span class="kd">function</span> <span class="nx">uni_adder</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> 
    <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code>const</code> declarations bring the FP immutable variable default to JS - use it!</li>
  <li>JavaScript has no immutable data structures however
    <ul>
      <li>means e.g. lists won’t be able to share sub-structures so “FP programming” will be less efficient in JS.</li>
    </ul>
  </li>
</ul>

<p><a name="closures"></a></p>
<h3 id="terminology-aside-closure">Terminology aside: <em>closure</em></h3>

<ul>
  <li>A <em>closure</em> is just a higher-order function return value</li>
  <li>The term “closure” comes from how they are implemented – all variables not local to the function must be remembered</li>
  <li>OCaml example:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span> <span class="c">(* f is at runtime the closure "&lt;fun y code, {x |-&gt; 4}&gt;" *)</span>
<span class="o">#</span> <span class="n">f</span> <span class="mi">3</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Note how <code>x</code> is a function parameter and is remembered in spite of function returning, means <code>x</code> needs to be remembered, in the closure</p>
  </li>
  <li>Here is an encoding of the above idea in OCaml
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">in</span> <span class="c">(* return pair of function and non-local value *)</span>
<span class="k">let</span> <span class="n">apply_closure</span> <span class="p">(</span><span class="n">f</span><span class="o">,</span><span class="n">x</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="k">in</span> <span class="c">(* function application needs to pass in x from the closure *)</span>
<span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="n">f</span> <span class="mi">3</span> <span class="k">in</span> <span class="c">(* example of partial application: only one argument given *)</span>
<span class="n">apply_closure</span> <span class="n">add3</span> <span class="mi">5</span><span class="p">;;</span>
</code></pre></div>    </div>
  </li>
  <li>Closures are the key thing missing from C: C has <em>function pointers</em> you can pass around, but no closures.
    <ul>
      <li>It also doesn’t allow you to write anonymous functions (<code>fun x -&gt; ..</code>), etc, etc.</li>
    </ul>
  </li>
  <li>In C++ there is an issue of what format non-locals like <code>x</code> are: references, copies, or what.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
