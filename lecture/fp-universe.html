<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/assignment6.html">Assignment 6</a></li>
                <li><a href="/fpse/assignments/assignment7.html">Assignment 7</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/9034692226">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h1 id="the-functional-programming-language-universe">The Functional Programming Language Universe</h1>

<ul>
  <li>“This is the Dawn of the Age of FP”, there are now many choices of FP languages</li>
  <li>There are both viable functional-focused languages as well as FP extensions to existing languages</li>
  <li>We review the landscape here so you can us some FP on your next Python/Java(Script)/C++/… project</li>
</ul>

<p>Along with the FP there are some other things we covered that you can re-use in other langauges:</p>

<ul>
  <li>Quickchecking aka property-based testing aka random testing
    <ul>
      <li>Originated with Haskell but being ported to many languages now</li>
    </ul>
  </li>
  <li>Type-directed programming
    <ul>
      <li>You need a typed functional language subset for this (e.g. C++, TypeScript, etc)</li>
      <li>Note that it doesn’t work as well with imperative code, not as many type interfaces declared.</li>
    </ul>
  </li>
</ul>

<h2 id="functional-focused-languages">Functional-focused languages</h2>

<ul>
  <li>These are languages designed with FP in mind from the start</li>
  <li>Key features include
    <ul>
      <li>Immutable variables by default</li>
      <li>Libraries have immutable aka persistent data structures (immutable lists, trees, maps, etc)</li>
      <li>Full higher-order functions (can pass and return functions to functions), currying, anonymous (<code>fun x -&gt; ...</code> functions), etc.</li>
      <li>Often also includes pattern matching and type inference, but also may be dynamically-typed</li>
    </ul>
  </li>
  <li>There are two major “schools” of FP today
    <ul>
      <li>ML school: static types, type-directed programming, type inference, polymorphism, pattern matching (OCaml, Standard ML, ReScript, Haskell, F#, Elm, Scala, etc)</li>
      <li>Lisp school, dynamically typed: more flexible but no type-directed programming (Lisp, Scheme, Racket, Clojure, etc)</li>
    </ul>
  </li>
  <li>All of these true functional languages should be very easy to learn now that you know OCaml.</li>
</ul>

<h2 id="ml-dialects">ML Dialects</h2>

<ul>
  <li>OCaml .. perhaps you have heard of that? :-)</li>
  <li>Standard ML is another variant of ML, but it has limited popularity these days</li>
  <li>F#, ReScript, Elm, and Haskell are other ML-descended languages we cover briefly now</li>
</ul>

<h3 id="f">F#</h3>

<ul>
  <li><a href="https://fsharp.org">F#</a> is Microsoft’s ML-style language, it has all the main features of OCaml</li>
  <li>It integrates well with the MSFT toolchain, probably the main point of interest</li>
  <li>Here is an example from their tutorial to show how similar it is to OCaml:</li>
</ul>

<div class="language-fsharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">square</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span>
<span class="k">let</span> <span class="n">isOdd</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">&lt;&gt;</span> <span class="mi">0</span>

<span class="k">let</span> <span class="n">sumOfOddSquares</span> <span class="n">nums</span> <span class="p">=</span>
    <span class="n">nums</span>
    <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="n">isOdd</span>
    <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">sumBy</span> <span class="n">square</span>

<span class="k">let</span> <span class="n">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span>
<span class="k">let</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">sumOfOddSquares</span> <span class="n">numbers</span>
<span class="n">printfn</span> <span class="s2">"The sum of the odd squares in %A is %d"</span> <span class="n">numbers</span> <span class="n">sum</span>

<span class="k">type</span> <span class="nc">Shape</span> <span class="p">=</span>
    <span class="p">|</span> <span class="nc">Square</span> <span class="k">of</span> <span class="n">side</span><span class="p">:</span> <span class="n">double</span>
    <span class="p">|</span> <span class="nc">Rectangle</span> <span class="k">of</span> <span class="n">width</span><span class="p">:</span> <span class="n">double</span> <span class="p">*</span> <span class="n">length</span><span class="p">:</span> <span class="n">double</span>

<span class="k">let</span> <span class="n">getArea</span> <span class="n">shape</span> <span class="p">=</span>
    <span class="k">match</span> <span class="n">shape</span> <span class="k">with</span>
    <span class="p">|</span> <span class="nc">Square</span> <span class="n">side</span> <span class="p">-&gt;</span> <span class="n">side</span> <span class="p">*</span> <span class="n">side</span>
    <span class="p">|</span> <span class="nc">Rectangle</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">width</span> <span class="p">*</span> <span class="n">length</span>

<span class="k">let</span> <span class="n">square</span> <span class="p">=</span> <span class="nc">Square</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span>
<span class="n">printfn</span> <span class="s2">"The area of the square is %f"</span> <span class="p">(</span><span class="n">getArea</span> <span class="n">square</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="rescript-was-called-reason-until-2021">ReScript (was called Reason until ~2021)</h3>

<ul>
  <li><a href="https://rescript-lang.org">ReScript</a> is an interesting beast, it is a fork of OCaml in terms of features
    <ul>
      <li>It has different (improved!) syntax fixing the historical oddities and kludges of OCaml</li>
      <li>Target to web browsers: compiler (“bucklescript”) takes <code>.res</code> to <code>.bs.js</code> which can in turn run in a browser</li>
      <li><a href="https://rescript-lang.org/try">Here</a> is a playground where you can see how <code>.res</code> is turned into <code>.js.bs</code>.</li>
      <li><a href="https://reasonml.github.io/en/try">This playground</a> shows the close relation of ReScript and OCaml (and JavaScript) (it is in fact a Reason playground, the predecessor of ReScript)</li>
      <li><a href="https://rescript-lang.org/docs/manual/latest/newcomer-examples">Some small code examples</a> to get an idea of the syntax</li>
    </ul>
  </li>
</ul>

<h4 id="rescriptreact">ReScriptReact</h4>

<ul>
  <li>The main thrust behind ReScript is use of soundly-typed FP in web UI programming
    <ul>
      <li>Compare to TypeScript which is not sound and lacks type inference</li>
    </ul>
  </li>
  <li><a href="https://rescript-lang.org/docs/react/latest/introduction">ReScriptReact</a> is the ReScript version of Facebook’s excellent React UI library for web browsers</li>
  <li><a href="https://github.com/jihchi/rescript-react-realworld-example-app">Here</a> is an example of a full browser app written in ReScriptReact.
    <ul>
      <li>ReScript and ReScriptReact count as OCaml for the course projects, an option to consider if you already know React.</li>
    </ul>
  </li>
</ul>

<h3 id="elm">Elm</h3>

<ul>
  <li><a href="https://elm-lang.org">Elm</a> is an ML-school language</li>
  <li>Designed for writing web apps, it runs in the browser via translation to JS.
    <ul>
      <li>Similar to ReScriptReact in goal</li>
    </ul>
  </li>
</ul>

<h3 id="elixir">Elixir</h3>

<ul>
  <li><a href="https://elixir-lang.org">Elixir</a> runs on the Erlang VM; Erlang is another older FP not so popular now.</li>
</ul>

<h3 id="scala">Scala</h3>

<ul>
  <li>Scala is a hybrid of Java and ML which runs on the JVM so can link with Java libraries</li>
  <li>It is much easier to do FP in compared to Java since FP was built-in from the start: pattern matching, type inference, etc.</li>
</ul>

<h3 id="haskell">Haskell</h3>

<ul>
  <li>Haskell is an ML descendant, it shares a lot of the same syntax</li>
  <li>It is hard-core FP: no direct side effects at all, must use monads for every side-effect (ouch!)</li>
  <li>It was gaining in popularity but interest has leveled off in the last few years
    <ul>
      <li>monads are too hard-core for your average programmer</li>
    </ul>
  </li>
  <li>Has some very cool features that OCaml does not have, e.g. type classes for principled operator overloading</li>
</ul>

<h3 id="lisp--scheme--racket">Lisp / Scheme / Racket</h3>

<ul>
  <li>Lisp was the very first functional programming language, from the late 50’s
    <ul>
      <li>inspired by Church’s Lambda Calculus, circa 1934 - functional programming on paper</li>
      <li>Lisp is dynamically typed, the ancestor of all modern dynamically-typed languages such as Python, JavaScript, etc.  No type-directed programming in any of these!!</li>
      <li>Allows mutation everywhere (no immutable <code>let</code> or immutable lists), but “only mutate when really needed”.</li>
    </ul>
  </li>
  <li>Scheme was a clean-up of Lisp in the 70’s-80’s, there were several errors in the Lisp design
    <ul>
      <li>e.g. dynamic scoping – closures were not computed in Lisp. (see <a href="./fp-universe.html#closures">closures tangent below</a>)</li>
    </ul>
  </li>
  <li><a href="https://racket-lang.org">Racket</a> is a popular modern dialect of Scheme with many added features including types</li>
  <li><a href="https://clojure.org">Clojure</a> is another more modern Lisp dialect
    <ul>
      <li>Has more immutablility by default than Scheme and so can more cleanly support parallelism
        <ul>
          <li>Avoids race conditions on stateful data strutures</li>
        </ul>
      </li>
      <li>Runs on the Java JVM so lots of libraries</li>
    </ul>
  </li>
  <li>Additionally, Smalltalk, Ruby, Python, and JavaScript are descended from Lisp (more below on those)</li>
  <li>The Lisp school is generally in decline these days, <code>(the syntax (sucks) (since everything is just an s-expression (like this)))</code></li>
</ul>

<h2 id="what-is-needed-to-have-fp-in-yourlang">What is needed to have FP in YourLang</h2>
<p>You need the following elements:</p>
<ul>
  <li>Higher-order functions: functions can be put in variables, passed to other functions, and returned as results of functions</li>
  <li>Currying: the ability to partially apply function arguments because the type is <code>a1 -&gt; (a2 -&gt; r)</code></li>
  <li>Anonymous (un-named) functions: e.g. in the OCaml <code>(fun x -&gt; x) 4</code></li>
  <li>Closures: to implement the above FP features, the compiler/interpreter needs <em>closures</em>.</li>
  <li>(Also, FP languages often have pattern matching and immutable data structures)</li>
</ul>

<p>Lets cover closures briefly now.</p>

<p><a name="closures"></a></p>
<h3 id="closures">Closures</h3>

<ul>
  <li>A <em>closure</em> is just how one function can return another function as a result</li>
  <li>The term “closure” comes from how they are implemented – all variable values not local to the function must be remembered</li>
  <li>OCaml example:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">add4</span> <span class="o">=</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">add4</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span> <span class="c">(* add4 is at runtime the *closure* "&lt; fun y code, {x |-&gt; 4} &gt;" *)</span>
<span class="o">#</span> <span class="n">add4</span> <span class="mi">3</span><span class="p">;;</span>                    <span class="c">(* The closure lets us remember the 4 we passed to x *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">7</span>
</code></pre></div></div>

<ul>
  <li>Note how <code>x</code> is a function parameter and is remembered in spite of function returning, means <code>x</code> needs to be remembered, in the closure</li>
  <li>Closures are the key thing missing from C: C has <em>function pointers</em> you can pass in and out of other functions, but no closures</li>
</ul>

<h2 id="fp-in-yourfavoritelang">FP in YourFavoriteLang</h2>

<ul>
  <li>It is now possible to do somewhat-FP-style programming in Java, C++, Python, JavaScript, etc.</li>
  <li>All of these languages have the core elements outlined above (higher-order, currying, anon. functions, closures)</li>
  <li>There is however often not good library support or integration
    <ul>
      <li>So, at this point it is more a “slice of FP” and not the whole pizza</li>
      <li>With good FP libraries added and enough discipline, many FP coding idioms will still work.</li>
    </ul>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Anonymous_function">Here</a> is a list of languages that do and don’t support basic FP.</li>
</ul>

<h3 id="fp-in-java">FP in Java</h3>

<p>Java 8+ has <strong>Lambdas</strong></p>

<ul>
  <li>Lambdas are higher-order functions but are clunky to use due to how they were patched in.</li>
  <li>Java 8 higher-order functions  “pun” as an interface with only one method in it, <code>apply</code>.
    <ul>
      <li>the function is taken to be the body of that single method, no need to write the method name when declaring the function then.</li>
    </ul>
  </li>
  <li>There is also some (limited) type inference for Lambda parameters (plus type inference in general via <code>var</code>)</li>
  <li>Currying in Java, somewhat painfully: <a href="https://gist.github.com/timyates/7674005">Gist currying example</a>. For that example here is the <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/Function.html">Function</a> and <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/function/BiFunction.html">BiFunction</a> type.</li>
  <li>Use <code>final</code> to declare variables immutable in Java - use it!</li>
  <li>There are no immutable data structures in the Java standard library unfortunately</li>
  <li>significantly limits the advantages of FP</li>
</ul>

<h3 id="fp-in-c1114">FP in C++11/14</h3>

<ul>
  <li>Closures are more difficult in C++ due to different low-level ways data can be accessed in C++.
    <ul>
      <li>you need to explicitly mark how each variable is stored in the closure: by value, reference, etc</li>
    </ul>
  </li>
  <li>Can use <code>const</code> declarations to get immutable variables</li>
  <li><a href="https://www.programiz.com/cpp-programming/lambda-expression">Here</a> is a tutorial with some details.</li>
  <li>C++ also has some type inference a la OCaml  <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Type_inference">C++ local type inference </a>
    <ul>
      <li>e.g. <code>auto mydata = 22;</code>. <code>auto</code> is like <code>var</code> in Java.</li>
    </ul>
  </li>
  <li>C++14 adds <a href="http://en.wikipedia.org/wiki/C++14#Generic_lambdas">generic lambdas</a> which look like the polymorphic types of OCaml/Java but are really just fancy macros.</li>
</ul>

<h3 id="fp-in-swift">FP in Swift</h3>

<ul>
  <li>Swift also has support for anonymous function definitions, closures, Currying, etc.</li>
  <li><code>let</code> is also built-in for defining immutable values (use <code>var</code> to mutate)</li>
  <li><code>map</code> and other standard functions are supported in the system libraries, and lists can be immutable and so can be shared.</li>
  <li>The generic types of Swift also allow polymorphic functions to be defined like in OCaml</li>
  <li>Here is a Curried add function<br />
```swift<br />
func add(_ x: Int) -&gt; ((Int) -&gt; Int) {<br />
return { y in x + y }</li>
</ul>

<p>let r1 = add(5)(4)<br />
let add5 = add(5)<br />
let r2 = add5(4)<br />
}</p>
<pre><code>
Or with more sugared syntax like OCaml's implicitly Curried functions:
```ocaml
func add(x: Int)(y: Int) -&gt; Int {
  return x + y
}

let sum = add(2)(y: 3)
</code></pre>

<p>Note however that application requires a named parameter on the 2nd parameter.</p>

<h3 id="fp-in-python">FP In Python</h3>

<ul>
  <li>Python as a descendant of Lisp “already has” FP including lambda, closures and Currying.  Here is a Curried add function.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">adder</span> <span class="o">=</span>  <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  
<span class="n">adder</span><span class="p">(</span><span class="mi">4</span><span class="p">)(</span><span class="mi">18</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">adder</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">r</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code>map</code>, <code>filter</code>, <code>reduce</code> etc are already in the core libraries</li>
  <li>Note that lists are mutable unfortunately (no sharing) but you can make a list out of tuples which are immutable</li>
  <li>In addition, the <a href="https://docs.python.org/3/library/functools.html"><code>functools</code></a> standard library supports other convenience higher-order function operations</li>
  <li>Plus, if you want even more FP-ism, there are additional libraries such as <a href="https://toolz.readthedocs.io/en/latest/index.html">PyToolz</a></li>
  <li>has immutable data structures as well</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">toolz</span> <span class="kn">import</span> <span class="n">curry</span>
<span class="o">@</span><span class="n">curry</span>
 <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">plusfour</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>     
</code></pre></div></div>

<ul>
  <li>PyToolz is a port of the Clojure FP libraries to Python</li>
  <li>Python is weak on immutable variables, there is no <code>const</code>/<code>final</code>
    <ul>
      <li>but the tuples and <code>frozenset</code> are immutable data structures</li>
      <li>and Python 3.8 finally has <code>final</code></li>
    </ul>
  </li>
  <li>Python 3.10 (finally!) has pattern matching.
    <ul>
      <li><a href="https://www.python.org/dev/peps/pep-0636/">tutorial 1</a> <a href="https://www.infoworld.com/article/3609208/how-to-use-structural-pattern-matching-in-python.html">tutorial 2</a></li>
    </ul>
  </li>
</ul>

<h3 id="fp-in-javascript-or-typescript">FP In JavaScript or TypeScript</h3>

<ul>
  <li>JavaScript is similar to Python, it has the basics built-in already</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">adder</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> 
<span class="p">{</span> <span class="k">return</span> <span class="kd">function</span> <span class="nx">uni_adder</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> 
    <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><code>const</code> declarations bring the FP immutable variable default to JS - use it!</li>
  <li>JavaScript has no immutable data structures however
    <ul>
      <li>means e.g. lists won’t be able to share sub-structures so “FP programming” will be less efficient in JavaScript.</li>
    </ul>
  </li>
</ul>

      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
