<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/assignment6.html">Assignment 6</a></li>
                <li><a href="/fpse/assignments/assignment7.html">Assignment 7</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1192943254">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="records">Records</h2>
<ul>
  <li>Records make <strong>and</strong> data: they have this-and-this-and-this</li>
  <li>Tuples also make <strong>and</strong> data, but records have labels for each component
    <ul>
      <li>Labels help with type checking and readability</li>
    </ul>
  </li>
  <li>Record fields are immutable by default
    <ul>
      <li>(We’ll see a way to make them mutable in a future lecture on side effects)</li>
    </ul>
  </li>
</ul>

<p>Note that a record type must be declared before you make any values with that type</p>
<ul>
  <li>similar to variants, but not like inferred variants or tuples</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat</span> <span class="o">=</span> <span class="p">{</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">7</span> <span class="p">}</span> <span class="c">(* doesn't work! Its type isn't defined yet *)</span>
</code></pre></div></div>

<p>So let’s define the type:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">{</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">;</span> <span class="n">denom</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
</code></pre></div></div>

<p>This defined the <code>ratio</code> type, a record type with two labels:</p>
<ul>
  <li><code>num</code> is label with an <code>int</code> value.</li>
  <li><code>denom</code> is a label with an <code>int</code> value, too.</li>
</ul>

<p>To make a value of a type simply replace the <code>:</code> with <code>=</code>:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="p">{</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">53</span> <span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">6</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="taking-apart-records">Taking apart records</h3>

<p>There are many ways to take apart record values.</p>

<ol>
  <li>Follow C/C++/Java/JS/Python etc: dot notation.</li>
</ol>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat_to_int</span> <span class="n">r</span> <span class="o">=</span>
  <span class="n">r</span><span class="o">.</span><span class="n">num</span> <span class="o">/</span> <span class="n">d</span><span class="o">.</span><span class="n">denom</span> <span class="c">(* project the labels out from r *)</span>
</code></pre></div></div>

<ol>
  <li>Pattern matching</li>
</ol>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat_to_int</span> <span class="n">r</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="o">|</span> <span class="p">{</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span> <span class="c">(* variable n contains numerator, d contains denominator *)</span>
</code></pre></div></div>
<ul>
  <li>Note that <code>num =</code> and <code>denom =</code> are the <strong>labels</strong>, and <code>n</code> and <code>d</code> are <strong>variables</strong>. This is just like an object or struct field name vs a variable name in Java/C/C++/etc.</li>
</ul>

<ol>
  <li>Punning by reusing the field name as a variable</li>
</ol>

<p>The following pun binds the <em>fields</em> <code>num</code> and <code>denom</code> from <code>r</code> straight into those same names as <em>variables</em>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat_to_int</span> <span class="n">r</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="o">|</span> <span class="p">{</span> <span class="n">num</span> <span class="p">;</span> <span class="n">denom</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span> <span class="c">(* sugar for { num = num ; denom = denom } -&gt; .. *)</span>
</code></pre></div></div>

<ol>
  <li>Inlining pattern matchings with <code>let</code></li>
</ol>

<p>Pattern <code>match</code>ing on only one pattern is too verbose, don’t do it.  Like with pairs, we can put the (sole) pattern as a function parameter or in a <code>let</code> definition.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">rat_to_int</span> <span class="p">{</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span> <span class="p">;</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">d</span> <span class="p">}</span> <span class="o">=</span> <span class="c">(* pattern as a function parameter *)</span>
  <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>

<span class="k">let</span> <span class="n">rat_to_int</span> <span class="p">{</span> <span class="n">num</span> <span class="p">;</span> <span class="n">denom</span> <span class="p">}</span> <span class="o">=</span> <span class="c">(* pattern parameter plus punning on labels/variables *)</span>
  <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>

<span class="k">let</span> <span class="n">rat_to_int</span> <span class="n">r</span> <span class="o">=</span>
  <span class="k">let</span> <span class="p">{</span> <span class="n">num</span> <span class="p">;</span> <span class="n">denom</span> <span class="p">}</span> <span class="o">=</span> <span class="n">r</span> <span class="k">in</span> <span class="c">(* pattern in a value let definition *)</span>
  <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span>
</code></pre></div></div>

<ol>
  <li>Yet another shortcut, <code>; _</code> can be used for dont-care fields:</li>
</ol>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">numerator</span> <span class="p">{</span> <span class="n">num</span> <span class="p">;</span> <span class="n">_</span> <span class="p">}</span> <span class="o">=</span> <span class="c">(* the _ catches all the other labels, no matter how many there are *)</span>
   <span class="n">num</span> 
</code></pre></div></div>

<h3 id="shadowing-shared-labels-and-namespaces">Shadowing, shared labels, and namespaces</h3>

<p>If there are record types that share some labels, and we use dot notation, the type inferencer will infer the most recent type defined with that label.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">newratio</span> <span class="o">=</span> <span class="p">{</span> <span class="n">num</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">;</span> <span class="n">coeff</span> <span class="o">:</span> <span class="kt">float</span> <span class="p">}</span> <span class="c">(* shadows above ratio type's label num *)</span>

<span class="c">(* Inferred type for x is newratio because its num field is more recent *)</span>
<span class="k">let</span> <span class="n">get_num</span> <span class="n">x</span> <span class="o">=</span> 
  <span class="n">x</span><span class="o">.</span><span class="n">num</span>

<span class="c">(* Resolve the ambiguity by explicitly declaring x's type *)</span>
<span class="k">let</span> <span class="n">get_new_num</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">newratio</span><span class="p">)</span> <span class="o">=</span> 
  <span class="n">x</span><span class="o">.</span><span class="n">num</span>
</code></pre></div></div>

<h3 id="puns-for-record-creation">Puns for record creation</h3>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">make_ratio</span> <span class="p">(</span><span class="n">num</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">denom</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span>
  <span class="p">{</span> <span class="n">num</span> <span class="p">;</span> <span class="n">denom</span> <span class="p">}</span> <span class="c">(* sugar for { num = num ; denom = denom } *)</span>

<span class="n">make_ratio</span> <span class="mi">1</span> <span class="mi">2</span>
</code></pre></div></div>

<p>When there are many labels and you are making a new record with only a few fields changed, use <code>with</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">abc</span> <span class="o">=</span> <span class="p">{</span> <span class="n">a</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">;</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">;</span> <span class="n">c</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">}</span>

<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">r1</span> <span class="k">with</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">}</span> <span class="c">(* same as writing { a = 4; b = r1.b; c = r1.c } - implicitly copy over others *)</span>
<span class="c">(* Note this is a COPY, NOT a mutate - ! *)</span>

<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span> <span class="n">r1</span> <span class="k">with</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">}</span> <span class="c">(* use semicolons for multiple overrides *)</span>

<span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">let</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">{</span> <span class="n">r1</span> <span class="k">with</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span> <span class="n">c</span> <span class="p">}</span> <span class="c">(* combining puns, `c = c` can again shorten to `c` *)</span>
</code></pre></div></div>

<h3 id="records-as-variant-payloads">Records as variant payloads</h3>

<p>When a variant constructor has many components to its payload, name them with records.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">gbu</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Good</span> <span class="k">of</span> <span class="p">{</span> <span class="n">sugar</span> <span class="o">:</span> <span class="kt">string</span> <span class="p">;</span> <span class="n">units</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
  <span class="o">|</span> <span class="nc">Bad</span> <span class="k">of</span> <span class="p">{</span> <span class="n">spice</span> <span class="o">:</span> <span class="kt">string</span> <span class="p">;</span> <span class="n">units</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">}</span>
  <span class="o">|</span> <span class="nc">Ugly</span>
</code></pre></div></div>

<p>The inner records (<code>{ sugar : string ; units : int }</code> and <code>{ spice : string ; units : int }</code>) don’t need to be defined on their own. The downside is they cannot be returned or typed on their own. They are only internal to the variant constructor.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">good_units_exn</span> <span class="n">v</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Good</span> <span class="p">{</span> <span class="n">units</span> <span class="p">;</span> <span class="n">_</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">units</span> <span class="c">(* this works! *)</span>
  <span class="o">|</span> <span class="nc">Bad</span> <span class="n">_</span> <span class="o">|</span> <span class="nc">Ugly</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"unhandled"</span>

<span class="k">let</span> <span class="n">good_units_exn</span> <span class="n">v</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Good</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">units</span> <span class="c">(* so does this! *)</span>
  <span class="o">|</span> <span class="nc">Bad</span> <span class="n">_</span> <span class="o">|</span> <span class="nc">Ugly</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"unhandled"</span>

<span class="k">let</span> <span class="n">return_good_record</span> <span class="n">v</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Good</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="c">(* This is not allowed! Type error! We cannot let r escape. *)</span>
  <span class="o">|</span> <span class="nc">Bad</span> <span class="n">_</span> <span class="o">|</span> <span class="nc">Ugly</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"unhandled"</span>
</code></pre></div></div>

<p>For a binary tree type the record labels are handy so you don’t get the order mixed up</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nc">Leaf</span> 
  <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="p">{</span> <span class="n">data</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="p">;</span> <span class="n">left</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="p">;</span> <span class="n">right</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">bin_tree</span> <span class="p">}</span>
</code></pre></div></div>

<p>If you write <code>{left = Leaf; node = 5; right = Leaf}</code> you are still fine</p>
<ul>
  <li>like with named function arguments the order doesn’t matter if there is a name that disambiguates</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
