<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/assignment6.html">Assignment 6</a></li>
                <li><a href="/fpse/assignments/assignment7.html">Assignment 7</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/9034692226">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="idiomatic-functional-programming">Idiomatic Functional Programming</h2>

<ul>
  <li>Design principles, design patterns, refactoring in Object-Oriented programming<br />
           = <br />
<strong>Principles &amp; idioms</strong> in Functional Programming</li>
  <li><strong>Principles</strong>: overarching principles; <strong>Idioms</strong>: more focused ideas to aid in achieving principles</li>
  <li>We have touched on much of this so much of this is review</li>
</ul>

<h3 id="fp-principles">FP Principles</h3>

<ol>
  <li>“Concise is nice”
    <ul>
      <li>Goal of making code as short as possible</li>
      <li>From the classic Strunk and White English writing guide:
        <blockquote>
          <p>A sentence should contain no unnecessary words, a paragraph no unnecessary sentences, for the same reason that a drawing should have no unnecessary lines and a machine no unnecessary parts</p>
        </blockquote>
      </li>
      <li>Concise code means that more information will fit in your brain’s fixed-size working set</li>
    </ul>
  </li>
  <li>Modularity / focus of responsibility
    <ul>
      <li>Make clear divisions of responsibility between different modules and functions</li>
      <li>Attempt to make this factoring of responsibilities the most elegant which will aid in theme 1. above.</li>
    </ul>
  </li>
  <li>Generally avoid side effects; it will help you achieve 1. and 2.
    <ul>
      <li>Recall how pure functional code is referentially transparent, the behavior is all in the interface with no “hidden” actions.</li>
      <li>Side effect world view is a state machine vs functional view as a pipeline explicitly passing data on</li>
      <li>Occasionally side effects will make code more concise, that is when to use them</li>
    </ul>
  </li>
  <li>Speed
    <ul>
      <li>There is always a trade-off in programming between efficiency and elegance</li>
      <li>Much of the time it is possible to prioritize concision and modularity over running time and space</li>
    </ul>
    <ul>
      <li>Note that Python and JavaScript are ~5-10 times slower than C or OCaml, a case in point for speed not a priority<br />
    - <strong>But</strong>, sometimes speed really matters</li>
      <li>When data sets get large or algorithms get complex</li>
      <li>Do generally avoid high polynomial or exponential algorithms on potentially large inputs</li>
      <li>Also pay more attention when data sets get extremely large, even n vs n log n gets noticeable there.</li>
    </ul>
  </li>
</ol>

<h3 id="fp-idioms">FP Idioms</h3>

<p>Here is a list of idioms, many of which are review as we touched on them before</p>

<h4 id="dont-repeat-yourself-dry-from-oo">Don’t Repeat Yourself (DRY from OO):</h4>
<ul>
  <li>Extract duplicate code into its own function</li>
  <li>if there is common code except for one spot, make that spot a code (i.e.function) parameter
    <ul>
      <li>example: make a map function on a tree if you are doing many tree operations that are maps.</li>
    </ul>
  </li>
  <li>Code usually won’t be exact duplicate; extract different bits as function parameters so the different bits are passed in</li>
  <li>May also entail replacing specific types with generic types <code>'a</code> or functor parameter types <code>t</code>, <code>elt</code> etc</li>
</ul>

<h4 id="hide-it-behind-an-interface">Hide it behind an interface</h4>
<ul>
  <li>Hiding minimizes what programmer-users have to think about, they can think at the higher (simpler) level of the interface
    <ul>
      <li>and, this again will take up less brain space since they are not seeing lots of low-level details.</li>
    </ul>
  </li>
  <li>If a function is auxiliary to only one other function, define it in the body of the latter.
    <ul>
      <li>i.e. <code>let f x = let aux y = ..&lt;aux's body&gt;.. in .. &lt;f's body&gt; ..</code></li>
    </ul>
  </li>
  <li>If a function is not local to a single function but is not used outside its module, leave it out of the module type (the <code>.mli</code> file) which will hide it to module users</li>
  <li>Make a new module for a new data type, and include operations on the type (only) in it
    <ul>
      <li>This is not just for generic data structures like <code>Map</code>/<code>Set</code>, it is for app-specific data structures</li>
      <li>Example: <code>ChessBoard</code> is a nontrivial data type for a chess game, make it its own module</li>
    </ul>
  </li>
  <li>Hide types <code>t</code> in module types if users don’t need to see the details</li>
  <li>Functional code has everything in the interface so it will make a more precice interface
    <ul>
      <li>Or on the other hand perhaps you can have a simpler interface if it is imperative, e.g. <code>fresh_name : () -&gt; string</code> making a different string each time called</li>
    </ul>
  </li>
</ul>

<h4 id="have-a-focus-of-responsibility">Have a focus of responsibility</h4>
<ul>
  <li>Each function and module should have a clear focus that can be summarized in a sentence</li>
  <li>Divide one function/module into two if it is doing two different things</li>
  <li>Don’t add random stuff to module if it doesn’t fit with it’s summary purpose</li>
  <li>If you need more than is in an existing module, make a new one and <code>include</code> the old one</li>
</ul>

<h4 id="concision">Concision</h4>

<p>(Most of this was already covered in the <a href="../style-guide.md">FPSE Style Guide</a>)</p>

<ul>
  <li><strong>Combinize</strong>: replace recursion with <code>map</code>s, <code>fold</code>s and the like
    <ul>
      <li>and, for your own data structures write your own combinators and then use in place of <code>rec</code></li>
    </ul>
  </li>
  <li>Use advanced pattern matching (<code>as</code>, <code>with</code>, deep patterns, partial record patterns, <code>_</code>, etc)</li>
  <li>Use <code>|&gt;</code> in place of call sequences, and make your functions amenable to piping
    <ul>
      <li>Make sure to have the underlying pipe-type be the <em>first</em> unnamed parameter</li>
      <li>Core solution: name most of the parameters in <code>List</code> etc (but not the list)</li>
    </ul>
  </li>
  <li>Use <code>@@</code> in place of parentheses</li>
  <li>Inline simple <code>let</code> definitions to make code read as a concise sentence
    <ul>
      <li>Also a small function called only once or twice may read better inlined</li>
      <li>Conversely, make more <code>let</code> definitions if the code is too convoluted</li>
    </ul>
  </li>
</ul>

<p><a name="efficiency"></a></p>
<h2 id="efficiency">Efficiency</h2>

<ul>
  <li>Our main goal is conciseness, but in some cases efficiency does matter</li>
  <li>We already discussed this issue a bit (e.g. cons vs append, tail recursion)</li>
  <li>Here is more detail on efficiency considerations</li>
  <li>We will also cover some case studies in the <a href="./efficiency.html">efficiency lecture</a>.</li>
</ul>

<h3 id="tail-recursion">Tail recursion</h3>

<ul>
  <li>We covered this earlier: <code>List.fold_left</code> is tail-recursive whereas <code>List.fold_right</code> is not</li>
  <li>A tail-recursive function is a function where there is no work to do after returning from recursive calls
    <ul>
      <li>Just bubble up the result</li>
    </ul>
  </li>
  <li>Observation: since there is no need to mark the call point to resume from, no stack is needed</li>
  <li>Overwrite the parameters going “down”, and return the base case as the final result of the recursion.</li>
  <li>Compilers can see which functions are tail-recursive and eliminate the stack</li>
  <li>Moral: to save space/time you may need to tail-call</li>
</ul>

<h3 id="imperative-vs-functional-data-structures">Imperative vs functional data structures</h3>

<p>Let us warm up reviewing <code>'a list</code> efficiency</p>

<ul>
  <li><code>hd</code> and <code>tl</code> are O(1)</li>
  <li><code>List.nth</code> is O(n) – lists are not random access</li>
  <li><code>append l1 l2</code> is O(<code>length l1</code>) - cons each <code>l1</code> elt onto <code>l2</code> one by one</li>
</ul>

<p>Remember that sub-lists are shared since they are immutable</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="o">...</span> <span class="n">n</span><span class="p">]</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span>    <span class="o">::</span> <span class="n">l1</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">::</span> <span class="n">l1</span> <span class="k">in</span> <span class="o">..</span>
</code></pre></div></div>

<ul>
  <li><code>l2</code> and <code>l3</code> share <code>l1</code> and all the above is O(1)</li>
  <li>If lists were mutable such sharing would not generally be possible</li>
</ul>

<p><code>List</code> vs <code>Array</code></p>
<ul>
  <li>Adding an element to the front (extending list) is constant time for list, O(n) for array
    <ul>
      <li>array needs to be copied to get more memory</li>
      <li>different lists can share tail due to referential transparency</li>
    </ul>
  </li>
  <li>Update of one element in an array is O(1); updating one element of a list is worst-case O(n) - re-build whole list</li>
  <li>Random access of nth element: O(n) list, O(1) array.</li>
  <li>If you want fast random access to a “list” that is not growing / shrinking / changing, use an <code>array</code>.</li>
</ul>

<p><code>Map</code> vs <code>Hashtbl</code></p>
<ul>
  <li><code>Map</code> is implemented like the <code>dict</code> of the homework</li>
  <li>O(log n) worst case time for <code>Map</code> to look up, add, or change an entry
    <ul>
      <li>only the path to the changed node needs updating, all the sub-trees hanging off it are kept</li>
    </ul>
  </li>
  <li>“O(1) amortized” for <code>Hashtbl</code> - will only matter for really big data sets.</li>
</ul>

<p><code>Set</code> vs <code>Hash_set</code></p>
<ul>
  <li>
    <p>See previous, <code>Set</code> is like <code>Map</code> and <code>Hash_set</code> is like <code>Hashtbl</code></p>
  </li>
  <li>
    <p><a href="https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html">Here is a summary of OCaml data structure complexity</a> (for the standard OCaml library but same results as <code>Core</code> version)</p>
  </li>
</ul>

<p>Summary: functional data structures</p>
<ul>
  <li>Feel like they should be much more inefficient but its often “at worst a log factor”</li>
  <li>In a few cases they are actually better because past states “persist for free”
    <ul>
      <li>e.g. sub-lists can be shared since copying never needed, etc</li>
      <li>See <a href="https://dev.realworldocaml.org/maps-and-hashtables.html">Real World OCaml benchmarks (scroll down)</a> for example benchmarks of this</li>
    </ul>
  </li>
  <li>In a few cases speed is critical and mutable structures are required</li>
</ul>

<h3 id="examples-of-idiomatic-fp">Examples of Idiomatic FP</h3>
<p><a name="examples"></a></p>
<ul>
  <li>
    <p>Here are example codebases we will spend some time inspecting and critiqueing.</p>

    <ul>
      <li><a href="https://exercism.io/tracks/ocaml/exercises/minesweeper">Minesweeper</a> at Exercism.io
        <ul>
          <li><a href="https://exercism.io/tracks/ocaml/exercises/minesweeper/solutions/ace26e2f446a4a18a3b1bad83dd9487c">This functional implementation</a> shows several nice OCaml patterns. <a href="../examples/minesweeper.ml">Here</a> is the version we reviewed in class which has several variations on the original implementation.</li>
          <li>We made a <a href="../examples/mine_array.ml">variation on the functional version</a> to be cleaner and more efficient</li>
          <li>Will look at an <a href="../examples/mine_mutate.ml">imperative approach</a> which has some really poor abstractions and fails to use combinators.</li>
        </ul>
      </li>
      <li><a href="https://github.com/marcoonroad/ocaml-cuid">ocaml-cuid</a> is a utility to generate highly random string IDs for webpages etc.
        <ul>
          <li>Lots of nice piping here plus use of functors to build Unix and JavaScript variations</li>
        </ul>
      </li>
      <li><a href="https://github.com/UnixJunkie/dolog">dolog</a> is a very simple logging utility
        <ul>
          <li>Shows some nice use of state, <code>include</code>, and a <code>Make</code> functor.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
