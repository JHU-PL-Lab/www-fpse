<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1191913911">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h2 id="idiomatic-functional-programming">Idiomatic Functional Programming</h2>
<p>This a major theme of the course; we covered some of this already but let’s put it all together.</p>

<ul>
  <li>Design principles, design patterns, refactoring (OO) = principles &amp; idioms (FP)</li>
  <li><strong>Principles</strong>: overarching principles; <strong>Idioms</strong>: more focused ideas to aid in achieving principles</li>
</ul>

<h3 id="fp-principles">FP Principles</h3>

<ol>
  <li>“Concise is nice”
    <ul>
      <li>Goal of making code as short as possible</li>
      <li>From the classic Strunk and White English writing guide:
        <blockquote>
          <p>A sentence should contain no unnecessary words, a paragraph no unnecessary sentences, for the same reason that a drawing should have no unnecessary lines and a machine no unnecessary parts (<strong>and, we add that code should have no unnecessary constructs</strong>).</p>
        </blockquote>
      </li>
      <li>Concise code means on a larger program more will fit in your brain’s working set</li>
    </ul>
  </li>
  <li>Modularity / focus of responsibility
    <ul>
      <li>Make clear divisions of responsibility between different modules and functions</li>
      <li>Attempt to make this factoring of responsibilities the most elegant which will aid in theme 1. above.</li>
    </ul>
  </li>
  <li>Generally avoid side effects; it will help you achieve 1. and 2.
    <ul>
      <li>Recall how pure functional code is referentially transparent, the behavior is all in the interface with no “hidden” actions.</li>
      <li>Side effect world view is a state machine vs functional view as a pipeline explicitly passing data on</li>
      <li>But, if the pipeline metaphor is failing, side effects may make it overall more concise</li>
    </ul>
  </li>
  <li>Speed
    <ul>
      <li>There is always a trade-off in programming between efficiency and elegance</li>
      <li>Much of the time it is possible to prioritize concision and modularity over running time and space</li>
    </ul>
    <ul>
      <li>Note that Python and JavaScript are ~5-10 times slower than C or OCaml, a case in point for speed not a priority<br />
    - <strong>But</strong>, sometimes speed really matters</li>
      <li>When data sets get large or algorithms get complex</li>
      <li>Do generally avoid high polynomial or exponential algorithms on potentially large inputs</li>
      <li>Also pay more attention when data sets get extremely large, even n vs n log n gets noticeable there.</li>
    </ul>
  </li>
</ol>

<h3 id="fp-idioms">FP Idioms</h3>

<p>Here is a list of idioms, many of which are review as we touched on them before</p>

<h4 id="dont-repeat-yourself-dry-from-oo">Don’t Repeat Yourself (DRY from OO):</h4>
<ul>
  <li>Extract duplicate code into its own function</li>
  <li>Code usually won’t be exact duplicate; extract different bits as function parameters so the different bits are passed in</li>
  <li>May also entail replacing specific types with generic types <code>'a</code> or functor parameter types <code>t</code>, <code>elt</code> etc</li>
</ul>

<h4 id="hide-it-behind-an-interface">Hide it behind an interface</h4>
<ul>
  <li>If a function is auxiliary to only one other function, define it in the body of the latter.
    <ul>
      <li>i.e. <code>let f x = let aux y = ..&lt;aux's body&gt;.. in .. &lt;f's body&gt; ..</code></li>
    </ul>
  </li>
  <li>If a function is not local to a single function but is not used outside its module, leave it out of the module type (e.g. <code>.mli</code> file) which will hide it to module users</li>
  <li>Make a new module for a new data type, and include operations on the type (only) in it
    <ul>
      <li>This is not just for generic data structures lke <code>Map</code>/<code>Set</code>, it is for app-specific data structures</li>
      <li>Example: <code>ChessBoard</code> is a nontrivial data type for a chess game, make it its own module</li>
    </ul>
  </li>
  <li>Hide types <code>t</code> in module types if users don’t need to see the details</li>
  <li>Functional code has everything in the interface so it will make a more precice interface
    <ul>
      <li>Or on the other hand perhaps you can have a simpler interface if it is imperative, e.g. <code>fresh_name : () -&gt; string</code> making a different string each time called</li>
    </ul>
  </li>
</ul>

<h4 id="have-a-focus-of-responsibility">Have a focus of responsibility</h4>
<ul>
  <li>Each function and module should have a clear focus that can be summarized in a sentence</li>
  <li>Divide one function/module into two if it is doing two different things</li>
  <li>Don’t add random stuff to module if it doesn’t fit with it’s summary purpose</li>
  <li>If you need more than is in an existing module, make a new one and <code>include</code> the old one</li>
</ul>

<h4 id="concision">Concision</h4>

<p>(Some of this was already covered in the <a href="../style-guide.md">FPSE Style Guide</a>)</p>

<ul>
  <li><strong>Combinize</strong>: replace recursion with <code>map</code>s, <code>fold</code>s and the like
    <ul>
      <li>and, for your own data structures write your own combinators and then use in place of <code>rec</code></li>
    </ul>
  </li>
  <li>Use advanced pattern matching (<code>as</code>, <code>with</code>, deep patterns, partial record patterns, <code>_</code>, etc)</li>
  <li>Use <code>|&gt;</code> in place of call sequences, and make your functions amenable to piping
    <ul>
      <li>Make sure to have the underlying pipe-type be the <em>first</em> unnamed parameter</li>
      <li>Core solution: name most of the parameters in <code>List</code> etc (but not the list)</li>
    </ul>
  </li>
  <li>Use <code>@@</code> in place of parentheses</li>
  <li>Inline simple <code>let</code> definitions to make code read as a concise sentence
    <ul>
      <li>Also a small function called only once or twice may read better inlined</li>
      <li>Conversely, make more <code>let</code> definitions if the code is too convoluted</li>
    </ul>
  </li>
</ul>

<p><a name="efficiency"></a></p>
<h2 id="efficiency">Efficiency</h2>

<ul>
  <li>Our main goal is conciseness, but in some cases efficiency does matter</li>
  <li>We already discussed this issue a bit (e.g. cons vs append, tail recursion), here is a bit more and we will cover even more later.</li>
</ul>

<h3 id="tail-recursion">Tail recursion</h3>

<ul>
  <li>We largely covered this earlier</li>
  <li>A tail-recursive function is a function where there is no work to do after returning from recursive calls
    <ul>
      <li>Just bubble up the result</li>
    </ul>
  </li>
  <li>Observe: since there is no need to mark the call point to resume from, no stack is needed!</li>
  <li>Overwrite the parameters going “down”, and return the base case at the bottom, done!</li>
  <li>Compilers take advantage of this to get rid of stack in this case</li>
  <li>Moral: to save space/time you may want to tail-call</li>
</ul>

<h4 id="folding-left-vs-right-and-tail-calls">Folding left vs right and tail calls</h4>
<p><a name="tail-recursion"></a><br />
<code>fold_right</code> is not tail-recursive; here is an implementation:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">init</span> <span class="n">l</span> <span class="o">=</span> 
<span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">h</span> <span class="p">(</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">init</span> <span class="n">t</span><span class="p">)</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">l</span> <span class="o">=</span> <span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">+</span><span class="p">)</span>  <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="n">l</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">l</span> <span class="o">=</span> <span class="n">fold_right</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="s2">""</span> <span class="n">l</span>
</code></pre></div></div>

<ul>
  <li>Observe: after each recursive call completes, it must compute <code>f h rec-call-result</code></li>
  <li>That is how folding right can start from the right, it computes <code>f</code> on the way up the call stack.</li>
  <li>Folding left is the opposite, computing <code>f</code> and passing accumulated result <em>down</em> the call stack:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">init</span> <span class="n">l</span> <span class="o">=</span> 
<span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="o">~</span><span class="n">f</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="p">(</span><span class="n">f</span> <span class="n">init</span> <span class="n">h</span><span class="p">)</span> <span class="n">t</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">l</span> <span class="o">=</span> <span class="n">fold_left</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="n">l</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">l</span> <span class="o">=</span> <span class="n">fold_left</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="s2">""</span> <span class="n">l</span>
</code></pre></div></div>

<ul>
  <li>Observe that in the recursive case when the <code>fold_left</code> completes at the base case there is no more work to do</li>
  <li>Thus, <code>fold_left</code> is tail-recursive
    <ul>
      <li>The <code>init</code> of the base case is in fact the final result.</li>
    </ul>
  </li>
  <li>So, if the choice doesn’t matter, use <code>fold_left</code> over <code>fold_right</code></li>
  <li><code>Core</code> has <code>fold</code> as an abbreviation of <code>fold_left</code> to bias you to use it over right fold.</li>
  <li>If you are doing millions of iterations, you may have to refactor your code to use tail calls
    <ul>
      <li>Or you could run out of memory</li>
      <li>Yes, this is a bit of a wart on the FP approach, sometimes you need to be aware of non-tail calls</li>
    </ul>
  </li>
</ul>

<h3 id="imperative-vs-functional-data-structures">Imperative vs functional data structures</h3>

<p><code>List</code> vs <code>Array</code></p>
<ul>
  <li>Adding an element to the front (extending list) is constant time for list, O(n) for array
    <ul>
      <li>array needs to be copied to get more memory</li>
      <li>different lists can share tail due to referential transparency</li>
    </ul>
  </li>
  <li>Update of one element in an array is O(1); updating one element of a list is worst-case O(n) - re-build whole list</li>
  <li>Random access of nth element: O(n) list, O(1) array.</li>
  <li>If you want fast random access to a “list” that is not growing / shrinking / changing, can in fact use an <code>array</code>.</li>
</ul>

<p><code>Map</code> vs <code>Hashtbl</code></p>
<ul>
  <li><code>Map</code> is implemented like the <code>dict</code> of the homework, but the tree is rebalanced always</li>
  <li>O(log n) worst case time for <code>Map</code> to look up, add, or change an entry</li>
  <li>“O(1) amortized” for <code>Hashtbl</code> - will only matter for really big data sets.</li>
</ul>

<p><code>Set</code> vs <code>Hash_set</code></p>
<ul>
  <li>
    <p>See previous, <code>Set</code> is like <code>Map</code> and <code>Hash_set</code> is like <code>Hashtbl</code></p>
  </li>
  <li>
    <p><a href="https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html">Here is a summary of OCaml data structure complexity</a> (for the standard OCaml library but same results as <code>Core</code> version)</p>
  </li>
  <li>
    <p>Is functional ever any better?  Yes!</p>
    <ul>
      <li>If you have many closely related maps, e.g. repeatedly forking off a map into two sub-versions</li>
      <li>Due to referential transparency the cost of copying is <strong>zero</strong>!!</li>
      <li>Multiple Lists similarly can share common portions</li>
      <li>See <a href="https://dev.realworldocaml.org/maps-and-hashtables.html">Real World OCaml benchmarks (scroll down)</a> for example benchmarks of this</li>
    </ul>
  </li>
</ul>

<h3 id="examples-of-idiomatic-fp">Examples of Idiomatic FP</h3>
<p><a name="examples"></a></p>
<ul>
  <li>
    <p>Here are example codebases we will spend some time inspecting and critiqueing.</p>

    <ul>
      <li><a href="https://exercism.io/tracks/ocaml/exercises/minesweeper">Minesweeper</a> at Exercism.io
        <ul>
          <li><a href="https://exercism.io/tracks/ocaml/exercises/minesweeper/solutions/ace26e2f446a4a18a3b1bad83dd9487c">This functional implementation</a> shows several nice OCaml patterns. <a href="../examples/minesweeper.ml">Here</a> is the version we reviewed in class which has several variations on the original implementation.</li>
          <li>Will look at an <a href="../examples/mine_mutate.ml">imperative approach</a> with too much imperative-think in it but with some good properties as well</li>
          <li>We also made a <a href="../examples/mine_array.ml">variation on the functional version</a> to be less inefficient and arguably cleaner</li>
        </ul>
      </li>
      <li><a href="https://github.com/marcoonroad/ocaml-cuid">ocaml-cuid</a> is a utility to generate highly random string IDs for webpages etc.
        <ul>
          <li>Lots of nice piping here plus use of functors to build Unix and JavaScript variations</li>
        </ul>
      </li>
      <li><a href="https://github.com/UnixJunkie/dolog">dolog</a> is a very simple logging utility
        <ul>
          <li>Shows some nice use of state, <code>include</code>, and a <code>Make</code> functor.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
