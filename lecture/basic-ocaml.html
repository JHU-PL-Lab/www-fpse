<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="introduction-to-ocaml">Introduction to OCaml</h2>

<p>(see the file <a href="basic-ocaml.ml">basic-ocaml.ml</a> if you want all of the ml examples in this file extracted out)</p>
<h3 id="installing">Installing</h3>

<ul>
  <li>See <a href="https://pl.cs.jhu.edu/fpse/coding.html">the Coding page</a> for install instructions and lots of other information.</li>
  <li>Make sure to use the required 4.14.0 version of OCaml, install the libraries listed via <code>opam</code>, and change your <code>.ocamlinit</code> file as mentioned on that page.
    <ul>
      <li>This will let us all “play in the same sandbox” and avoid confusions</li>
    </ul>
  </li>
</ul>

<h3 id="the-ecosystem-via-hello-world-in-ocaml">The Ecosystem via Hello World in OCaml</h3>

<ul>
  <li>Before getting into the details of the language we will cover the ecosystem at a high level</li>
</ul>

<h4 id="the-top-loop">The top loop</h4>

<ul>
  <li>Top loops allow you to type in small snippets of code which will run and produce a result.</li>
  <li>The OCaml top loop is the shell command <code>utop</code>.</li>
  <li>We will run the OCaml top loop and show you you can enter expressions such as <code>3+4</code>, follow with <code>;;</code> to indicate end of input (<code>;;</code> is <strong>required</strong>), and hit return to get the result<br />
```ocaml<br />
utop # 3+4;;</li>
  <li>: int = 7<br />
```</li>
  <li>Control-D will exit <code>utop</code>.
    <h4 id="the-compilerun-system">The compile/run system</h4>
  </li>
  <li>The compile/run view is the standard <code>cc</code>/<code>gcc</code>/<code>javac</code> view and is also used in OCaml</li>
  <li>In OCaml we will more generally live in <strong>both worlds</strong>: play with code in top loop, but use compiler to compile it.</li>
  <li>Let’s type the following in a file <code>helloworld.ml</code>:<br />
```ocaml<br />
open Core;; (* Make the Core libraries directly available *)<br />
let hw = “hello” ^ “world”;;</li>
</ul>

<p>printf “the string is %s\n” hw</p>
<pre><code>* From the shell type `ocamlc helloworld.ml` to compile and then `./a.out` to run


#### Building and running with `dune`

* `dune` is the modern `make`/`Makefile` equivalent for OCaml.
* In same directory, add a file `dune`:
```scheme
(executable             ; create an executable
  (name helloworld)     ; need to give it a name
  (modules helloworld)  ; it consists of just one module, helloworld.ml
  (libraries core)      ; indicates that the core libraries are used
)
</code></pre>
<ul>
  <li>This is the <strong>build file</strong>, specifying how to compile/test/run the program.  The notation is S-expressions.</li>
  <li>Also a file <code>dune-project</code> is needed with only <code>(lang dune 3.4)</code> in it.</li>
  <li>Now, type <code>dune build</code> to compile a standalone program like we did above but letting <code>dune</code> invoke the compiler.</li>
  <li>All of the results are placed in the <code>_build/</code> directory</li>
  <li>Then, run with <code>dune exec ./helloworld.exe</code> - same as typing <code>_build/default/helloworld.exe</code></li>
  <li>We will be using <code>dune</code> to build libraries and binaries, and <code>utop</code> to play with them.</li>
</ul>

<h3 id="ocaml-language-basics-in-utop">OCaml Language Basics in <code>utop</code></h3>

<ul>
  <li>We will be running many small programs in lecture - best done in the top loop.</li>
  <li>
    <p>All the following are typed as input into <code>utop</code> with <code>;;</code> ending input.</p>
  </li>
  <li>Integers
    <pre><code class="language-ocaml">3 + 4;;
let x = 3 + 4;; (* give the value a name via let keyword. *)
let y = x + 5;; (* can use x now *)
let z = x + 5 in z - 1;; (* let .. in defines a local variable z *)
</code></pre>
  </li>
</ul>

<h4 id="boolean-operations">Boolean operations</h4>

<pre><code class="language-ocaml">let b = true;;
b &amp;&amp; false;;
true || false;;
1 = 2;; (* = not == for equality comparison; note = works on ints only in our OCaml setup *)
1 &lt;&gt; 2;;  (* &lt;&gt; not != for not equal *)
</code></pre>

<h4 id="other-basic-data--see-documentation-for-details">Other basic data – see documentation for details</h4>
<pre><code class="language-ocaml">4.5;; (* floats *)
4.5 +. 4.3;; (* operations are +. etc not just + which is for ints only *)
30980314323422L;; (* 64-bit integers *)
'c';; (* characters *)
"and of course strings";;
</code></pre>

<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code>squared</code> with <code>x</code> its one parameter.  <code>return</code> is  implicit.</p>
<pre><code class="language-ocaml">let squared x = x * x;; (* returns     val squared : int -&gt; int = &lt;fun&gt;     *)
squared 4;; (* to call a function -- separate arguments with S P A C E S *)
</code></pre>
<ul>
  <li>OCaml has no <code>return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is automatically <strong>inferred</strong> and printed as domain <code>-&gt;</code> range; <code>int -&gt; int</code> here.</li>
  <li>OCaml functions in fact always take only one argument - !  multiple arguments can be encoded (covered later)</li>
</ul>

<h4 id="fibonacci-series-example---0-1-1-2-3-5-8-13-">Fibonacci series example - <code>0 1 1 2 3 5 8 13 ...</code></h4>

<p>Let’s write a well-known function with recursion and if-then-else syntax</p>

<pre><code class="language-ocaml">let rec fib n =     (* the "rec" keyword needs to be added to allow recursion *)
  if n &lt;= 0 then 0
  else if n = 1 then 1
  else fib (n - 1) + fib (n - 2);; (* notice again everything is an expression, no "return" *)

fib 10;; (* get the 10th Fibonacci number; 2^10 steps so don't make input too big! *)
</code></pre>

<p>Nested conditionals as above are generally avoided in OCaml since they are not so readable.  For example here is an easier to read <code>fib</code> using pattern match notation similar to Java/C <code>switch</code> which we will cover in detail later:</p>

<pre><code class="language-ocaml">let rec fib = function 
  | 0 -&gt; 0 
  | 1 -&gt; 1 
  | n -&gt; fib (n - 1) + fib (n - 2);;
</code></pre>
<h4 id="anonymous-aka-un-named-functions">Anonymous (aka un-named) functions</h4>

<ul>
  <li>Key feature of FP: functions are just expressions; put them in variables, pass and return from other functions, etc.</li>
  <li>Much of this course will be showing how this is useful</li>
</ul>

<pre><code class="language-ocaml">let add1 x = x + 1;; (* a normal add1 definition *)
add1 3;;
let anon_add1 = (function x -&gt; x + 1);; (* equivalent to above; "x" is argument here *)
anon_add1 3;;
(anon_add1 4) + 7;; 
((function x -&gt; x + 1) 4) + 7;; (* can inline anonymous function definition *)
((fun x -&gt; x + 1) 4) + 7;; (*  shorthand notation -- cut off the "ction" *)
</code></pre>

<ul>
  <li>Multiple arguments - just leave s p a c e s between multiple arguments in both definitions and uses</li>
</ul>

<pre><code class="language-ocaml">let add x y = x + y;;
add 3 4;;
(add 3) 4;; (* same meaning as previous application -- two applications, " " associates LEFT *)
let add3 = add 3;; (* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)
add3 4;;
add3 20;;
(+) 3 4;; (* Putting () around any infix operator turns it into a 2-argument function *)
</code></pre>

<p>Conclusion: add is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, add is a <strong>higher-order function</strong>: it either takes a function as an argument, or returns a function as result.</p>

<p>Observe <code>int -&gt; int -&gt; int</code> is parenthesized as <code>int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<pre><code class="language-ocaml">add3 (3 * 2);;
add3 3 * 2;; (* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than * *)
add3 @@ 3 * 2;; (* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)
</code></pre>

<ul>
  <li><code>=</code> is also a 2-argument function; it is somewhat strange in our <code>Core</code> OCaml on non-ints:
    <pre><code class="language-ocaml">3.4 = 4.2;; (* errors, = only works on ints with the Core library in use *)
Float.(=) 3.3 4.4;; (* Solution: use the Float module's = function for floats *)
</code></pre>
  </li>
  <li>Why this apparent ugliness?  Pay a price here but reap rewards later of having the right notion of <code>=</code>.</li>
</ul>

<h3 id="simple-structured-data-types-option-and-result">Simple Structured Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code>option</code> type.</li>
</ul>

<pre><code class="language-ocaml">Some 5;;
- : int option = Some 5
</code></pre>

<ul>
  <li>All this does is “wrap” the 5 in the <code>Some</code> tag</li>
</ul>

<pre><code class="language-ocaml">None;;
- : 'a option = None
</code></pre>

<ul>
  <li>Notice these are both in the <code>option</code> type .. either you have <code>Some</code> data or you have <code>None</code>.</li>
  <li><code>option</code> is similar to how you can have null or non-null objects in other languages, but it is explicit here.</li>
  <li>These kinds of types with the capital-letter-named tags are called <strong>variants</strong> in OCaml; each tag wraps a different variant.</li>
  <li>The <code>option</code> type is very useful; here is a super simple example.</li>
</ul>

<pre><code class="language-ocaml"># let nice_div m n = if n = 0 then None else Some (m / n);;
val nice_div : int -&gt; int -&gt; int option = &lt;fun&gt;
# nice_div 10 0;;
- : int option = None
# nice_div 10 2;;
- : int option = Some 5
</code></pre>

<p>There is a downside with this though, you can’t just use <code>nice_div</code> like <code>/</code>:</p>

<pre><code class="language-ocaml"># (nice_div 5 2) + 7;;
Line 1, characters 0-14:
Error: This expression has type int option
       but an expression was expected of type int
</code></pre>

<p>This type error means the <code>+</code> lhs should be type <code>int</code> but is a <code>Some</code> value which is not an <code>int</code>.</p>

<p>Here is a non-solution to that:</p>
<pre><code class="language-ocaml"># let not_nice_div m n = if n = 0 then None else m / n;;
Line 1, characters 47-52:
Error: This expression has type int but an expression was expected of type
         'a option
</code></pre>
<ul>
  <li>The <code>then</code> and <code>else</code> branches must return the same type, here they do not.</li>
  <li>The <code>int</code> and <code>int option</code> types have no overlap of members!  Generally true across OCaml.</li>
  <li><code>null</code> or similar value can sneak in to a type in other languages, but no such sneaking in OCaml.</li>
</ul>

<h4 id="using-pattern-matching-to-use-nice_div">Using pattern matching to use <code>nice_div</code></h4>

<p>Here is a real solution to the above issue:</p>
<pre><code class="language-ocaml"># match (nice_div 5 2) with 
   | Some i -&gt; i + 7 (* i is bound to the result, 2 here *)
   | None -&gt; failwith "This should never happen, we divided by 2";;
- : int = 9
</code></pre>
<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option values, via the <code>match</code> syntax.</li>
  <li><code>match</code> is similar to <code>switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>The LHS in OCaml can be a general pattern which binds variables (the <code>i</code> here), etc</li>
  <li>Note that we turned <code>None</code> into a runtime exception via <code>failwith</code>.</li>
</ul>

<h4 id="result">Result</h4>

<p>An “even nicer” version of the above would be to use the <code>result</code> type, which is very similar to <code>option</code> but is specialized just for error handling.</p>

<pre><code class="language-ocaml"># let nicer_div m n = if n = 0 then Error "Divide by zero" else Ok (m / n);;
val nicer_div : int -&gt; int -&gt; (int, string) result = &lt;fun&gt;
</code></pre>
<ul>
  <li>The <code>result</code> type is explicitly intended for this case of failure-result
    <ul>
      <li><code>Ok</code> means the normal result</li>
      <li><code>Error</code> is the error case, which unlike none can include failure data, usually a string.</li>
    </ul>
  </li>
  <li>Again we can do the same kind of pattern match on <code>Ok/Error</code> as above.</li>
  <li>This is a “more well-typed” version of the C approach of returning <code>-1</code> or <code>NULL</code> to indicate failure.</li>
</ul>

<pre><code class="language-ocaml"># match (nicer_div 5 2) with 
   | Ok i -&gt; i + 7
   | Error s -&gt; failwith s;;
- : int = 9
</code></pre>

<p>Lastly, the function could itself raise an exception</p>

<pre><code class="language-ocaml">let div_exn m n = if n = 0 then failwith "divide by zero is bad!" else m / n;;
div_exn 3 4;;
</code></pre>

<ul>
  <li>This has the property of not needing a match on the result.</li>
  <li>Note that the built-in <code>/</code> also raises an exception.</li>
  <li>Exceptions are side effects though, we want to minimize their usage to avoid error-at-a-distance.</li>
  <li>The above examples show how exceptional conditions can either be handled via exceptions or in the return value;
    <ul>
      <li>A key dimension of this course is this side effect vs direct trade-off</li>
      <li>Many bugs, security leaks, etc are due to ignorance of side effects; the <code>Error/Ok</code> approach keeps them “in your face” as a programmer</li>
    </ul>
  </li>
</ul>

<h3 id="lists">Lists</h3>

<ul>
  <li>Lists are pervasive in OCaml</li>
  <li>They are <strong>immutable</strong> so while they look something like arrays or vectors they are not</li>
</ul>

<pre><code class="language-ocaml">let l1 = [1; 2; 3];;
let l2 = [1; 1+1; 1+1+1];;
let l3 = ["a"; "b"; "c"];;
let l4 = [1; "a"];; (* error - All elements must have same type *)
let l5 = [];; (* empty list *)
</code></pre>

<h4 id="building-lists">Building lists</h4>

<p>Lists are represented internally as <strong>binary trees</strong> with left child a leaf.</p>
<pre><code class="language-ocaml">0 :: l1;; (* "::" is 'consing' 0 to the top of the tree - fast *)
0 :: (1 :: (2 :: (3 :: [])));; (* equivalent to [0;1;2;3] *)
[1; 2; 3] @ [4; 5];; (* appending lists - slower, needs to cons 3/2/1 on front of [4;5] *)
let z = [2; 4; 6];;
let y = 0 :: z;;
z;; (* Observe z itself did not change -- recall lists are immutable in OCaml *)
</code></pre>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<ul>
  <li>Before writing real programs here is a simple example of pattern matching on a list.</li>
  <li>This function gets the tail, the list without the first element.</li>
</ul>

<pre><code class="language-ocaml">let tl_exn l =
  match l with
  |  [] -&gt; invalid_arg "empty lists have no tail"
  |  x :: xs -&gt; Ok xs  (* the pattern x :: xs  binds x to the first elt, xs to ALL the others *)
;;
let l = [1;2;3];; 
let l' = tl_exn l;;
l;; (* IMPORTANT: lists are immutable, l didn't change!! *)
let l'' =  tl_exn l' (* So to get tail of tail, take tail of l' not 2 x tail of l!  THREAD the state! *)
tl_exn [];; (* Raise an exception if the list had no tail *)
</code></pre>

<ul>
  <li>An alternative to avoid the exception effect is to return <code>Ok/Error</code>:</li>
</ul>

<pre><code class="language-ocaml">let tl l =
  match l with
  |  [] -&gt; Error "empty list has no tail"
  |  x :: xs -&gt; Ok xs
;;
let l = [1;2;3];; 
let l' = tl l;;
tl [];;
let l'' = tl l' (* Oops this fails!  As in the div example above need to case on `Ok/Error` *)
</code></pre>

<ul>
  <li>Lists are not random access like arrays; if you want to get the nth element, you need to work for it.</li>
</ul>

<pre><code class="language-ocaml">let rec nth_exn l n =
  match l with
  |  [] -&gt; invalid_arg "there is no nth element in this list"
  |  x :: xs -&gt; if n = 0 then x else nth_exn xs (n-1)
;;
nth_exn [33;22;11] 1;;
nth_exn [33;22;11] 3;;
</code></pre>

<p>Fortunately many common operations are already in the <code>List</code> module in the <code>Core</code> library:</p>

<pre><code class="language-ocaml"># List.nth [1;2;3] 2;;
- : int option = Some 3
</code></pre>
<ul>
  <li>This library uses the <code>option</code> type instead of raising an exception like we did</li>
  <li><code>List.nth_exn</code> raises an exception like ours does.  Both versions are useful.</li>
  <li>Note on the HW you can use libraries on some questions but not others, read instructions.</li>
</ul>

      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
