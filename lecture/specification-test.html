<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/fpse/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
            <li><a href="">Assignments</a>
                <ul class="menu">
                <li><a href="/fpse/assignments/assignment1.html">Assignment 1</a></li>
                <li><a href="/fpse/assignments/assignment2.html">Assignment 2</a></li>
                <li><a href="/fpse/assignments/assignment3.html">Assignment 3</a></li>
                <li><a href="/fpse/assignments/assignment4.html">Assignment 4</a></li>
                <li><a href="/fpse/assignments/assignment5.html">Assignment 5</a></li>
                <li><a href="/fpse/assignments/project.html">Project</a></li>
              </ul></li>          <li><a href="https://courselore.org/courses/1191913911">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="specification">Specification</h2>

<ul>
  <li>Terminology
    <ul>
      <li>Specification: <em>what</em> the program should do</li>
      <li>Implementation: <em>how</em> it does it</li>
    </ul>
  </li>
  <li>Let us step back and look at the bigger picture of specifying</li>
</ul>

<h3 id="correctness">Correctness</h3>

<ul>
  <li>The high-level goal is to have software that is “correct”</li>
  <li>There are many levels of interpretation for “correct”
    <ul>
      <li>Informal spec.: we had some vague idea of what the code should do, wrote it, iteratively addressed feedback of users until bug reports shrunk to very low levels.</li>
      <li>Semi-formal spec.: Sat down with stakeholders, wrote out a specification document in English with a few pictures/formulas, added some tests to code which affirmed aspects of this spec.</li>
      <li>Rigorous spec.: Have an unambiguous mathematical notion of what correct behavior should be, write it out as the formal specification, make sure code meets it.</li>
    </ul>
  </li>
  <li>In practice all of these modes can be fruitful depending on the project and how mission-critical it is.</li>
</ul>

<h3 id="forms-of-specification">Forms of specification</h3>
<p>Specifications can range from informal to completely rigorous and unambiguous</p>

<ul>
  <li>Requirements and Design documents: high-level informal descriptions of what the app should do
    <ul>
      <li>This is the classic form of specification in software engineering; includes description/pictures/etc but far from code</li>
    </ul>
  </li>
  <li>Types, e.g. writing an <code>.mli</code> file before implementing the code
    <ul>
      <li>Gives a very rigorous, compiler-checked skeleton for the code; we are doing this for you on the assignments</li>
      <li>Much more precise than the previous in terms of code/spec relationship, but limited expressiveness</li>
    </ul>
  </li>
  <li>Tests
    <ul>
      <li>A test suite constitutes a specification on a finite window of behavior - can’t run all infinite cases</li>
      <li>Can be 100% accurate on the cases tested, but could be woefully incomplete</li>
      <li><em>Coverage</em> measurements can be used to help close the incompleteness gap somewhat (never fully however)</li>
    </ul>
  </li>
  <li>Full logical assertions specifying code behavior in terms of math
    <ul>
      <li>e.g. <em>precondition</em> on a function that tree parameter is a binary tree (left values &lt; right values)</li>
      <li>e.g. <em>precondition</em> on a function that tree parameter is a <em>balanced</em> binary tree</li>
      <li>e.g. <em>postcondition</em> that <code>List.sort</code> always returns a sorted list</li>
      <li>e.g. <em>precondition</em>/<em>postcondition</em> on tree <code>add</code> function that if the input tree is balanced the output tree will also be.</li>
      <li>e.g. <em>invariants</em> on data structures such as a <code>Set</code> implementation which uses an underlying always-sorted list.</li>
      <li>e.g. <em>inductive invariants</em> on recursive algorithms, e.g. assuming that in the body of <code>reverse</code> that it works on a shorter list.</li>
      <li>Logical assertions are more general than tests since they are for <em>all</em> inputs
        <ul>
          <li>but not necessarily verified (but, invariants do guide tests - write tests to verify on lots of examples)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Verified assertions aka formal methods
    <ul>
      <li>After making the above logical assertions, <em>verify</em> the code meets the assertions using a verification tool</li>
      <li>Now this is mostly research, but becoming more mainstream</li>
    </ul>
  </li>
</ul>

<h3 id="type-directed-programming">Type-directed programming</h3>

<p>Fact: types outline the “shape” of the code you need to write and serve as a “structural” spec.</p>

<ul>
  <li>You have been doing type-directed programming, perhaps getting very annoyed whilst
    <ul>
      <li>With time the annoyance turns to thanks (we promise!)</li>
    </ul>
  </li>
  <li>Principle is: writing code that matches declared type will get you well on the way to an implementation
    <ul>
      <li>type errors point to code errors to be fixed</li>
      <li>when the last type error drops, the code may directly work</li>
    </ul>
  </li>
  <li>Type-directed programming is 100% rigorous, but is incomplete: types only express <em>rough shapes</em> of data
    <ul>
      <li>e.g. <code>int list</code> is a rough shape compared to “sorted <code>int list</code>” but the latter isn’t a type in OCaml</li>
    </ul>
  </li>
</ul>

<h4 id="type-directed-programming-examples">Type-directed programming examples</h4>

<p>Review example: not bubbling up <code>option</code> or other wrapped results properly</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">zadd</span> <span class="p">(</span><span class="n">l1</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="p">)</span> <span class="p">(</span><span class="n">l2</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="kt">list</span><span class="p">)</span> <span class="o">=</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">zip</span> <span class="n">l1</span> <span class="n">l2</span> <span class="k">in</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="n">l</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">74</span><span class="o">-</span><span class="mi">75</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">list</span> <span class="nn">List</span><span class="p">.</span><span class="nn">Or_unequal_lengths</span><span class="p">.</span><span class="n">t</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="k">'</span><span class="n">c</span> <span class="kt">list</span>
</code></pre></div></div>
<ul>
  <li>To solve this type error you will need to <code>match</code> on the result, which should fix both type error and behavior</li>
</ul>

<p>Review example: with partial parameters applied, remainder types hint at what is needed.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">;</span><span class="mi">3</span><span class="p">];</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span><span class="mi">4</span><span class="p">];</span> <span class="p">[</span><span class="mi">22</span><span class="p">;</span><span class="mi">17</span><span class="p">]]</span> <span class="k">in</span>
<span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">l</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="kt">int</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">_weak1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">_weak1</span> <span class="kt">list</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>The type shows that <code>f</code> needs to be a function taking an <code>int list</code> as argument.</li>
</ul>

<p>Review example: the type in an <code>.mli</code> file can direct your implementation, e.g. <code>map</code> on <code>dict</code> example from HW2</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">map</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">dict</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">dict</span>
</code></pre></div></div>
<ul>
  <li>Q: “how can I get a dict of <code>'b</code>’s built from a dict of <code>'a</code>’s here</li>
  <li>A: “Use the function from <code>'a</code> to <code>'b</code> on elements of <code>'a dict</code>.</li>
</ul>

<p>Extension example: add a new field to a record or a new variant case, chase the type errors to patch</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">party</span> <span class="o">=</span> <span class="nc">Dem</span> <span class="o">|</span> <span class="nc">Rep</span>
<span class="k">type</span> <span class="n">voter</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">party</span><span class="o">:</span> <span class="n">party</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">count_parties</span> <span class="p">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">voter</span> <span class="kt">list</span><span class="p">)</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">l</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="p">)</span> 
    <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">cd</span><span class="o">,</span><span class="n">cr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="p">{</span><span class="n">party</span><span class="p">;</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span> 
     <span class="k">match</span> <span class="n">party</span> <span class="k">with</span> 
     <span class="o">|</span> <span class="nc">Dem</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">cd</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cr</span><span class="p">)</span>
     <span class="o">|</span> <span class="nc">Rep</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">cd</span><span class="o">,</span> <span class="n">cr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">);;</span>
</code></pre></div></div>

<p>Adding a <code>Gre</code> for green party: first just change the type, and chase errors</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">party</span> <span class="o">=</span> <span class="nc">Dem</span> <span class="o">|</span> <span class="nc">Rep</span> <span class="o">|</span> <span class="nc">Gre</span>
<span class="k">type</span> <span class="n">voter</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">party</span><span class="o">:</span> <span class="n">party</span> <span class="p">}</span>
<span class="k">let</span> <span class="n">count_parties</span> <span class="p">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">voter</span> <span class="kt">list</span><span class="p">)</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="n">l</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="p">)</span> 
    <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">cd</span><span class="o">,</span><span class="n">cr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">fun</span> <span class="p">{</span><span class="n">party</span><span class="p">;</span> <span class="n">_</span><span class="p">}</span> <span class="o">-&gt;</span> 
     <span class="k">match</span> <span class="n">party</span> <span class="k">with</span> 
     <span class="o">|</span> <span class="nc">Dem</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">cd</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">cr</span><span class="p">)</span>
     <span class="o">|</span> <span class="nc">Rep</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">cd</span><span class="o">,</span> <span class="n">cr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">);;</span>
<span class="nc">Lines</span> <span class="mi">6</span><span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">5</span><span class="o">-</span><span class="mi">24</span><span class="o">:</span>
<span class="nc">Warning</span> <span class="mi">8</span><span class="o">:</span> <span class="n">this</span> <span class="n">pattern</span><span class="o">-</span><span class="n">matching</span> <span class="n">is</span> <span class="n">not</span> <span class="n">exhaustive</span><span class="o">.</span>
<span class="nc">Here</span> <span class="n">is</span> <span class="n">an</span> <span class="n">example</span> <span class="k">of</span> <span class="n">a</span> <span class="n">case</span> <span class="n">that</span> <span class="n">is</span> <span class="n">not</span> <span class="n">matched</span><span class="o">:</span>
<span class="nc">Gre</span>
<span class="k">type</span> <span class="n">party</span> <span class="o">=</span> <span class="nc">Dem</span> <span class="o">|</span> <span class="nc">Rep</span> <span class="o">|</span> <span class="nc">Gre</span>
<span class="k">type</span> <span class="n">voter</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">string</span><span class="p">;</span> <span class="n">party</span> <span class="o">:</span> <span class="n">party</span><span class="p">;</span> <span class="p">}</span>
<span class="k">val</span> <span class="n">count_parties</span> <span class="o">:</span> <span class="n">voter</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>Shows a new <code>match</code> case is needed; in process of adding new case it will become clear a triple is also needed</li>
  <li>This example also shows why non-exhaustive pattern matches are bad: errors often lurk</li>
</ul>

<p>Conclusion: Don’t <strong>wrestle</strong> with OCaml’s types, <em>dance</em> with them</p>

<p><a name="specs"></a></p>

<h3 id="preconditions-postconditions-and-data-structure-invariants">Preconditions Postconditions and Data Structure Invariants</h3>

<ul>
  <li>Types are fine for high-level structural information, but cannot express deeper properties.
    <ul>
      <li>“a function only takes non-negative input”</li>
      <li>“a function returns a sorted list”</li>
      <li>etc</li>
    </ul>
  </li>
  <li>Preconditions, postconditions, and invariants allow properties beyond types to be expressed</li>
</ul>

<p>Let us consider some preconditions and postconditions on the <code>Simple_set.Make</code> functor example <a href="../examples/set-example-functor.zip">(click for zipfile)</a>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Make</span> <span class="p">(</span><span class="nc">M</span><span class="o">:</span> <span class="nc">Eq</span><span class="p">)</span> <span class="o">=</span> 
<span class="k">struct</span>
<span class="k">open</span> <span class="nc">Core</span>
<span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span> <span class="kt">list</span>
<span class="k">let</span> <span class="n">emptyset</span> <span class="o">:</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="p">)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">remove</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"item is not in set"</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">equal</span> <span class="n">hd</span> <span class="n">x</span> <span class="k">then</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">remove</span> <span class="n">x</span> <span class="n">tl</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">equal</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">tl</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>Precondition on <code>remove</code>: <code>s</code> is not empty (it would always fail otherwise)</li>
  <li>Stronger precondition on <code>remove</code>: <code>contains x s</code> must hold
    <ul>
      <li>could be too strong if caller wants to handle this exception (generally better to avoid exceptions though)</li>
    </ul>
  </li>
  <li>Postcondition on <code>remove</code> for it returning set <code>s'</code>:  <code>not(contains x s')</code> - ??
    <ul>
      <li>No, this simple “set” data structure is in fact a multiset and this will not always hold</li>
      <li>If we had this postcondition on a “real set” spec we would have seen that our implementation failed to meet it</li>
    </ul>
  </li>
  <li>Postcondition on <code>add x s</code>: for the resulting set <code>s'</code>, <code>contains x s'</code> holds</li>
</ul>

<h4 id="assertions-in-code">Assertions in code</h4>

<ul>
  <li>OCaml <code>assert</code> can be placed in code to directly verify properties
    <ul>
      <li>program dies if the assertion fails, it should always hold</li>
      <li>silently returns <code>()</code> if it succeeds</li>
    </ul>
  </li>
  <li>Example new version of <code>add</code> above:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="nn">M</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> 
<span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">s</span><span class="p">)</span> <span class="k">in</span> <span class="k">assert</span> <span class="p">(</span><span class="n">contains</span> <span class="n">x</span> <span class="n">s'</span><span class="p">);</span> <span class="n">s'</span>
</code></pre></div>    </div>
  </li>
  <li>Good for development mode, but not after deployment (slows things down)</li>
  <li>Generally it is better to make tests to spot-check assertions instead of using <code>assert</code>
    <ul>
      <li><a href="https://github.com/janestreet/ppx_inline_test"><code>ppx_inline_tests</code></a> is a library where you can write tests in-line with your code</li>
      <li>example: <code>let s_test = .. in let%test_unit "add adds" = assert (contains (add s_test x) x)</code></li>
      <li>inline tests both document invariants and serve as tests: two-for-one!</li>
      <li>They also allow functions and data structures hidden in a module to be tested
        <ul>
          <li>one issue with OCaml’s modules is the tester module needs to see the local functions in the library module so they need to be made non-local for that - oops!</li>
          <li>For Assignment 2 we didn’t hide the underlying tree type of the dictionary so you could use it in tests</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="data-structure-invariants">Data structure invariants</h3>

<ul>
  <li>It is often the case that there are additional restrictions on values allowed in a data structure type
    <ul>
      <li>for example the “ordered tree” and “balanced tree” examples mentioned above</li>
    </ul>
  </li>
  <li>Example from <code>dict</code> on homework: <code>is_ordered</code> must hold for the binary tree.</li>
  <li>Such data structure invariants should be made clear in the code documentation</li>
</ul>

<h3 id="recursion-invariants">Recursion Invariants</h3>

<ul>
  <li>Recursion and other loops (e.g. in <code>fold</code>) is a prime place to assert invariants</li>
  <li>(Even if you don’t write them out, <em>thinking</em> of the invariants are critical to coding recursive programs)</li>
  <li>A standard invariant for recursive functions is that the recursive calls return what the outer function expected</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> 
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span> 
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="n">rxs</span> <span class="o">=</span> <span class="n">rev</span> <span class="n">xs</span> <span class="k">in</span> <span class="k">assert</span><span class="p">(</span><span class="nn">Poly</span><span class="p">.(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">rxs</span><span class="p">));</span> <span class="n">rxs</span> <span class="o">@</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>Note that we have to use the built-in <code>List.rev</code> to test our version - somewhat circular (note <code>Poly</code> quick-open lets <code>=</code> work on any type)</li>
  <li>In general a big issue with specification is it is often hard to give a code-based definition of the full spec.</li>
  <li>So, our main focus is on <em>partial</em> specs, give sanity conditions and not complete property</li>
</ul>

<h3 id="invariants-over-folds-as-examples">Invariants over folds as examples</h3>

<ul>
  <li>In re-implementing some of the common <code>List</code> functions with <code>fold</code>s it helps to think of the invariant</li>
  <li>Folding left (<code>List.fold</code>):
    <ul>
      <li>Suppose we are at some arbitrary point processing the fold;</li>
      <li>assume accumulation <code>accum</code> has “the result of the task” for all elements to the left in the list</li>
      <li>require <code>~f</code> to then “do the task” to incorporate the current element <code>elt</code></li>
      <li>also assume <code>accum</code> is initially <code>init</code></li>
    </ul>
  </li>
  <li>Folding right: just flip the order the list is walked over in the above</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* invariant for length: accum is length of list up to here *)</span>
<span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="mi">0</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">l</span> 
<span class="c">(* invariant for rev: accum is reverse of list up to here *)</span>
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span>  <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">accum</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="n">l</span> 
<span class="c">(* invariant for map: accum is f applied to each element of list up to here *)</span>
<span class="k">let</span> <span class="n">map</span> <span class="o">~</span><span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span>  <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">elt</span><span class="p">)</span><span class="o">::</span><span class="n">accum</span><span class="p">)</span> <span class="n">l</span>
<span class="c">(* etc *)</span>
<span class="k">let</span> <span class="n">filter</span> <span class="o">~</span><span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">init</span><span class="o">:</span><span class="bp">[]</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">elt</span> <span class="n">accum</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">elt</span> <span class="k">then</span> <span class="n">elt</span><span class="o">::</span><span class="n">accum</span> <span class="k">else</span> <span class="n">accum</span><span class="p">)</span> <span class="n">l</span>
</code></pre></div></div>

<h3 id="formal-verification">Formal Verification</h3>

<ul>
  <li>Formal verification is <em>proving</em> the invariants hold (e.g. that <code>rev</code> really reverses the list)</li>
  <li>It is of only limited applicability in mainstream SE but will become more common through your careers</li>
  <li>A simple view of what it is is the preconditions/postconditions/invariants/<code>asserts</code> above will be <strong>verified</strong> to always hold by a computer program.
    <ul>
      <li>Like how a compiler verifies type declarations but on a much grander scale.</li>
      <li>End goal is to do this over a full spec. but verification of partial spec is also good (e.g. dict being a binary tree)</li>
    </ul>
  </li>
</ul>

<h3 id="specification-and-abstraction">Specification and Abstraction</h3>

<ul>
  <li>The more completely a module is specified the less the users need to know about the underlying implementration</li>
  <li>The built-in <code>Core.Map</code> etc modules are examples where the users need to know almost nothing about the implementation</li>
  <li>Note that <em>documentation</em> of the specification in the interface is important; sometimes <code>Core</code> is weak there</li>
  <li>On your own libraries you can do the same
    <ul>
      <li>it will make it a lot easier for your users, they can just think about the spec. view.</li>
    </ul>
  </li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
  <li>Testing wears two very different but very useful hats:
    <ol>
      <li>Specification-based: use tests to define and refine what the code should do</li>
      <li>Implementation-based: find bugs in code, for example when you change code make sure you didn’t break it.</li>
    </ol>
  </li>
  <li>Moral: when testing, wear both hats
    <ul>
      <li>Writing tests before fully coding the answer makes the tests serve as your “coding spec”</li>
      <li>Adding tests for corner cases will flesh out the spec</li>
      <li>Adding tests covering past bugs will make sure they are caught quickly next time</li>
    </ul>
  </li>
  <li>Equivalent terminology you may see: black-box (spec) and glass-box (code-based) testing</li>
  <li>Black-box tests are those written against the spec</li>
  <li>Glass-box tests are in the context of bugs in the code and other code properties</li>
</ul>

<h3 id="standard-categories-of-tests">Standard categories of tests</h3>
<ul>
  <li><strong>Unit testing</strong>: what you have mainly done – test the small pieces of the app; no I/O testing</li>
  <li><strong>Acceptance testing</strong>: test the bigger pieces including I/O
    <ul>
      <li>For example testing your <code>keywordcount.exe</code> on a certain fixed directory tree.</li>
    </ul>
  </li>
  <li><strong>Random testing</strong> of which there are many types: fuzz testing / monkey testing / property-based testing / quickcheck:
    <ul>
      <li>the tests are run on data generated <strong>randomly</strong> from some distribution</li>
      <li>“quickcheck”ing aka property-based testing is running <strong>unit</strong> tests on randomly generated data (random lists of ints, etc)</li>
      <li>“fuzz testing” is running <strong>acceptance</strong> tests with random input strings supplied.</li>
    </ul>
  </li>
</ul>

<h3 id="testing-and-coverage">Testing and coverage</h3>

<ul>
  <li>Code coverage is a great <em>glass-box</em> (impl-based) metric of how good your test suite is</li>
  <li>The simple idea of coverage: are there lines of your code that never get exercised by any of your tests?</li>
  <li>Coverage tools let you easily check this.</li>
  <li>We will show how the Bisect coverage tool can be used below</li>
</ul>

<h2 id="ounit2">OUnit2</h2>

<ul>
  <li>We have been using the <code>OUnit2</code> library mostly as a black box up to now</li>
  <li>Now we will go through the details, which are in fact very simple
    <ul>
      <li>There is not much in <code>OUnit2</code> per se, if you want something extra just write some higher-order functions to do it</li>
    </ul>
  </li>
  <li>To review, here is your standard simple <code>tests.ml</code> file, this one is from the simple-set example:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">open</span> <span class="nc">OUnit2</span>
<span class="k">open</span> <span class="nc">Simple_set</span>

<span class="k">let</span> <span class="n">tests</span> <span class="o">=</span> <span class="s2">"test suite for set"</span> <span class="o">&gt;:::</span> <span class="p">[</span>
  <span class="s2">"empty"</span>  <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="p">(</span><span class="n">emptyset</span><span class="p">)</span> <span class="p">(</span><span class="n">emptyset</span><span class="p">));</span>
  <span class="s2">"3-elt"</span>    <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="bp">true</span> <span class="p">(</span><span class="n">contains</span> <span class="mi">5</span> <span class="p">(</span><span class="n">add</span> <span class="mi">5</span> <span class="n">emptyset</span><span class="p">)</span> <span class="p">(</span><span class="o">=</span><span class="p">)));</span>
  <span class="s2">"1-elt nested"</span> <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="bp">false</span> <span class="p">(</span><span class="n">contains</span> <span class="mi">5</span> <span class="p">(</span><span class="n">remove</span> <span class="mi">5</span> <span class="p">(</span><span class="n">add</span> <span class="mi">5</span> <span class="n">emptyset</span><span class="p">)</span> <span class="p">(</span><span class="o">=</span><span class="p">))(</span><span class="o">=</span><span class="p">)));</span>
<span class="p">]</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">run_test_tt_main</span> <span class="n">tests</span>
</code></pre></div>    </div>
  </li>
  <li><code>OUnit2.assert_equal</code> is just the <code>OUnit2</code> version of <code>assert</code>, it uses <code>Poly.(=)</code> for simplicity (but be careful)</li>
  <li>The infix <code>&gt;::</code> operator takes a string (test name) and a piece of test code under <code>fun _ -&gt;</code> (to keep it from running right away) and builds a single test of type <code>test</code> (type <code>#require "ounit2"</code> and <code>open OUnit2</code> to the top-loop before playing with this code there):
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">test1</span> <span class="o">=</span> <span class="s2">"simple test"</span> <span class="o">&gt;::</span> <span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="p">(</span><span class="mi">2</span> <span class="o">::</span> <span class="bp">[]</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">];;</span>
  <span class="k">val</span> <span class="n">test1</span> <span class="o">:</span> <span class="n">test</span> <span class="o">=</span>
  <span class="nc">TestLabel</span> <span class="p">(</span><span class="s2">"simple test"</span><span class="o">,</span>
  <span class="nc">TestCase</span> <span class="p">(</span><span class="nc">Short</span><span class="o">,</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>The <code>&gt;:::</code> operator simply takes a <code>test list</code> and builds a test suite (which in fact is just of type <code>test</code>)
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">test_suite</span> <span class="o">=</span> <span class="s2">"suite now"</span> <span class="o">&gt;:::</span> <span class="p">[</span><span class="n">test1</span><span class="p">];;</span>
<span class="k">val</span> <span class="n">test_suite</span> <span class="o">:</span> <span class="n">test</span> <span class="o">=</span>
<span class="nc">TestLabel</span> <span class="p">(</span><span class="s2">"suite now"</span><span class="o">,</span>
 <span class="nc">TestList</span>
  <span class="p">[</span><span class="nc">TestLabel</span> <span class="p">(</span><span class="s2">"simple test"</span><span class="o">,</span>
    <span class="nc">TestCase</span> <span class="p">(</span><span class="nc">Short</span><span class="o">,</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span><span class="p">))])</span>
</code></pre></div>    </div>
  </li>
  <li>Then, <code>OUnit2.run_test_tt_main tests</code> will run the suite <code>tests</code>
    <ul>
      <li>(note this will work but then freeze the top loop alas; the old <code>run_test_tt</code> is no longer existing sigh)</li>
    </ul>
  </li>
</ul>

<h4 id="how-the-tests-run-when-you-say-dune-test">How the tests run when you say dune test</h4>
<ul>
  <li>The above <code>tests.ml</code> file is just defining an executable, like <code>keywordcount.exe</code> on HW2</li>
  <li>Build and run the executable to run the tests</li>
  <li>Here a dune build file which would work for the simple set tests for example:</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">executable</span>
  <span class="p">(</span><span class="nf">name</span> <span class="nv">tests</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">libraries</span>
    <span class="nv">ounit2</span>
    <span class="nv">simple_set</span>
  <span class="p">))</span>

<span class="c1">; dune rule so command line "dune runtest" (and "dune test") will run tests.</span>
<span class="p">(</span><span class="nf">rule</span>
 <span class="p">(</span><span class="nf">alias</span> <span class="nv">runtest</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">action</span> <span class="p">(</span><span class="nf">chdir</span> <span class="nv">%</span><span class="err">{</span><span class="nv">project_root</span><span class="err">}</span>
  <span class="p">(</span><span class="nf">run</span> <span class="o">.</span><span class="nv">/test/tests</span><span class="o">.</span><span class="nv">exe</span><span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li>The alias rule also runs the tests after building them</li>
  <li>We in fact use dune shorthand for the above: replace <code>executable</code> with <code>test</code> and it makes an executable with the above alias to run tests:</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">test</span>
  <span class="p">(</span><span class="nf">name</span> <span class="nv">tests</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">libraries</span>
    <span class="nv">ounit2</span>
    <span class="nv">simple_set</span>
  <span class="p">))</span>
</code></pre></div></div>

<h3 id="higher-order-testing">Higher-order testing</h3>

<ul>
  <li>If you did unit testing in other languages it looks pretty much like the above</li>
  <li>But in OCaml we can make tests programatically which makes for less code duplication</li>
  <li>Example: lets make a bunch of different tests on the same invariant, that reversing a list twice is a no-op:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">make_rev_test</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"test test"</span> <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span><span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">l</span><span class="p">)</span> <span class="n">l</span><span class="p">));;</span> 
<span class="k">val</span> <span class="n">make_rev_test</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">make_rev_suite</span> <span class="n">ll</span> <span class="o">=</span> 
  <span class="s2">"suite of rev rev tests"</span> <span class="o">&gt;:::</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">ll</span> <span class="o">~</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">fun</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">make_rev_test</span> <span class="n">l</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">make_rev_suite</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">make_rev_suite</span> <span class="p">[[];[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];[</span><span class="mi">2</span><span class="p">;</span><span class="mi">44</span><span class="p">;</span><span class="mi">2</span><span class="p">];[</span><span class="mi">32</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">]];;</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">run_test_tt_main</span> <span class="n">s</span><span class="p">;;</span> <span class="c">(* recall this crashes the top loop when finished *)</span>
</code></pre></div></div>

<ul>
  <li>In general you can build an arbitrarily big tree of tests with suites of suites etc
    <ul>
      <li>As can be seen above, a suite of tests just has type <code>test</code></li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s'</span> <span class="o">=</span> <span class="s2">"id tests"</span> <span class="o">&gt;:::</span> 
  <span class="p">[</span><span class="s2">"one"</span> <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="p">(</span><span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="p">;</span>
   <span class="s2">"two"</span> <span class="o">&gt;::</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">assert_equal</span> <span class="p">(</span><span class="nn">Fn</span><span class="p">.</span><span class="n">id</span> <span class="s2">"hello"</span><span class="p">)</span> <span class="s2">"hello"</span><span class="p">)];;</span>
<span class="k">let</span> <span class="n">suites</span> <span class="o">=</span> <span class="n">test_list</span> <span class="p">[</span><span class="n">s</span><span class="p">;</span><span class="n">s'</span><span class="p">];;</span> <span class="c">(* make suite of suites *)</span>
<span class="k">let</span> <span class="n">named_suites</span> <span class="o">=</span> <span class="s2">"revrev and Fn.id"</span> <span class="o">&gt;:</span> <span class="n">suites</span> <span class="c">(* any tree of tests can be named *)</span>
</code></pre></div></div>

<p>Here is the type of <code>test</code> under the hood (from the docs) which should make clear why the above works:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">test</span> <span class="o">=</span>
<span class="o">|</span> <span class="nc">TestCase</span> <span class="k">of</span> <span class="n">test_fun</span>
<span class="o">|</span> <span class="nc">TestList</span> <span class="k">of</span> <span class="n">test</span> <span class="kt">list</span>
<span class="o">|</span> <span class="nc">TestLabel</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">test</span>
</code></pre></div></div>

<h3 id="tangent-defining-infix-operators">Tangent: defining infix operators</h3>

<ul>
  <li>The OUnit infix operators <code>&gt;::</code>/<code>&gt;:::</code> are just like <code>+</code>, <code>^</code> etc</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">"ounit2"</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nc">OUnit2</span><span class="p">;;</span>
<span class="o">#</span> <span class="p">(</span><span class="o">&gt;::</span><span class="p">)</span> <span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">test_fun</span> <span class="o">-&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="p">(</span><span class="o">&gt;:::</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="n">test</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>There is no magic to this, you can also do it:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">utop</span> <span class="o">#</span> <span class="k">let</span> <span class="p">(</span><span class="o">^^</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="k">val</span> <span class="p">(</span> <span class="o">^^</span> <span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="n">utop</span> <span class="o">#</span> <span class="mi">3</span> <span class="o">^^</span> <span class="mi">5</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">8</span>
</code></pre></div></div>
<ul>
  <li>Note unlike in C++ we are not overloading operators, <code>^^</code> only works on two ints now.</li>
  <li>The old version of <code>^^</code> for printing just got nuked.</li>
  <li>So, new infix ops are always defined within a module to avoid overlap</li>
  <li>OCaml will eventually have overloading but it is still in the development pipe</li>
</ul>

<h3 id="making-actual-tests">Making actual tests</h3>

<ul>
  <li>We used <code>assert_equal</code> above which is the OUnit function to check things being equal</li>
  <li><code>assert_bool</code> which is like the <code>assert</code> OCaml command: <code>assert_bool "name that test" (0=0)</code> for example</li>
  <li>If you want to verify some code raises an exception, use <code>assert_raises</code></li>
  <li>To perform acceptance testing (I/O), use <code>assert_command</code> to run a shell command and compare against output
    <ul>
      <li>we are using <code>assert_command</code> to test your A2P2</li>
    </ul>
  </li>
  <li>If you need fixed setup/teardown code bracketing a group of tests to setup e.g. files: <code>bracket_tmpfile</code></li>
</ul>

<p>As always, see the documentation for more details: <br />
OUnit2 <a href="https://ocaml.org/p/ounit2/latest/doc/index.html">API docs</a></p>

<h3 id="bisect-for-ocaml-code-coverage">Bisect for OCaml code coverage</h3>

<ul>
  <li>The <code>bisect_ppx</code> preprocessor can decorate your code with one hit-bit per line
    <ul>
      <li>it can then show which lines are “hit” upon running your test suite</li>
    </ul>
  </li>
  <li>Add <code>(preprocess (pps bisect_ppx))</code> to library or executable declaration in <code>dune</code> to decorate
    <ul>
      <li><em>don’t</em> add to your <code>(test ... )</code> dune declaration, you want to count lines hit in your code not in your test code!</li>
    </ul>
  </li>
  <li>Then do a <code>dune test</code> which will generate the low-level hit-lines data in a file.
    <ul>
      <li>or <code>dune exe</code> and run your app if you want to see coverage there</li>
    </ul>
  </li>
  <li>Shell command <code>bisect-ppx-report html</code> generates a pretty report showing which lines hit in latest execution
    <ul>
      <li>open <code>_coverage/index.html</code> in your browser to see the report</li>
      <li>if this command is not working make sure you did the <code>opam install bisect-ppx</code> in the course required installs</li>
    </ul>
  </li>
  <li>See <a href="https://github.com/aantron/bisect_ppx">Bisect docs</a> for more details</li>
  <li>Note that if you have lines of code that you know should not be run (e.g. invariants that should not fail) you can put <code>[@@@coverage off]</code> on them.</li>
</ul>

<p>We will check how well my tests of the <a href="../examples/set-example.zip">simple set example</a> covered the code using Bisect.  The only addition to code is the <code>(preprocess (pps bisect_ppx))</code> added to <code>src/dune</code> for the library.</p>

<h2 id="testing-executables">Testing executables</h2>
<ul>
  <li><code>OUnit</code> can be used to test executables: <code>OUnit2.assert_command</code> can run a shell command (e.g. your OCaml executable)</li>
  <li><code>dune</code> also contains an extension called <code>cram</code> which allows for output to be compared against expected output for a given input</li>
  <li>It is very general, you just specify the shell command to run (can test non-OCaml just as easily)</li>
  <li>We will super-briefly skim the <a href="https://dune.readthedocs.io/en/stable/tests.html#cram-tests"><code>cram</code> docs</a></li>
</ul>

<p><a name="quickcheck"></a></p>
<h2 id="base_quickcheck-and-random-testing">Base_quickcheck and Random Testing</h2>
<h3 id="the-big-picture-of-random-testing">The big picture of random testing</h3>

<ol>
  <li>Suppose we have one function <code>f</code> that we want to test.</li>
  <li>We need to be able to generate random data which is the parameters of <code>f</code></li>
  <li>We run <code>f</code> on different random data many times (say 100 or 10000 times)</li>
  <li>We need to know if the test worked or not on the random data
    <ul>
      <li>So, tests usually verify that invariants hold or some bad exception not raised etc.</li>
      <li>This is another reason invariants are good, they are properties that can be quickchecked
        <h3 id="using-base_quickcheck">Using <code>Base_quickcheck</code></h3>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li><code>Base_quickcheck</code> contains three key algorithms:
    <ol>
      <li>Generators, <code>Quickcheck.Generator</code> - make random data of desired distribution in given type</li>
      <li>Shrinkers, <code>Quickcheck.Shrinker</code> - if a failing case is discovered, try to make it smaller (we will not cover these in detail)</li>
      <li>Runner, <code>Quickcheck.test</code> etc, which runs some fixed number (10,000 by default) of random tests and shrinks failures.</li>
    </ol>
  </li>
  <li>
    <p>We will look at several examples of the <code>Base_quickcheck</code> library in action in <a href="../examples/quickcheck_examples.ml">quickcheck_examples.ml</a></p>
  </li>
  <li><a href="https://ocaml.org/p/base_quickcheck/v0.15.0/doc/Base_quickcheck/index.html">Base_quickcheck docs</a></li>
  <li>The <a href="https://dev.realworldocaml.org/testing.html#property-testing-with-quickcheck">Real World OCaml</a> book has a short tutorial (note it uses <code>ppx_inline_tests</code> and not <code>OUnit2</code>)</li>
</ul>

<h3 id="fuzz-testing-vs-quickcheck">Fuzz testing vs Quickcheck</h3>

<ul>
  <li>We are focusing on quickchecking (aka property-based testing) now but fuzz testing also important</li>
  <li>Fuzz testing is to acceptance tests as quickcheck is to unit tests
    <ul>
      <li>fuzzers feed in inputs on <code>stdio</code> and other input channels to whole app</li>
      <li>quickcheckers are internally generating random data</li>
    </ul>
  </li>
  <li>Industry fuzz testers do a lot more more than generate totally random data
    <ul>
      <li>They may be aware that the string input should fit a particular grammar, e.g. html</li>
      <li>They may be combined with a coverage tool and work to find random data “covering” all the code</li>
    </ul>
  </li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: TEMPLATED
				</div>			


   </body>
</html>
