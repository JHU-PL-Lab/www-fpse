<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://courselore.org/courses/0644001341">Q&A</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="lazy-data-structures">Lazy Data Structures</h2>

<ul>
  <li>OCaml is by default eager
    <ul>
      <li>function parameters are evaluated to values before calling functions</li>
      <li>Pairs, records, and variants all have their internals computed to values recursively.</li>
    </ul>
  </li>
  <li>But, sometimes laziness can be both useful and more efficient
    <ul>
      <li>for lazy funcation call, no need to compute arguments that are not used</li>
      <li>It allows for construction of “infinite” lists, etc
        <ul>
          <li>Don’t compute the nth element until it is asked for</li>
          <li>But, once it is computed, cache it (a form of memoizing)</li>
          <li>Just don’t ask for all infinitely many elements!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="super-simple-encoding-of-laziness-in-ocaml">Super simple encoding of laziness in OCaml</h4>

<ul>
  <li>OCaml has no built-in Laziness (Haskell does)</li>
  <li>But it can be encoded via a <em>thunk</em></li>
</ul>

<pre><code class="language-ocaml">let frozen_add = fun () -&gt; printf "Have a smiley day!\n"; 4 + 3
let thaw e = e ()
thaw frozen_add;; (* 4+3 not computed until here *)
</code></pre>

<ul>
  <li>This simple encoding is in fact just “call by name”, laziness means memoizing the result.</li>
</ul>

<h4 id="the-baselazy-module">The <code>Base.Lazy</code> module</h4>

<ul>
  <li><code>Base.Lazy</code> is a much more usable sugar for the above</li>
</ul>

<pre><code class="language-ocaml"># open Lazy;;
# let l = lazy(printf "Have a smiley day!\n";2+3);;
val l : int lazy_t = &lt;lazy&gt; (* lazy_t is the wrapper type *)
# force l;;
Have a smiley day!
- : int = 5
# let f lv =  (force lv) + (force lv);;
val f : int lazy_t -&gt; int = &lt;fun&gt;
# f l;;
Have a smiley day! (* this is printed only once, the 2nd force uses cached 5 value *)
- : int = 10
</code></pre>

<pre><code class="language-ocaml">open Core
open Lazy
type 'a stream = Cons of 'a * 'a stream Lazy.t (* List MUST be infinite - ! *)

(* Programs making lazy lists look somewhat bizarre at first - doesn't this loop forever?!? *)
let rec all_ones : int stream = Cons(1,lazy(all_ones))

let rec ints n : int stream = Cons(n,lazy(ints (n+1)))

(* Code to get the nth element of a lazy list *)

let rec nth (Cons(hd, tl) : 'a stream) (n : int) :'a =
  if n = 0 then hd
  else nth (force tl) (n-1)

(* A more interesting example - shows memoization, this is not exponential *)

let rec fib : int stream = 
  let rec fib_rest (Cons(hd, tl) : int stream) : (int stream) = 
   let Cons(hd',_) = force tl in (* Note can't pattern match on first-2 together due to force needed *)
    Cons (hd + hd', lazy(fib_rest (force tl))) in
  Cons(1, lazy(Cons(1, lazy(fib_rest fib))))

nth fib 100;; (* clearly not exponential *)
</code></pre>

<ul>
  <li>One thing not clear from the code is that a <code>Lazy</code> will not be recomputed</li>
  <li>Once the list is “unrolled” by one call it doesn’t need to be “re-unrolled”</li>
  <li>This is a form of caching / memoization built into <code>Lazy</code>
    <ul>
      <li>(but not in our crude encoding of it above)</li>
    </ul>
  </li>
  <li>Note that becuase of that the above nth function will in fact be linear, not exponential</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
