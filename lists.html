<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/syllabus.html">Syllabus</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="list-programming">List programming</h2>
<ul>
  <li>First we will do a few more recursive functions over lists</li>
  <li>Then we will show how the <code>Core.List</code> library functions allow a great many (most?) operations to be written without recursion</li>
</ul>

<h4 id="reversing-a-list">Reversing a list</h4>

<ul>
  <li>Let us write a somewhat more interesting function, reversing a list.</li>
  <li>Lists are immutable so it is going to create a completely new list, not change the original.</li>
  <li>This style of programming is called “Data structure corresponds to control flow” - the program needs to touch and reconstruct the whole data structure as it runs.</li>
</ul>

<pre><code class="language-ocaml">let rec rev l =
  match l with
  |  [] -&gt; []
  |  x :: xs -&gt; rev xs @ [x]
;;
rev [1;2;3];; (* recall input list is the tree 1 :: ( 2 :: ( 3 :: [])) *)
</code></pre>

<ul>
  <li>Correctness of a recursive function by induction: assume recursive call does what you expect in arguing it is overall correct.</li>
  <li>For this example, can assume <code>rev xs</code> always reverses the tail of the list,
    <ul>
      <li>(e.g. in computing <code>rev [1;2;3]</code> we match <code>x</code> = <code>1</code> and <code>xs</code> = <code>[2;3]</code> and can assume <code>rev [2;3]</code> = <code>[3;2]</code> )</li>
    </ul>
  </li>
  <li>Given that fact, <code>rev xs @ [x]</code> should clearly reverse the whole list
    <ul>
      <li>(e.g. <code>[3;2] @ [1]</code> = <code>[3;2;1]</code> for the example)</li>
    </ul>
  </li>
  <li>QED, the function is proved correct! (actually partially correct, this induction argument does not rule out infinite loops)</li>
</ul>

<p>Of course <code>rev</code> is also in <code>Core.List</code> since it is a common operation:</p>

<pre><code class="language-ocaml"># List.rev [1;2;3];;
- : int list = [3; 2; 1]
</code></pre>

<p><strong>Another Example: zero out all the negative elements in a list of numbers</strong></p>

<ul>
  <li>C solution: <code>for</code>-loop over it and mutate all negatives to 0</li>
  <li>OCaml immutable list solution: recurse on list structure, building the new list as we go</li>
</ul>

<pre><code class="language-ocaml">let rec zero_negs l =
  match l with
  |  [] -&gt; []
  |  x :: xs -&gt; (if x &amp;lt; 0 then 0 else x) :: zero_negs xs
in
zero_negs [1;-2;3];;
</code></pre>

<h3 id="corelist-library-functions">Core.List library functions</h3>

<ul>
  <li>We already saw a few of these previously, e.g. <code>List.rev</code> and <code>List.nth</code>.</li>
  <li><code>List</code> is a <strong>module</strong>, think fancy package.  It contains functions <em>plus</em> values <em>plus</em> types <em>plus</em> even other modules</li>
  <li><code>List</code> is itself in the module <code>Core</code> so the full name for <code>rev</code> is <code>Core.List.rev</code>
    <ul>
      <li>but we put an <code>open Core</code> in our <code>.ocamlinit</code> (and in the template for A1) so you can just write e.g. <code>List.rev</code></li>
    </ul>
  </li>
  <li>Note that the <code>Core</code> module extends (think subclasses) <code>Base</code>, look in <code>Base.List</code> for the <code>List</code> documentation.</li>
  <li>(Note that <code>List.hd</code> is also available, but you should nearly always be pattern matching to take apart lists; don’t use <code>List.hd</code> on the homework.)</li>
  <li>Let us <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/List/index.html">peek at the documentation for <code>Base.List</code></a> to see what is available; we will cover a few of them now.</li>
</ul>

<h4 id="some-simple-but-very-handy-list-library-functions">Some simple but very handy <code>List</code> library functions</h4>
<pre><code class="language-ocaml">List.length ["d";"ss";"qwqw"];;
List.is_empty [];;
List.last_exn [1;2;3];; (* get last element; raises an exception if list is empty *)
List.join [[1;2];[22;33];[444;5555]];;
List.append [1;2] [3;4];; (* Usually the infix @ syntax is used for append *)
</code></pre>
<h4 id="-and-their-types">… And their types</h4>

<ul>
  <li>The types of the functions are additional hints to their purpose, get used to reading them</li>
  <li>Much of the time when you mis-use a function you will get a type error</li>
  <li>Recall that <code>'a list</code> etc is a polymorhic aka generic type, <code>'a</code> can be <em>any</em> type<br />
```ocaml
    <h1 id="listlength">List.length;;</h1>
  </li>
  <li>: ‘a list -&gt; int = &lt;fun&gt;
    <h1 id="listis_empty">List.is_empty;;</h1>
  </li>
  <li>: ‘a list -&gt; bool = &lt;fun&gt;
    <h1 id="listlast_exn">List.last_exn;;</h1>
  </li>
  <li>: ‘a list -&gt; ‘a = &lt;fun&gt;
    <h1 id="listjoin">List.join;;</h1>
  </li>
  <li>: ‘a list list -&gt; ‘a list = &lt;fun&gt;
    <h1 id="listappend">List.append;;</h1>
  </li>
  <li>: ‘a list -&gt; ‘a list -&gt; ‘a list = &lt;fun&gt;
    <h1 id="listmap---we-will-do-this-one-below-but-type-gives-it-away-">List.map;;  (* We will do this one below, but type gives it away *)</h1>
  </li>
  <li>
    <p>: ‘a list -&gt; f:(‘a -&gt; ‘b) -&gt; ‘b list = &lt;fun&gt;<br />
```</p>
  </li>
  <li>We coded <code>nth</code> and <code>rev</code> before, here is one more, <code>join</code>:</li>
</ul>

<pre><code class="language-ocaml">let rec join l = match l with
  | [] -&gt; [] (* "joining together a lists of no-lists is an empty list" *)
  | l :: ls -&gt; l @ join ls (* " by induction assume (join ls) will turn list-of-lists to single list" *)
</code></pre>

<h4 id="ocaml-tuples-and-some-list-library-functions-using-tuples">OCaml tuples and some <code>List</code> library functions using tuples</h4>

<ul>
  <li>Along with lists <code>[1;2;3]</code> OCaml has tuples, <code>(1,2.,"3")</code></li>
  <li>It is like a fixed-length list, but tuple elements <strong>can have different types</strong></li>
  <li>You can also pattern match on tuples</li>
</ul>

<pre><code class="language-ocaml"># (1,2.,"3");;
- : int * float * string = (1, 2., "3")
# [1,2,3];; (* a common error, parens not always needed so this is a singleton list of a 3-tuple, not a list of ints *)
- : (int * int * int) list = [(1, 2, 3)]
</code></pre>

<ul>
  <li>Here is a simple function to break a list in half using the <code>List.split_n</code> function
    <ul>
      <li>a pair of lists is returned by <code>split_n</code>, dividing it at the nth position</li>
    </ul>
  </li>
</ul>

<pre><code class="language-ocaml">let split_in_half l = List.split_n l (List.length l / 2);;
split_in_half [2;3;4;5;99];;
</code></pre>

<ul>
  <li>Now, using the <code>List.cartesian_product</code> function we can make all possible pairs of (front,back) elements</li>
</ul>

<pre><code class="language-ocaml">let all_front_back_pairs l = 
  let front, back = split_in_half l in 
    List.cartesian_product front back;; (* observe how let can itself pattern match pairs *)
val all_front_back_pairs : 'a list -&gt; ('a * 'a) list = &amp;lt;fun&gt;
# all_front_back_pairs [1;2;3;4;5;6];;
- : (int * int) list =
[(1, 4); (1, 5); (1, 6); (2, 4); (2, 5); (2, 6); (3, 4); (3, 5); (3, 6)]
</code></pre>

<ul>
  <li>Fact: lists of pairs are isomorphic to pairs of lists (of the same length)</li>
  <li>zipping and unzipping library functions can convert between these two equivalent forms.</li>
</ul>

<pre><code class="language-ocaml">List.unzip @@ all_front_back_pairs [1;2;3;4;5;6];;
</code></pre>

<ul>
  <li>Note the use of <code>@@</code> here, recall it is function application but with “loosest binding”, avoids need for parens</li>
  <li>Here is an even cooler way to write the same thing, with pipe operation <code>|&gt;</code> (based on shell pipe <code>|</code>)</li>
</ul>

<pre><code class="language-ocaml">[1;2;3;4;5;6] |&gt; all_front_back_pairs |&gt; List.unzip;;
</code></pre>
<ul>
  <li>In a series of pipes, the leftmost argument is data, and all the others are functions</li>
  <li>The data is fed into first function, output of first function fed as input to second, etc</li>
  <li>
    <p>This is exactly what the shell <code>|</code> does with standard input / standard output.</p>
  </li>
  <li><code>List.zip</code> is the opposite of unzip:</li>
</ul>

<pre><code class="language-ocaml">List.zip [1;2;3] [4;5;6];;
- : (int * int) list List.Or_unequal_lengths.t =
Core.List.Or_unequal_lengths.Ok [(1, 4); (2, 5); (3, 6)]
</code></pre>
<ul>
  <li>The strange result is dealing with the case where the lists supplied may not be same length</li>
  <li>This type and value are hard to read, let us take a crack at it.</li>
  <li><code>((int * int) list) List.Or_unequal_lengths.t</code> is the proper parentheses.</li>
  <li><code>List.Or_unequal_lengths.t</code> is referring to the type <code>t</code> found in the <code>List.Or_unequal_lengths</code> module (a small module within the <code>List</code> module)</li>
  <li>We can use the <code>#show_type</code> directive in the top loop to see what <code>t</code> actually is:
    <pre><code class="language-ocaml"># #show_type List.Or_unequal_lengths.t;;
type nonrec 'a t = 'a List.Or_unequal_lengths.t = Ok of 'a | Unequal_lengths
</code></pre>
  </li>
  <li>This means the value is either <code>Ok(..)</code> or <code>Unequal_lenghts</code>, very similar to <code>result</code></li>
  <li>The latter case is for zipping lists of different lengths:</li>
</ul>

<pre><code class="language-ocaml">List.zip [1;2;3] [4;5];;
- : (int * int) list List.Or_unequal_lengths.t =
Core.List.Or_unequal_lengths.Unequal_lengths
</code></pre>

<ul>
  <li>In the original same-length case we got the result from the first clause in this type, <code>Core.List.Or_unequal_lengths.Ok [(1, 4); (2, 5); (3, 6)]</code>.</li>
  <li>They should have just used the <code>result</code> type here, these values and types are ugly!!</li>
  <li>Note <code>List.zip_exn</code> will just raise an exception for unequal-length lists, avoiding all of this wrapper ugliness
    <ul>
      <li>but in larger programs we really want to avoid exceptions at a distance so it is often worth the suffering</li>
    </ul>
  </li>
</ul>

<h4 id="zipunzip-and-currying">zip/unzip and Currying</h4>

<p>We should be able to zip and then unzip as a no-op, one should undo the other (we will use the <code>_exn</code> version to avoid the above error wrapper issue).</p>

<pre><code class="language-ocaml">List.unzip @@ List.zip_exn [1;2] [3;4];;
</code></pre>
<p>And the reverse should also work as it is an isomorphism:</p>

<pre><code class="language-ocaml">List.zip_exn @@ List.unzip [(1, 3); (2, 4)];;
Line 1, characters 16-43:
Error: This expression has type int list * int list
       but an expression was expected of type 'a list
</code></pre>

<ul>
  <li>Oops! It fails.  What happened here?</li>
  <li><code>List.zip_exn</code> takes two curried arguments, lists to zip (its type is <code>'a list -&gt; 'b list -&gt; ('a * 'b) list </code>), whereas <code>List.unzip</code> returns a <em>pair of lists</em>.</li>
  <li>No worries, we can write a wrapper (an <em>adapter</em>) turning <code>List.zip_exn</code> into a version taking a pair of lists:</li>
</ul>

<pre><code class="language-ocaml">let zip_pair (l,r) = List.zip_exn l r in 
zip_pair @@ List.unzip [(1, 3); (2, 4)];;
[(1, 3); (2, 4)] |&gt; zip_pair |&gt; List.unzip;; (* Pipe equivalent form *)
</code></pre>
<ul>
  <li>Congratulations, we just wrote a fancy no-op function :smile:</li>
  <li>The general principle here is a <em>curried</em> 2-argument function like <code>int -&gt; int -&gt; int</code> is <strong>isomorphic</strong> to <code>int * int -&gt; int</code></li>
  <li>The latter form looks more like a standard function taking multiple arguments and is the <strong>uncurried</strong> form.</li>
  <li>And we sometimes need to interconvert between the two representations</li>
  <li>This conversion is called <em>uncurrying</em> (curried to pair/triple/etc form) or <em>currying</em> (putting it into curried form)</li>
</ul>

<h4 id="curryuncurry-are-themselves-functions">Curry/Uncurry are themselves functions</h4>
<ul>
  <li>We can even write functions which generically convert between these two forms - !</li>
  <li><code>curry</code>   - takes in uncurried 2-arg function and returns a curried version</li>
  <li><code>uncurry</code> - takes in curried 2-arg function and returns an non-curried version</li>
</ul>

<pre><code class="language-ocaml">let curry f = fun x -&gt; fun y -&gt; f (x, y);;
let uncurry f = fun (x, y) -&gt; f x y;;
</code></pre>
<p>Observe the types themselves in fact fully define their behavior:</p>
<pre><code class="language-ocaml">curry : ('a * 'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c
uncurry : ('a -&gt; 'b -&gt; 'c) -&gt; 'a * 'b -&gt; 'c
</code></pre>

<p>We can now use them to build <code>zip_pair</code> directly:</p>
<pre><code class="language-ocaml">let zip_pair  = uncurry @@ List.zip_exn;;
</code></pre>

<h4 id="one-last-higher-order-function-compose">One last higher-order function: compose</h4>

<p>Composition function g o f: take two functions, return their composition</p>
<pre><code class="language-ocaml">let compose g f = (fun x -&gt; g (f x));;
compose (fun x -&gt; x+3) (fun x -&gt; x*2) 10;;
</code></pre>

<ul>
  <li>The type says it all again, <code>('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b</code></li>
  <li>Equivalent ways to code <code>compose</code> in OCaml:</li>
</ul>

<pre><code class="language-ocaml">let compose g f x =  g (f x);;
let compose g f x =  x |&gt; f |&gt; g;; (* This is the readability winner: feed x into f and f's result into g *)
let compose = (fun g -&gt; (fun f -&gt; (fun x -&gt; g(f x))));;
</code></pre>

<ul>
  <li>We can express the Zip/unzip composition explicitly with <code>compose</code>:</li>
</ul>

<pre><code class="language-ocaml"># (compose zip_pair List.unzip) [(1, 3); (2, 4)];;
- : (int * int) list = [(1, 3); (2, 4)]
</code></pre>

<h4 id="list-functions-which-take-function-arguments"><code>List</code> functions which take function arguments</h4>

<ul>
  <li>So far we have done the “easier” functions in <code>List</code>; the real meat are the functions taking other functions</li>
  <li>Lets warm up with <code>List.filter</code>: remove all elements not meeting a condition which we supply a function to check</li>
</ul>

<pre><code class="language-ocaml">List.filter [1;-1;2;-2;0] (fun x -&gt; x &gt;= 0);;
</code></pre>

<ul>
  <li>Cool, we can “glue in” any checking function (boolean-returning, i.e. a <em>predicate</em>) and <code>List.filter</code> will do the rest</li>
  <li>Observe <code>List.filter</code> has type <code>'a list -&gt; f:('a -&gt; bool) -&gt; 'a list</code> – the <code>f</code> is a <em>named argument</em>, we can put args out of order if we give name via <code>~f:</code> syntax:
    <pre><code class="language-ocaml">List.filter ~f:(fun x -&gt; x &gt;= 0) [1;-1;2;-2;0];;
</code></pre>
  </li>
  <li>And, since OCaml functions are Curried we can leave off the list argument to make a generic remove-negatives function.
    <pre><code class="language-ocaml">let remove_negatives = List.filter ~f:(fun x -&gt; x &gt;= 0);;
remove_negatives  [1;-1;2;-2;0];;
</code></pre>
  </li>
</ul>

<p>Let us use <code>filter</code> to write a function determining if a list has any negative elements:</p>

<pre><code class="language-ocaml">let has_negs l = not (l |&gt; List.filter ~f:(fun x -&gt; x &amp;lt; 0) |&gt; List.is_empty);;
</code></pre>
<ul>
  <li>The example shows the power of pipelining, it is easier to see the processing order with <code>|&gt;</code></li>
  <li>This is a common operation so there is a library function for it as well: does there <em>exist</em> any element in the list where predicate holds?</li>
</ul>

<pre><code class="language-ocaml">let has_negs l = List.exists ~f:(fun x -&gt; x &amp;lt; 0) l;;
</code></pre>
<p>Similarly, <code>List.for_all</code> checks if it holds for <em>all</em> elements.</p>

<h4 id="listmap">List.map</h4>

<ul>
  <li><code>List.map</code> is  super cool, apply some operation we supply to every element of a list:</li>
</ul>

<pre><code class="language-ocaml"># List.map ~f:(fun x -&gt; x + 1) [1;-1;2;-2;0];;
- : int list = [2; 0; 3; -1; 1]
# List.map ~f:(fun x -&gt; x &gt;= 0) [1;-1;2;-2;0];;
- : bool list = [true; false; true; false; true]
List.map ~f:(fun (x,y) -&gt; x + y) [(1,2);(3,4)];; (* turns list of number pairs into list of their sums *)
</code></pre>

<h4 id="folding">Folding</h4>

<ul>
  <li>Observe the <code>for_all</code> and <code>exists</code> functions can be viewed as just mapping over the predicate like in the previous, and inserting an “and” (for all) or an “or” (exists) between each list element.</li>
  <li>The <code>fold</code> library functions do exactly that.  Here for example is <code>List.fold_right</code> at work</li>
</ul>

<pre><code class="language-ocaml">let exists ~f l =  (* Note the ~f is **declaring** a named argument f, we were only using pre-declared ones above *)
  let bool_result_list = List.map ~f:f l in
  List.fold_right bool_result_list ~f:(||) ~init:false;;
# exists ~f:(fun x -&gt; x &gt;= 0) [-1;-2];;
- : bool = false
# exists ~f:(fun x -&gt; x &gt;= 0) [1;-2];;
- : bool = true
</code></pre>

<ul>
  <li>The <code>~f</code>  parameter is the operation to put between list elements, disjunction <code>||</code> in this example;</li>
  <li>The <code>~init</code> is needed because it is a binary operator and an initial value is needed</li>
  <li>For <code>fold_right</code> the <code>~init</code> is on the <strong>right</strong>, that is why it is called a “fold right”:</li>
</ul>

<pre><code class="language-ocaml"># List.fold_right ~f:(||) ~init:false [true; false];; (* this is true || (false || (false)), the final false the ~init *)
- : bool = true
</code></pre>

<ul>
  <li><code>List.fold_left</code> aka <code>List.fold</code> puts the <code>~init</code> on the left:<br />
```ocaml
    <h1 id="listfold_left-f-initfalse-true-false--this-is-false--true--false-the-first-false-the-init-">List.fold_left ~f:(||) ~init:false [true; false];; (* this is false || (true || false), the FIRST false the ~init *)</h1>
  </li>
  <li>
    <p>: bool = true<br />
```</p>
  </li>
  <li>Note that in this case folding left or right gives the same answer;
    <ul>
      <li>that is because <code>||</code> is <em>commutative and associative</em>, so e.g. <code>true || (false || (false) = false || (true || false)</code>.</li>
    </ul>
  </li>
  <li>But e.g. <code>List.fold_left ~f:(-) ~init:0 [1;2;3]</code> is <code>-6</code> and <code>List.fold_right ~f:(-) ~init:0 [1;2;3]</code> is <code>2</code></li>
  <li>Folding left is preferred, it is tail recursive and can be optimized (more on this later)</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
