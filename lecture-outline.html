<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/syllabus.html">Syllabus</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h1 id="outline-of-lecture-units">Outline of Lecture Units</h1>

<h2 id="course-outline">Course Outline</h2>

<ul>
  <li>Just repeat the Syllabus here.</li>
</ul>

<h2 id="what-is-fp">What is FP?</h2>

<h3 id="history-in-brief">History in brief</h3>

<ul>
  <li>Lambda calculus, 1930’s - logicians (Church, Turing, Kleene, Curry, etc)</li>
  <li>Logic proofs are formal constructions</li>
  <li>Core ideas of functional programming already present</li>
  <li>But no computers so no running, only hand-calculation</li>
  <li>Lisp, 1960’s (McCarthy)</li>
  <li>Implement the ideas of the mathematicians</li>
  <li>Goal application space: artificial intelligence programming</li>
  <li>Added list data to functions: <strong>Lis</strong>t <strong>P</strong>rocessing</li>
  <li>Typed functional languages, 70’s &amp; 80’s: ML and its descendents Haskell and OCaml</li>
  <li>Will see what this is in detail as we use OCaml</li>
  <li>Modern era: add FP as possibility in mainstream: Python, JavaScript, Java, C++, etc.</li>
  <li>FP now edging out OO school in some domains.</li>
</ul>

<h3 id="imperative-vs-oo-vs-fp">Imperative vs OO vs FP</h3>

<ul>
  <li>Oversimplifying but these are the three modern schools</li>
  <li>More oversimplifying: “Imperative = C, OO = Java, FP = OCaml”</li>
  <li>other languages can also be put in schools, but these are leading representatives today</li>
</ul>

<h3 id="imperative">Imperative</h3>

<ul>
  <li>Imperative also has functions, but functions often have side effects (e.g. mutate some shared data structures)</li>
  <li>C has function pointers but they are not widely used and lack needed expressiveness (which we will cover).</li>
</ul>

<h3 id="o-o">O-O</h3>

<ul>
  <li>Objects tend to have “their” state encpsulated within their boundary</li>
  <li>Still it is usually a mutable state - change over time</li>
  <li>A function is something like an object with one method, <code class="highlighter-rouge">call</code>, and with no fields</li>
  <li>That doesn’t fully capture higher-order functions which is why <code class="highlighter-rouge">lambda</code> added to Jave.</li>
</ul>

<h3 id="functional">Functional</h3>

<ul>
  <li>Key aspect is lack of mutation: more like a mathematical function, the output only depends on the input and it’s only output is the codomain value, not any side effects like printing, mutating, raising exceptions, etc.</li>
  <li>Lack of side effects is called “referential transparency” - variable values don’t change out from under you (like in math textbook).</li>
  <li>Standard data structures not too different from imperative case: dictionaries, lists, etc, but often will themselves be non-mutable</li>
  <li>Key advantage is higher-order-ness: code is data, make new functions, accept functions as parameters.</li>
  <li>Allows for powerful new programming paradigms.  give examples like compose, map, etc.</li>
  <li>Less good at supporting extension, no notion of subclass in common functional paradigms (not impossible to add though).</li>
</ul>

<h3 id="who-wins">Who wins?</h3>
<p>Thesis:</p>
<ul>
  <li>Imperative wins for low-level code: underlying machine instructions are in the imperative domain, will run faster.</li>
  <li>O-O wins for super large apps with fairly shallow logic: UI’s, many apps, etc.</li>
  <li>Functional wins for complex algorithms with deep inner logic, and also for data manipulation focus</li>
  <li>Gets too confusing with mutation, and better composition of functions makes code easier to understand.</li>
  <li>Of course this choice is never made in a vacuum: existing codebases and libraries, programmer experience, etc.</li>
</ul>

<h2 id="intro-to-ocaml">Intro to OCaml</h2>

<h3 id="the-ecosystem-via-hello-world-in-ocaml">The Ecosystem via Hello World in OCaml</h3>

<p>In a file <code class="highlighter-rouge">helloworld.ml</code> type</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">hw</span> <span class="o">=</span> <span class="s2">"hello"</span><span class="o">^</span><span class="s2">" world"</span>
</code></pre></div></div>

<ul>
  <li>Paste into <code class="highlighter-rouge">ocaml</code> then in <code class="highlighter-rouge">utop</code></li>
  <li>Save file in new directory, <code class="highlighter-rouge">ocamlc helloworld.ml</code></li>
  <li><code class="highlighter-rouge">./a.out</code> to run</li>
  <li>Nothing happens?  Because executables only interact by I/O (think Java, C, etc)</li>
  <li>Re-write to add
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_string</span> <span class="n">hw</span>
</code></pre></div>    </div>
  </li>
  <li>recompile and run: we get some output!</li>
</ul>

<h4 id="building-and-running-with-dune">Building and running with Dune</h4>

<ul>
  <li>In same directory, add a file <code class="highlighter-rouge">dune</code>:
    <div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">executable</span>
<span class="p">(</span><span class="nf">name</span> <span class="nv">helloworld</span><span class="p">)</span>
<span class="p">(</span><span class="nf">modules</span> <span class="nv">helloworld</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>This is the build file, like a <code class="highlighter-rouge">Makefile</code>.</li>
  <li>Now, type <code class="highlighter-rouge">dune build</code> to compile a standalone program like we did above.</li>
  <li>Then, run with <code class="highlighter-rouge">dune exec ./helloworld</code></li>
</ul>

<h4 id="adding-a-library">Adding a Library</h4>

<ul>
  <li>Lets make printing less primitive: use a <code class="highlighter-rouge">Core</code> library function, <code class="highlighter-rouge">printf</code></li>
  <li>Replace printing with line <code class="highlighter-rouge">Core.printf "the string is %s\n" hw</code></li>
  <li>Try building - gives an error</li>
  <li>Add line `  (libraries core)` to dune file to fix</li>
  <li>Compile and run</li>
</ul>

<h4 id="exploring-basic-data-in-the-top-loop">Exploring Basic Data in the top loop</h4>
<ul>
  <li>Integers
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* ;; ends input, top loop will patiently do nothing until a ;; *)</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* give the value a name via let keyword. *)</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;;</span> <span class="c">(* can use x now *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(*  *)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="boolean-operations">Boolean operations</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="bp">false</span><span class="p">;;</span>
<span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span><span class="p">;;</span>
<span class="mi">1</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* = not == for equality comparison *)</span>
<span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;;</span>  <span class="c">(* &lt;&gt; not != for not equal *)</span>
</code></pre></div></div>
<h4 id="simple-functions-on-integers">Simple functions on integers</h4>

<p>To declare a function <code class="highlighter-rouge">squared</code> with <code class="highlighter-rouge">x</code> its one parameter.  <code class="highlighter-rouge">return</code> is  implicit.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">squared</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;;</span> 
<span class="n">squared</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* to call a function -- separate arguments with S P A C E S *)</span>
</code></pre></div></div>
<ul>
  <li>OCaml has no <code class="highlighter-rouge">return</code> statement; value of the whole body-expression is what gets returned</li>
  <li>Type is inferred and printed as domain <code class="highlighter-rouge">-&gt;</code> range</li>
  <li>OCaml functions in fact take only one argument - !  multiple arguments can be encoded by some tricks (later)</li>
</ul>

<p>Fibonacci series example - <code class="highlighter-rouge">0 1 1 2 3 5 8 13 ...</code></p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>     <span class="c">(* the "rec" keyword needs to be added to allow recursion *)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="mi">1</span>
  <span class="k">else</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);;</span> <span class="c">(* notice again everything is an expression, no "return" *)</span>

<span class="n">fib</span> <span class="mi">10</span><span class="p">;;</span> <span class="c">(* get the 10th Fibonacci number *)</span>
</code></pre></div></div>

<h4 id="anonymous-functions">Anonymous functions</h4>

<ul>
  <li>Lets users define a function as an expression</li>
  <li>Similar to lambdas in Python, Java, C++, etc - all are based on the lambda calculus *)</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add1</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;;</span> <span class="c">(* normal add1 definition *)</span>
<span class="k">let</span> <span class="n">funny_add1</span> <span class="o">=</span> <span class="p">(</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);;</span> <span class="c">(* "x" is (sole) argument here *)</span>
<span class="n">funny_add1</span> <span class="mi">3</span><span class="p">;;</span>
<span class="p">(</span><span class="n">funny_add1</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> 
<span class="p">((</span><span class="k">function</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(*  a "-&gt;" function is an expression and can be used anywhere *)</span>
<span class="p">((</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span> <span class="c">(*  shorthand notation -- cut off the "ction" *)</span>
</code></pre></div></div>

<p>Multiple arguments - just leave spaces between multiple arguments</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;;</span>
<span class="n">add</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="p">(</span><span class="n">add</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">;;</span> <span class="c">(* same meaning as previous application -- two applications, " " associates LEFT *)</span>
<span class="k">let</span> <span class="n">add3</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">3</span><span class="p">;;</span> <span class="c">(* No need to give all arguments at once!  Type of add is int -&gt; (int -&gt; int) - "CURRIED" *)</span>
<span class="n">add3</span> <span class="mi">4</span><span class="p">;;</span>
<span class="n">add3</span> <span class="mi">20</span><span class="p">;;</span>
</code></pre></div></div>

<p>Conclusion: add is a function taking an integer, and returning a <strong>function</strong> which takes ints to ints.<br />
So, add is a <strong>higher-order function</strong>: it either takes a function as an argument, or returns a function as result.</p>

<p>Observe <code class="highlighter-rouge">int -&gt; int -&gt; int</code> is parenthesized as <code class="highlighter-rouge">int -&gt; (int -&gt; int)</code> – unusual <strong>right</strong> associativity</p>

<p>Be careful on operator precedence with this goofy way that function application doesn’t need parens!</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add3</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);;</span>
<span class="n">add3</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* NOT the previous - this is the same as (add3 3) * 2 - application binds tighter than * *)</span>
<span class="n">add3</span> <span class="o">@@</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;;</span> <span class="c">(* LIKE the original - @@ is like the " " for application but binds LOOSER than other ops *)</span>
</code></pre></div></div>

<h3 id="super-simple-data-types-option-and-result">Super Simple Data Types: Option and Result</h3>

<ul>
  <li>Before getting into “bigger” data types and how to declare our own, let’s use one of the simplest structured data types, the built-in <code class="highlighter-rouge">option</code> type.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Some</span> <span class="mi">5</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<ul>
  <li>all this does is “wrap” the 5 in the <code class="highlighter-rouge">Some</code> tag</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">None</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
</code></pre></div></div>

<ul>
  <li>Notice these are both in the <code class="highlighter-rouge">option</code> type .. either you have <code class="highlighter-rouge">Some</code> data or you have <code class="highlighter-rouge">None</code>.</li>
  <li>This type is very useful; here is a simple example.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nice_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span>
<span class="o">#</span> <span class="n">nice_div</span> <span class="mi">10</span> <span class="mi">2</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="mi">5</span>
</code></pre></div></div>

<p>There is a downside with this though, you can’t just use <code class="highlighter-rouge">nice_div</code> like <code class="highlighter-rouge">/</code>:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">0</span><span class="o">-</span><span class="mi">14</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">option</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span>
</code></pre></div></div>

<p>This type error means the <code class="highlighter-rouge">+</code> lhs should be type <code class="highlighter-rouge">int</code> but is a <code class="highlighter-rouge">Some</code> value so is not an <code class="highlighter-rouge">int</code>.</p>

<p>Here is a non-solution to that:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">not_nice_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="nc">Line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">47</span><span class="o">-</span><span class="mi">52</span><span class="o">:</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span>
         <span class="k">'</span><span class="n">a</span> <span class="n">option</span>
</code></pre></div></div>
<ul>
  <li>The <code class="highlighter-rouge">then</code> and <code class="highlighter-rouge">else</code> branches must return the same type, here they do not.</li>
</ul>

<h4 id="pattern-matching-first-example">Pattern matching first example</h4>

<p>Here is a real solution to the above issue:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nice_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
   <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"This should never happen, we divided by 2"</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>

<ul>
  <li>This shows how OCaml lets us <em>destruct</em> option types, via the <code class="highlighter-rouge">match</code> syntax.</li>
  <li><code class="highlighter-rouge">match</code> is similar to <code class="highlighter-rouge">switch</code> in C/Java/.. but is much more flexible in OCaml</li>
  <li>LHS in OCaml can be a general pattern</li>
  <li>Note that we turned <code class="highlighter-rouge">None</code> into an exception via <code class="highlighter-rouge">failwith</code>.</li>
</ul>

<h4 id="result">Result</h4>

<p>An “even nicer” version of the above would be to use the <code class="highlighter-rouge">result</code> type, which is very similar to option.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">nicer_div</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="nc">Error</span> <span class="s2">"Divide by zero"</span> <span class="k">else</span> <span class="nc">Ok</span> <span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">nicer_div</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>
<ul>
  <li>The <code class="highlighter-rouge">result</code> type is explicitly intended for this case of failure-result
    <ul>
      <li><code class="highlighter-rouge">Ok</code> means the normal result</li>
      <li><code class="highlighter-rouge">Error</code> is the error case, which unlike none can include failure data.</li>
    </ul>
  </li>
  <li>Again we can do the same kind of pattern match on <code class="highlighter-rouge">Ok/Error</code> as above.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">match</span> <span class="p">(</span><span class="n">nicer_div</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="k">with</span> 
   <span class="o">|</span> <span class="nc">Ok</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
   <span class="o">|</span> <span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="n">s</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div></div>

<p>Lastly, the function could itself raise an exception</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">div_exn</span> <span class="n">m</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"divide by zero is bad!"</span> <span class="k">else</span> <span class="n">m</span> <span class="o">/</span> <span class="n">n</span><span class="p">;;</span>
<span class="n">div_exn</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">;;</span><span class="err">```</span>

<span class="nc">Which</span> <span class="n">has</span> <span class="n">the</span> <span class="n">property</span> <span class="k">of</span> <span class="n">not</span> <span class="n">needing</span> <span class="n">a</span> <span class="k">match</span> <span class="n">on</span> <span class="n">the</span> <span class="n">result</span><span class="o">.</span>

<span class="o">###</span> <span class="nc">Lists</span>

<span class="nc">Lists</span> <span class="n">are</span> <span class="n">pervasive</span> <span class="k">in</span> <span class="nc">OCaml</span><span class="p">;</span> <span class="n">easy</span> <span class="k">to</span> <span class="n">create</span> <span class="ow">and</span> <span class="n">manipulate</span>

<span class="err">``</span><span class="nt">`ocaml</span>
<span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">;</span> <span class="s2">"b"</span><span class="p">;</span> <span class="s2">"c"</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">l4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="s2">"a"</span><span class="p">];;</span> <span class="c">(* errors - All elements must have same type - HOMOGENEOUS *)</span>
<span class="k">let</span> <span class="n">l5</span> <span class="o">=</span> <span class="bp">[]</span><span class="p">;;</span> <span class="c">(* empty list *)</span>
</code></pre></div></div>

<h4 id="building-lists">Building lists</h4>

<p>Lists are represented internally as BINARY TREES with left child a leaf.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="o">::</span> <span class="n">l1</span><span class="p">;;</span> <span class="c">(* "::" is 'consing' an element to the front - fast *)</span>
<span class="mi">0</span> <span class="o">::</span> <span class="p">(</span><span class="mi">1</span> <span class="o">::</span> <span class="p">(</span><span class="mi">2</span> <span class="o">::</span> <span class="p">(</span><span class="mi">3</span> <span class="o">::</span> <span class="bp">[]</span><span class="p">)));;</span> <span class="c">(* equivalent to the above *)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span> <span class="c">(* appending lists - slower *)</span>
<span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">6</span><span class="p">];;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">z</span><span class="p">;;</span>
<span class="n">z</span><span class="p">;;</span> <span class="c">(* Observe z itself did not change -- lists are immutable in OCaml *)</span>
</code></pre></div></div>

<h3 id="pattern-matching">Pattern Matching</h3>
<p>[INSERT option and result types here as the initial pattern match code]</p>

<h4 id="destructing-lists-with-pattern-matching">Destructing Lists with pattern matching</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span>  <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">rev</span> <span class="n">xs</span> <span class="o">@</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="p">;;</span>
<span class="n">rev</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span> <span class="c">(* = 1 :: ( 2 :: ( 3 :: [])) *)</span>
</code></pre></div></div>
<p>“Data structure corresponds to control flow” here and in other examples.</p>

<h4 id="introduction-to-ocaml-notes">Introduction to OCaml notes</h4>
<p>High-level outline of how PLI version needs to evolve</p>
<ul>
  <li>utop and <code class="highlighter-rouge">Core</code>/<code class="highlighter-rouge">Base</code> from the get-go: = on ints only but pop into <code class="highlighter-rouge">Poly</code> when convenient.</li>
  <li>Lots of List.blah early on, including folds, pipes, etc.</li>
  <li>add in all of the syntax stuff below that I skipped in PLI</li>
  <li>Many more real examples of programs, get further away from the toy stuff.</li>
  <li>Type-directed programming basics early</li>
  <li>Need to decide on modality, either feeding into top loop or dune.  Problem is VSCode needs a dune build to get merlin file set up properly, it is hard to have files loaded that give errors.</li>
</ul>

<h4 id="basic-functional-programming-in-ocaml">Basic Functional Programming in OCaml</h4>
<ul>
  <li>Basic OCaml
    <ul>
      <li>elementary <code class="highlighter-rouge">ocaml</code>, <code class="highlighter-rouge">utop</code>, <code class="highlighter-rouge">.ocamlinit</code> file</li>
      <li>expressions, let, functions, lists, pattern matching, higher-order functions</li>
      <li>Lists lists lists, folds, pipes etc.</li>
    </ul>
  </li>
</ul>

<h4 id="foundational-libraries-i">Foundational Libraries I</h4>
<ul>
  <li>Lists in Base - RWOC 1 a bit (tour) and RWOC 3.  Lots of important functions available.</li>
  <li>Fn, Option, Result, etc etc etc Base versions</li>
</ul>

<h4 id="notes-new-stuff-not-in-pli-for-basic-ocaml-now">NOTES: New stuff not in PLI for Basic OCaml now.</h4>
<ul>
  <li>@@ application</li>
  <li>_ - all the places it works</li>
  <li>pipelining</li>
  <li>Pipelining for functional data construction - <code class="highlighter-rouge">List.([] |&gt;  cons 1 |&gt; cons 2 |&gt; cons 3 |&gt; cons 4)</code> (notice it makes it in reverse).  similar to message chaining of OOP.</li>
  <li><code class="highlighter-rouge">let rec sum = function | [] -&gt; ..</code> (needs function not fun)</li>
  <li>Minimal commands for dune, .ocamlinit, top loop.  Basically fixed recipes to start with.</li>
  <li>let is a special application - needed for monads later</li>
  <li>= on ints only by default with <code class="highlighter-rouge">Base</code>.  <code class="highlighter-rouge">String.(=)</code> etc explicitly for other base types.  Or cheat with <code class="highlighter-rouge">open Poly</code> (restores original OCaml polymorphic <code class="highlighter-rouge">=</code> which is dangerous)</li>
  <li>Named and optional and optional/w/default function arguments, punning with f ~x (x is both var at caller and name in callee), similar as pun in definition of function).  RWOC covers well.</li>
  <li>Operators as functions and making your own infix syntax - <code class="highlighter-rouge">let (^^) x y = x * y</code> kind of thing.  see RWOC prefix and infix operators.</li>
  <li><code class="highlighter-rouge">begin</code>/<code class="highlighter-rouge">end</code> to replace parens</li>
  <li>effects done later, not in earlier HWs anyway.</li>
</ul>

<h2 id="data-structures-variants-and-records">Data structures (variants and records)</h2>
<p>This is mostly covered in RWOC chapters on variants and records.</p>

<ul>
  <li>Basic records and variants stuff obviously</li>
  <li><code class="highlighter-rouge">result</code> type - <code class="highlighter-rouge">Ok</code> or <code class="highlighter-rouge">Error</code>.</li>
  <li>Advanced patterns - <code class="highlighter-rouge">p when e</code>, <code class="highlighter-rouge">'a' .. 'z'</code>, <code class="highlighter-rouge">as x</code>, or <code class="highlighter-rouge">|</code> patterns in let, <code class="highlighter-rouge">{x;y}</code> is same as <code class="highlighter-rouge">{x=x;y=y}</code>…  Cornell 3.1.7</li>
  <li>Polymorphic variants aka anonymous variants - Cornell 3.2.4.4, RWOC variants chapter</li>
  <li>See RWOC chapters on variants and records for lots of new conventions and examples.</li>
  <li>record field name punning: <code class="highlighter-rouge">let r = {x;y}</code> abbreviation - RWOC Ch5</li>
  <li><code class="highlighter-rouge">let r' = { r with x = ..; y = }</code>  for changing just a few fields - RWOC 5</li>
  <li>Embedding record declarations in variants - like named args on variant fields:<br />
<code class="highlighter-rouge">type gbu = | Good of { sugar : string; } | Bad of { spice: string; } | Ugly</code></li>
</ul>

<h2 id="types">Types</h2>
<ul>
  <li>Type inference</li>
  <li>Extensible variants - OCaml manual 8.14</li>
  <li>Equality on and Pretty printing declated data types with <code class="highlighter-rouge">ppx_deriving</code></li>
  <li>Type-driven development - very important topic to touch on somewhere; fits well with GADTS.</li>
</ul>

<h2 id="modules">Modules</h2>
<ul>
  <li>Structures and functors; look at the <code class="highlighter-rouge">Core</code> libraries to see what we need to cover, need to at least be users of things like <code class="highlighter-rouge">include</code>, nested modules, first-class modules, etc (whatever Core uses in particular).  Idea is to start out as writers of basic modules and users of the fancier stuff, and learn how to write the fancier stuff later.</li>
  <li>type abstraction, module signatures</li>
</ul>

<h2 id="basic-development">Basic Development</h2>
<p>(Could do this a bit earlier, it is making modules but could skip on that for a bit)</p>

<ul>
  <li>Simple whole programs, basic dune building and testing – see <code class="highlighter-rouge">code/set_example</code> .. might want to change to use <code class="highlighter-rouge">In_Channel</code> to just read in the numbers, see RWOC for some boilerplate for that at end of the tour.. includes basic dune etc.</li>
  <li>Merlin super basics (can pretty much ignore as dune should build a correct <code class="highlighter-rouge">.merlin</code> file)</li>
</ul>

<h2 id="side-effects">Side effects</h2>

<h3 id="mutation">Mutation</h3>
<ul>
  <li>Standard mutation topics: ref, mutable records, arrays.  Printing earlier - ?</li>
  <li>sequencing; <code class="highlighter-rouge">ignore(3+4); print_string "hi"</code> to avoid warnings.  Cornell 8.3</li>
  <li><code class="highlighter-rouge">==</code> vs <code class="highlighter-rouge">=</code> - Cornell 8.6</li>
  <li>Mutable stack eg - Cornell 8.8; get a Base alternative example, e.g. <code class="highlighter-rouge">Hashtbl</code> (see libraries)</li>
  <li>Weakly polymorphic types <code class="highlighter-rouge">‘_a</code> - Cornell 8.8 (save details on this for advanced types below?)</li>
</ul>

<h3 id="exceptions">Exceptions</h3>
<p>See RWOC Error/Exceptions chapter.</p>
<ul>
  <li>lack of exception effects in types is old-fashioned.  Using option types or Ok/Error is often better.</li>
  <li><code class="highlighter-rouge">match f x with exception _ -&gt; blah | ...</code> shorthand syntax</li>
</ul>

<h3 id="io-and-stdio">I/O and Stdio</h3>
<ul>
  <li>Basic printing</li>
  <li><code class="highlighter-rouge">Stdio</code>
    <ul>
      <li>Channels, etc</li>
    </ul>
  </li>
</ul>

<h2 id="libraries">Libraries</h2>
<p>Do libraries with modules as the <code class="highlighter-rouge">Core</code> modules need understanding of functors, abstraction, etc</p>

<ul>
  <li><a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/core/index.html"><code class="highlighter-rouge">Core</code></a>
    <ul>
      <li><code class="highlighter-rouge">Map</code> (and <code class="highlighter-rouge">List.Assoc</code> a bit).  RWOC 13.</li>
      <li><code class="highlighter-rouge">Hashtbl</code>, good example of mutable code.  RWOC 13</li>
    </ul>
  </li>
  <li>Command line parsing - RWOC ch14</li>
  <li>JSON data - RWOC ch15</li>
</ul>

<h2 id="buildpackagetest-in-ocaml">Build/Package/Test in Ocaml</h2>

<h3 id="dune">Dune</h3>
<ul>
  <li>Tree nature of dune files</li>
  <li>Defining libraries with <code class="highlighter-rouge">library</code></li>
  <li>Defining executables with <code class="highlighter-rouge">executable</code></li>
  <li>Using libraries via <code class="highlighter-rouge">libraries</code> (uses <code class="highlighter-rouge">ocamlfind</code> in the background)</li>
  <li>etc for other options in <code class="highlighter-rouge">dune</code> files</li>
  <li>Test executables with <code class="highlighter-rouge">Ounit2</code></li>
  <li>Poking your code in the top loop: <code class="highlighter-rouge">dune utop</code>, <code class="highlighter-rouge">dune top</code>, and <code class="highlighter-rouge">#use_output "dune top";;</code></li>
  <li>Merlin with dune - basics on configuring to parse libraries used properly, etc.  Cornell 3.1.3.4</li>
  <li>Command line: <code class="highlighter-rouge">dune build</code>, <code class="highlighter-rouge">dune runtest</code>, <code class="highlighter-rouge">dune exec</code></li>
  <li>Backtracing on error in dune: use <code class="highlighter-rouge">Base</code>, backtraces turned on by default then.</li>
</ul>

<h3 id="basic-documentation-and-testing">Basic Documentation and Testing</h3>
<ul>
  <li>Principles of testing
    <ul>
      <li>black box and glass box testing.  Cornell Ch7</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">ocamldoc</code>comments, Cornell 2.3.7</li>
  <li><code class="highlighter-rouge">OUnit</code> unit testing library Cornell 3.1.3</li>
</ul>

<h2 id="idiomatic-functional-programming">Idiomatic Functional Programming</h2>
<ul>
  <li>A major theme of the course</li>
  <li>design patterns (OO) = idioms (FP)</li>
  <li>Contrasting OO with functional - state machine vs pipeline of data (data-oriented design). Look into doing this earlier in the class.</li>
  <li>Refactoring also applies to FP.
    <ul>
      <li>pull out duplicate code as its own function parameter, or inline if gratuitous</li>
      <li>Divide one function into two if it is doing two different things</li>
      <li>Make code more parametric (or less if not needed)</li>
      <li>Rename</li>
      <li>Lift or hide (demote) functions/variables</li>
      <li>Inline definition or converse - inline let definitions if simple, make more if too complex</li>
      <li>Move around reponsibilties, make more modular by putting fewer things in public interface</li>
      <li>Type refactoring - remove unneeded things, generalize (make polymorphic or GADT)</li>
      <li>Module refactoring - pull out code into a new module, move a function from one module to another.</li>
      <li>Combinize: replace recursion with maps and folds</li>
      <li>Use more pattern matching</li>
      <li>[A list of smells and principles also would be good, many of the above are DRY or “compression-driven development” issues.]</li>
    </ul>
  </li>
  <li>Type-aided extension: add a type to a variant, then clean up on the type error messages.
    <ul>
      <li>Applies to many other contexts as well: make a change, chase type errors.  Type errors gone =&gt; code works.</li>
    </ul>
  </li>
  <li>Go through some imperative to functional code refactorings</li>
  <li>The expression problem and functional vs OO trade-off.</li>
</ul>

<h2 id="specification">Specification</h2>

<ul>
  <li>Specifying properties of programs
    <ul>
      <li>Type-directed programming: start out by writing types &amp; module signatures as a skeleton</li>
      <li><code class="highlighter-rouge">assert</code> for more fine-grained properties not expressible with types</li>
      <li>Referential transparency</li>
      <li>Abstract interfaces: white box vs gray box vs black box (&lt;abst&gt;).
        <ul>
          <li>Black box can be bad - like closed-source code.  Really need a read-only notion, you can see the structure if needed.  Too hard now to figure out what is under the hood.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Invariants
    <ul>
      <li>Types as (basic) invariants, with an automatic always-running static checker</li>
      <li>Data structure Invariants - Cornell Representation Invariants, Ch6</li>
      <li>recursive function invariants</li>
      <li>representation invariants</li>
    </ul>
  </li>
</ul>

<h2 id="orphan-topics">Orphan Topics</h2>
<ul>
  <li>Streams and laziness - Cornell 12.1</li>
  <li>Memoization - RWOC Imperative chapter, Cornell 12.4</li>
</ul>

<h2 id="advanced-modules">Advanced modules</h2>
<p>(May need to do some of this earlier)</p>

<ul>
  <li><code class="highlighter-rouge">include</code> - Cornell 5.3.1; 5.3.1.2; subtlety of abstr with it</li>
  <li>Nested modules - in RWOC 4.</li>
  <li>First-class modules - RWOC 10.</li>
  <li><code class="highlighter-rouge">let open List in ..</code> and <code class="highlighter-rouge">List.(...map....)</code> syntax</li>
  <li>Anonymous functors:  <code class="highlighter-rouge">module F = functor (M : S) -&gt; ... -&gt; functor (M : S) -&gt; struct  ... end</code></li>
  <li>more examples of functors being useful. libraries, etc. Cornell 5.3.2.2, .3</li>
  <li>passing anonymous structs to functors Cornell 5.3.2.3</li>
  <li><code class="highlighter-rouge">comparator_witness</code> and comparison in Jane Street modules</li>
  <li>Type sharing constraints and destructive substitution to deal with too-hidden types.  RWOC Functors chapter.</li>
</ul>

<h2 id="advanced-types">Advanced Types</h2>

<ul>
  <li>Weak polymorphism</li>
  <li>Covariant types <code class="highlighter-rouge">+'a t = ...</code> - declares contents are not mutable so can be fully polymorphic not weakly.  RWOC weak polymorphism section.</li>
  <li>GADTS - see PLII lecture notes.    Make sure to discuss with type-driven development</li>
  <li>New Jane street extensions: <a href="https://github.com/janestreet/higher_kinded/">higher-kinded types</a> and <a href="https://github.com/janestreet/accessor">accessors</a> which are like Haskell lenses.</li>
</ul>

<h2 id="advanced-testing">Advanced Testing</h2>
<p>See <a href="https://github.com/realworldocaml/book/tree/master/book/testing">draft RWOC chapter</a></p>

<ul>
  <li>Along with <code class="highlighter-rouge">OUnit</code> may also want to do <code class="highlighter-rouge">ppx_inline_tests</code> or whatever it is called.  RWOC using it.. Only problem is it is not working with 4.10 and utop.</li>
  <li><code class="highlighter-rouge">Bisect</code> for code coverage. Cornell 7.4</li>
  <li>Automated test generation aka randomized testing aka fuzz testing, <code class="highlighter-rouge">QCheck</code>.  Cornell 7.7-7.9</li>
</ul>

<h2 id="monads-and-monad-likes">Monads and monad-likes</h2>

<h3 id="monad-warm-up">Monad Warm-up</h3>
<ul>
  <li><code class="highlighter-rouge">Option.bind</code> in base, also let%bind for that.. RWOC Error Handling chapter</li>
  <li>State passing and exception encoding - PLII notes</li>
  <li>CPS</li>
  <li>Async library and promises - Cornell 12.2 or RWOC 14.  Leaning to Async.</li>
</ul>

<h3 id="monads-proper">Monads proper.</h3>

<ul>
  <li>Monads.  PLII notes for all the monad topics.</li>
  <li>Monad laws.</li>
  <li>Monad transormers (or, skip?)</li>
  <li>Monad programming.  Need to decide what libraries/bindings to use.  Jane Street has <code class="highlighter-rouge">Base.Monad</code> and <code class="highlighter-rouge">ppx_let</code>, or use <code class="highlighter-rouge">let*</code> now. unclear.  I don’t think Jane street library has transformers?</li>
  <li>Comprehension.. need to research this.  See <code class="highlighter-rouge">map</code> in <code class="highlighter-rouge">Base.Monad</code> stuff.</li>
</ul>

<h2 id="metaprogramming-ppx-extensions">Metaprogramming: ppx extensions</h2>
<ul>
  <li>See RWOC ch23 (not written yet unfortunately).</li>
  <li>Tutorial at http://rgrinberg.com/posts/extension-points-3-years-later/</li>
  <li><a href="https://github.com/janestreet/ppx_jane"><code class="highlighter-rouge">ppx_jane</code></a> (comparison, hash, conversion between S-Expr),</li>
  <li><a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/ppx_let/index.html"><code class="highlighter-rouge">ppx_let</code></a>.</li>
</ul>

<h2 id="under-the-hood-of-functional-language-runtimes">Under the hood of functional language runtimes</h2>
<ul>
  <li>Substitution notion of running functions and <code class="highlighter-rouge">let</code> - informal PLI stuff.</li>
  <li>Tail recursion Cornell 3.1.1.5.</li>
  <li>Garbage collection</li>
  <li>Efficiency of functional vs mutable data structures.  Some in Ch9 Cornell.</li>
  <li>RWOC has a chapter on this, also on GC, maybe do a peek at that (not much though)</li>
</ul>

<h2 id="fp-in-other-languages">FP in other languages</h2>

<ul>
  <li>JavaScript, <a href="https://reactjs.org/docs/hooks-intro.html">React hooks</a>, and <a href="https://reasonml.github.io/reason-react/">ReasonReact</a></li>
  <li>Python</li>
  <li>Java lambdas</li>
  <li>Elm</li>
</ul>

<h2 id="top-level-directives-not-sure-where-to-put-this-just-my-own-reference-for-now">Top level directives (not sure where to put this, just my own reference for now)</h2>
<ul>
  <li><code class="highlighter-rouge">#directory adir</code> - adds <code class="highlighter-rouge">adir</code> to the list of directories to search for files.</li>
  <li><code class="highlighter-rouge">#pwd</code> - shows current working directory.</li>
  <li><code class="highlighter-rouge">#trace afun</code> - calls and returns to <code class="highlighter-rouge">afun</code> will now be dumped to top level - a simple debugging tool.</li>
  <li><code class="highlighter-rouge">#use "afile.ml"</code> - loads code file as if it was copied and pasted into the top loop.</li>
  <li><code class="highlighter-rouge">#mod_use</code> - like <code class="highlighter-rouge">#use</code> but loads the file like it was a module (name of file as a module name)</li>
  <li><code class="highlighter-rouge">#load "blah.cmo"</code>,<code class="highlighter-rouge">#load "blahlib.cma"</code> - load a compiled binary or library file.</li>
  <li><code class="highlighter-rouge">#show</code> - shows the type for an entity (variable or module).</li>
  <li><code class="highlighter-rouge">#require</code> - loads a library (does not <code class="highlighter-rouge">open</code> it, just loads the module)</li>
  <li><code class="highlighter-rouge">#use_output "dune top"</code> - like the shell <code class="highlighter-rouge">xargs</code> command - run a command and assume output is top loop input commands.  The particular command <code class="highlighter-rouge">dune top</code> generates top loop commands to set up libraries and load the current project.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
