<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/syllabus.html">Syllabus</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    
<h1 id="outline-of-lecture-units">Outline of Lecture Units</h1>

<h2 id="course-outline">Course Outline</h2>

<ul>
  <li>Just repeat the Syllabus here.</li>
</ul>

<h2 id="what-is-fp">What is FP?</h2>

<h3 id="history-in-brief">History in brief</h3>

<ul>
  <li>Lambda calculus, 1930’s - logicians (Church, Turing, Kleene, Curry, etc)</li>
  <li>Logic proofs are formal constructions</li>
  <li>Core ideas of functional programming already present</li>
  <li>But no computers so no running, only hand-calculation</li>
  <li>Lisp, 1960’s (McCarthy)</li>
  <li>Implement the ideas of the mathematicians</li>
  <li>Goal application space: artificial intelligence programming</li>
  <li>Added list data to functions: <strong>Lis</strong>t <strong>P</strong>rocessing</li>
  <li>Typed functional languages, 70’s &amp; 80’s: ML and its descendents Haskell and OCaml</li>
  <li>Will see what this is in detail as we use OCaml</li>
  <li>Modern era: add FP as possibility in mainstream: Python, JavaScript, Java, C++, etc.</li>
  <li>FP now edging out OO school in some domains.</li>
</ul>

<h3 id="imperative-vs-oo-vs-fp">Imperative vs OO vs FP</h3>

<ul>
  <li>Oversimplifying but these are the three modern schools</li>
  <li>More oversimplifying: “Imperative = C, OO = Java, FP = OCaml”</li>
  <li>other languages can also be put in schools, but these are leading representatives today</li>
</ul>

<h3 id="imperative">Imperative</h3>

<ul>
  <li>Imperative also has functions, but functions often have side effects (e.g. mutate some shared data structures)</li>
  <li>C has function pointers but they are not widely used and lack needed expressiveness (which we will cover).</li>
</ul>

<h3 id="o-o">O-O</h3>

<ul>
  <li>Objects tend to have “their” state encpsulated within their boundary</li>
  <li>Still it is usually a mutable state - change over time</li>
  <li>A function is something like an object with one method, <code class="highlighter-rouge">call</code>, and with no fields</li>
  <li>That doesn’t fully capture higher-order functions which is why <code class="highlighter-rouge">lambda</code> added to Jave.</li>
</ul>

<h3 id="functional">Functional</h3>

<ul>
  <li>Key aspect is lack of mutation: more like a mathematical function, the output only depends on the input and it’s only output is the codomain value, not any side effects like printing, mutating, raising exceptions, etc.</li>
  <li>Lack of side effects is called “referential transparency” - variable values don’t change out from under you (like in math textbook).</li>
  <li>Standard data structures not too different from imperative case: dictionaries, lists, etc, but often will themselves be non-mutable</li>
  <li>Key advantage is higher-order-ness: code is data, make new functions, accept functions as parameters.</li>
  <li>Allows for powerful new programming paradigms.  give examples like compose, map, etc.</li>
  <li>Less good at supporting extension, no notion of subclass in common functional paradigms (not impossible to add though).</li>
</ul>

<h3 id="who-wins">Who wins?</h3>
<p>Thesis:</p>
<ul>
  <li>Imperative wins for low-level code: underlying machine instructions are in the imperative domain, will run faster.</li>
  <li>O-O wins for super large apps with fairly shallow logic: UI’s, many apps, etc.</li>
  <li>Functional wins for complex algorithms with deep inner logic</li>
  <li>Gets too confusing with mutation, and better composition of functions makes code easier to understand.</li>
  <li>Of course this choice is never made in a vacuum: existing codebases and libraries, programmer experience, etc.</li>
</ul>

<h2 id="introduction-to-ocaml">Introduction to OCaml</h2>
<p>High-level outline of how PLI version needs to evolve</p>
<ul>
  <li>utop and <code class="highlighter-rouge">Core</code> from the get-go: = on ints only but pop into <code class="highlighter-rouge">Poly</code> when convenient.</li>
  <li>Lots of List.blah early on, including folds, pipes, etc.</li>
  <li>add in all of the syntax stuff below that I skipped in PLI</li>
  <li>Many more real examples of programs, get further away from the toy stuff.</li>
</ul>

<h4 id="basic-functional-programming-in-ocaml">Basic Functional Programming in OCaml</h4>
<ul>
  <li>Basic OCaml
    <ul>
      <li>elementary <code class="highlighter-rouge">ocaml</code>, <code class="highlighter-rouge">utop</code>, <code class="highlighter-rouge">.ocamlinit</code> file</li>
      <li>expressions, let, functions, lists, pattern matching, higher-order functions</li>
      <li>Lists lists lists, folds, pipes etc.</li>
    </ul>
  </li>
</ul>

<h4 id="new-stuff-not-in-pli-for-basic-ocaml-now">New stuff not in PLI for Basic OCaml now.</h4>
<ul>
  <li>@@ application</li>
  <li>_ - all the places it works</li>
  <li>pipelining</li>
  <li>Pipelining for functional data construction - <code class="highlighter-rouge">List.([] |&gt;  cons 1 |&gt; cons 2 |&gt; cons 3 |&gt; cons 4)</code> (notice it makes it in reverse).  similar to message chaining of OOP.</li>
  <li><code class="highlighter-rouge">let rec sum = function | [] -&gt; ..</code> (needs function not fun)</li>
  <li>Minimal commands for dune, .ocamlinit, top loop.  Basically fixed recipes to start with.</li>
  <li>let is a special application - needed for monads later</li>
  <li>= on ints only by default with <code class="highlighter-rouge">Base</code>.  <code class="highlighter-rouge">String.(=)</code> etc explicitly for other base types.  Or cheat with <code class="highlighter-rouge">open Poly</code> (restores original OCaml polymorphic <code class="highlighter-rouge">=</code> which is dangerous)</li>
  <li>Named and optional and optional/w/default function arguments, punning with f ~x (x is both var at caller and name in callee), similar as pun in definition of function).  RWOC covers well.</li>
  <li>Operators as functions and making your own infix syntax - <code class="highlighter-rouge">let (^^) x y = x * y</code> kind of thing.  see RWOC prefix and infix operators.</li>
  <li><code class="highlighter-rouge">begin</code>/<code class="highlighter-rouge">end</code> to replace parens</li>
  <li>effects done later, not in earlier HWs anyway.</li>
</ul>

<h2 id="data-structures-variants-and-records">Data structures (variants and records)</h2>
<p>This is mostly covered in RWOC chapters on variants and records.</p>

<ul>
  <li>Basic records and variants stuff obviously</li>
  <li>Advanced patterns - <code class="highlighter-rouge">p when e</code>, <code class="highlighter-rouge">'a' .. 'z'</code>, <code class="highlighter-rouge">as x</code>, or <code class="highlighter-rouge">|</code> patterns in let, <code class="highlighter-rouge">{x;y}</code> is same as <code class="highlighter-rouge">{x=x;y=y}</code>…  Cornell 3.1.7</li>
  <li>Polymorphic variants aka anonymous variants - Cornell 3.2.4.4, RWOC variants chapter</li>
  <li>See RWOC chapters on variants and records for lots of new conventions and examples.</li>
  <li>record field name punning - RWOC Ch5</li>
  <li><code class="highlighter-rouge">let r' = { r with x = ..; y = }</code>  for changing just a few fields - RWOC 5</li>
  <li>Embedding record declarations in variants - like named args on variant fields:<br />
<code class="highlighter-rouge">type gbu = | Good of { sugar : string; } | Bad of { spice: string; } | Ugly</code></li>
</ul>

<h2 id="types">Types</h2>
<ul>
  <li>Type inference</li>
  <li>Extensible variants - OCaml manual 8.14</li>
  <li>Equality on and Pretty printing declated data types with <code class="highlighter-rouge">ppx_deriving</code></li>
  <li>Type-driven development - very important topic to touch on somewhere; fits well with GADTS.</li>
</ul>

<h2 id="modules">Modules</h2>
<ul>
  <li>elemts of structures, functors; hit on more advanced stuff later</li>
  <li>type abstraction, module signatures</li>
  <li>Simple whole programs, basic dune building and testing – see <code class="highlighter-rouge">code/set_example</code> .. might want to change to use <code class="highlighter-rouge">In_Channel</code> to just read in the numbers, see RWOC for some boilerplate for that at end of the tour.. includes basic dune etc.</li>
</ul>

<h2 id="side-effects">Side effects</h2>

<h3 id="mutation">Mutation</h3>
<ul>
  <li>Standard mutation topics: ref, mutable records, arrays.  Printing earlier - ?</li>
  <li>sequencing; <code class="highlighter-rouge">ignore(3+4); print_string "hi"</code> to avoid warnings.  Cornell 8.3</li>
  <li><code class="highlighter-rouge">==</code> vs <code class="highlighter-rouge">=</code> - Cornell 8.6</li>
  <li>Mutable stack eg - Cornell 8.8; get a Base alternative example, e.g. <code class="highlighter-rouge">Hashtbl</code> (see libraries)</li>
  <li>Weakly polymorphic types <code class="highlighter-rouge">‘_a</code> - Cornell 8.8 (save details on this for advanced types below?)</li>
</ul>

<h3 id="exceptions">Exceptions</h3>
<p>See RWOC Error/Exceptions chapter.</p>
<ul>
  <li>lack of exception effects in types is old-fashioned.  Using option types or Ok/Error is often better.</li>
  <li><code class="highlighter-rouge">match f x with exception _ -&gt; blah | ...</code> shorthand syntax</li>
</ul>

<h3 id="io-and-stdio">I/O and Stdio</h3>
<ul>
  <li>Basic printing</li>
  <li><code class="highlighter-rouge">Stdio</code>
    <ul>
      <li>Channels, etc</li>
    </ul>
  </li>
</ul>

<h3 id="libraries">Libraries</h3>
<p>Do libraries with modules as the <code class="highlighter-rouge">Core</code> modules need understanding of functors, abstraction, etc</p>

<ul>
  <li><a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/core/index.html"><code class="highlighter-rouge">Core</code></a>
    <ul>
      <li>Lists in Base - RWOC 1 a bit (tour) and RWOC 3.  Worth covering, lots of important functions available.</li>
      <li><code class="highlighter-rouge">Map</code> (and <code class="highlighter-rouge">List.Assoc</code> a bit).  RWOC 13.</li>
      <li><code class="highlighter-rouge">Hashtbl</code>, good example of mutable code.  RWOC 13</li>
    </ul>
  </li>
  <li>Command line parsing - RWOC ch14</li>
  <li>JSON data - RWOC ch15</li>
</ul>

<h2 id="buildpackagetest-in-ocaml">Build/Package/Test in Ocaml</h2>

<h3 id="dune">Dune</h3>
<ul>
  <li>Tree nature of dune files</li>
  <li>Defining libraries with <code class="highlighter-rouge">library</code></li>
  <li>Defining executables with <code class="highlighter-rouge">executable</code></li>
  <li>Using libraries via <code class="highlighter-rouge">libraries</code> (uses <code class="highlighter-rouge">ocamlfind</code> in the background)</li>
  <li>etc for other options in <code class="highlighter-rouge">dune</code> files</li>
  <li>Test executables with <code class="highlighter-rouge">Ounit2</code></li>
  <li>Poking your code in the top loop: <code class="highlighter-rouge">dune utop</code>, <code class="highlighter-rouge">dune top</code>, and <code class="highlighter-rouge">#use_output "dune top";;</code></li>
  <li>Merlin with dune - basics on configuring to parse libraries used properly, etc.  Cornell 3.1.3.4</li>
  <li>Command line: <code class="highlighter-rouge">dune build</code>, <code class="highlighter-rouge">dune runtest</code>, <code class="highlighter-rouge">dune exec</code></li>
  <li>Backtracing on error in dune: use <code class="highlighter-rouge">Base</code>, backtraces turned on by default then.</li>
</ul>

<h3 id="basic-documentation-and-testing">Basic Documentation and Testing</h3>
<ul>
  <li>Principles of testing
    <ul>
      <li>black box and glass box testing.  Cornell Ch7</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">ocamldoc</code>comments, Cornell 2.3.7</li>
  <li><code class="highlighter-rouge">OUnit</code> unit testing library Cornell 3.1.3</li>
</ul>

<h2 id="idiomatic-functional-programming">Idiomatic Functional Programming</h2>
<ul>
  <li>A major theme of the course</li>
  <li>design patterns (OO) = idioms (FP)</li>
  <li>Contrasting OO with functional - state machine vs pipeline of data (data-oriented design). Look into doing this earlier in the class.</li>
  <li>Refactoring also applies to FP.
    <ul>
      <li>pull out duplicate code as its own function parameter, or inline if gratuitous</li>
      <li>Divide one function into two if it is doing two different things</li>
      <li>Make code more parametric (or less if not needed)</li>
      <li>Rename</li>
      <li>Lift or hide (demote) functions/variables</li>
      <li>Inline definition or converse - inline let definitions if simple, make more if too complex</li>
      <li>Move around reponsibilties, make more modular by putting fewer things in public interface</li>
      <li>Type refactoring - remove unneeded things, generalize (make polymorphic or GADT)</li>
      <li>Module refactoring - pull out code into a new module, move a function from one module to another.</li>
      <li>Combinize: replace recursion with maps and folds</li>
      <li>Use more pattern matching</li>
    </ul>
  </li>
  <li>Type-aided extension: add a type to a variant, then clean up on the type error messages.
    <ul>
      <li>Applies to many other contexts as well: make a change, chase type errors.  Type errors gone =&gt; code works.</li>
    </ul>
  </li>
  <li>Go through some imperative to functional code refactorings</li>
  <li>The expression problem and functional vs OO trade-off.</li>
</ul>

<h2 id="specification">Specification</h2>

<ul>
  <li>Specifying properties of programs
    <ul>
      <li>Type-directed programming: start out by writing types &amp; module signatures as a skeleton</li>
      <li><code class="highlighter-rouge">assert</code> for more fine-grained properties not expressible with types</li>
      <li>Referential transparency</li>
      <li>Abstract interfaces: white box vs gray box vs black box (&lt;abst&gt;).
        <ul>
          <li>Black box can be bad - like closed-source code.  Really need a read-only notion, you can see the structure if needed.  Too hard now to figure out what is under the hood.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Invariants
    <ul>
      <li>Types as (basic) invariants, with an automatic always-running static checker</li>
      <li>Data structure Invariants - Cornell Representation Invariants, Ch6</li>
      <li>recursive function invariants</li>
      <li>representation invariants</li>
    </ul>
  </li>
</ul>

<h2 id="orphan-topics">Orphan Topics</h2>
<ul>
  <li>Streams and laziness - Cornell 12.1</li>
  <li>Memoization - RWOC Imperative chapter, Cornell 12.4</li>
</ul>

<h2 id="advanced-modules">Advanced modules</h2>
<p>(May need to do some of this earlier)</p>

<ul>
  <li><code class="highlighter-rouge">include</code> - Cornell 5.3.1; 5.3.1.2; subtlety of abstr with it</li>
  <li>Nested modules - in RWOC 4.</li>
  <li>First-class modules - RWOC 10.</li>
  <li><code class="highlighter-rouge">let open List in ..</code> and <code class="highlighter-rouge">List.(...map....)</code> syntax</li>
  <li>Anonymous functors:  <code class="highlighter-rouge">module F = functor (M : S) -&gt; ... -&gt; functor (M : S) -&gt; struct  ... end</code></li>
  <li>more examples of functors being useful. libraries, etc. Cornell 5.3.2.2, .3</li>
  <li>passing anonymous structs to functors Cornell 5.3.2.3</li>
  <li><code class="highlighter-rouge">comparator_witness</code> and comparison in Jane Street modules</li>
  <li>Type sharing constraints and destructive substitution to deal with too-hidden types.  RWOC Functors chapter.</li>
</ul>

<h2 id="advanced-types">Advanced Types</h2>

<ul>
  <li>Weak polymorphism</li>
  <li>Covariant types <code class="highlighter-rouge">+'a t = ...</code> - declares contents are not mutable so can be fully polymorphic not weakly.  RWOC weak polymorphism section.</li>
  <li>GADTS - see PLII lecture notes.    Make sure to discuss with type-driven development</li>
  <li>New Jane street extensions: <a href="https://github.com/janestreet/higher_kinded/">higher-kinded types</a> and <a href="https://github.com/janestreet/accessor">accessors</a> which are like Haskell lenses.</li>
</ul>

<h2 id="advanced-testing">Advanced Testing</h2>
<p>See <a href="https://github.com/realworldocaml/book/tree/master/book/testing">draft RWOC chapter</a></p>

<ul>
  <li>Along with <code class="highlighter-rouge">OUnit</code> may also want to do <code class="highlighter-rouge">ppx_inline_tests</code> or whatever it is called.  RWOC using it.. Only problem is it is not working with 4.10 and utop.</li>
  <li><code class="highlighter-rouge">Bisect</code> for code coverage. Cornell 7.4</li>
  <li>Automated test generation aka randomized testing aka fuzz testing, <code class="highlighter-rouge">QCheck</code>.  Cornell 7.7-7.9</li>
</ul>

<h2 id="monads-and-monad-likes">Monads and monad-likes</h2>

<h3 id="monad-warm-up">Monad Warm-up</h3>
<ul>
  <li><code class="highlighter-rouge">Option.bind</code> in base, also let%bind for that.. RWOC Error Handling chapter</li>
  <li>State passing and exception encoding - PLII notes</li>
  <li>CPS</li>
  <li>Async library and promises - Cornell 12.2 or RWOC 14.  Leaning to Async.</li>
</ul>

<h3 id="monads-proper">Monads proper.</h3>

<ul>
  <li>Monads.  PLII notes for all the monad topics.</li>
  <li>Monad laws.</li>
  <li>Monad transormers (or, skip?)</li>
  <li>Monad programming.  Need to decide what libraries/bindings to use.  Jane Street has <code class="highlighter-rouge">Base.Monad</code> and <code class="highlighter-rouge">ppx_let</code>, or use <code class="highlighter-rouge">let*</code> now. unclear.  I don’t think Jane street library has transformers?</li>
  <li>Comprehension.. need to research this.  See <code class="highlighter-rouge">map</code> in <code class="highlighter-rouge">Base.Monad</code> stuff.</li>
</ul>

<h2 id="metaprogramming-ppx-extensions">Metaprogramming: ppx extensions</h2>
<ul>
  <li>See RWOC ch23 (not written yet unfortunately).</li>
  <li>Tutorial at http://rgrinberg.com/posts/extension-points-3-years-later/</li>
  <li><a href="https://github.com/janestreet/ppx_jane"><code class="highlighter-rouge">ppx_jane</code></a> (comparison, hash, conversion between S-Expr),</li>
  <li><a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/ppx_let/index.html"><code class="highlighter-rouge">ppx_let</code></a>.</li>
</ul>

<h2 id="under-the-hood-of-functional-language-runtimes">Under the hood of functional language runtimes</h2>
<ul>
  <li>Substitution notion of running functions and <code class="highlighter-rouge">let</code> - informal PLI stuff.</li>
  <li>Tail recursion Cornell 3.1.1.5.</li>
  <li>Garbage collection</li>
  <li>Efficiency of functional vs mutable data structures.  Some in Ch9 Cornell.</li>
  <li>RWOC has a chapter on this, also on GC, maybe do a peek at that (not much though)</li>
</ul>

<h2 id="fp-in-other-languages">FP in other languages</h2>

<ul>
  <li>JavaScript, <a href="https://reactjs.org/docs/hooks-intro.html">React hooks</a>, and <a href="https://reasonml.github.io/reason-react/">ReasonReact</a></li>
  <li>Python</li>
  <li>Java lambdas</li>
  <li>Elm</li>
</ul>

<h2 id="top-level-directives-not-sure-where-to-put-this-just-my-own-reference-for-now">Top level directives (not sure where to put this, just my own reference for now)</h2>
<ul>
  <li><code class="highlighter-rouge">#directory adir</code> - adds <code class="highlighter-rouge">adir</code> to the list of directories to search for files.</li>
  <li><code class="highlighter-rouge">#trace afun</code> - calls and returns to <code class="highlighter-rouge">afun</code> will now be dumped to top level - a simple debugging tool.</li>
  <li><code class="highlighter-rouge">#use "afile.ml"</code> - loads code file as if it was copied and pasted into the top loop.</li>
  <li><code class="highlighter-rouge">#mod_use</code> - like <code class="highlighter-rouge">#use</code> but loads the file like it was a module (name of file as a module name)</li>
  <li><code class="highlighter-rouge">#load "blah.cmo"</code>,<code class="highlighter-rouge">#load "blahlib.cma"</code> - load a compiled binary or library file.</li>
  <li><code class="highlighter-rouge">#show</code> - shows the type for an entity (variable or module).</li>
  <li><code class="highlighter-rouge">#require</code> - loads a library (does not <code class="highlighter-rouge">open</code> it, just loads the module)</li>
  <li><code class="highlighter-rouge">#use_output "dune top"</code> - like the shell <code class="highlighter-rouge">xargs</code> command - run a command and assume output is top loop input commands.</li>
</ul>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
