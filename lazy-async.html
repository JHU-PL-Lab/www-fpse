<!DOCTYPE HTML>
<!--
Solarize by TEMPLATED
templated.co @templatedco
Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
<head>
 <title>Functional Programming and Software Engineering</title>
 <meta http-equiv="content-type" content="text/html; charset=utf-8" />
 <meta name="description" content="" />
 <meta name="keywords" content="" />
 <!--[if lte IE 8]><script src="/pl/css/ie/html5shiv.js"></script><![endif]-->
 <script src="/pl/js/jquery.min.js"></script>
 <script src="/fpse/js/jquery.dropotron.min.js"></script>
 <script src="/fpse/js/skel.min.js"></script>
 <script src="/fpse/js/skel-layers.min.js"></script>
 <script src="/fpse/js/init.js"></script>
 <noscript>
  <link rel="stylesheet" href="/fpse/css/skel.css" />
  <link rel="stylesheet" href="/fpse/css/style.css" />
 </noscript>
 <!--[if lte IE 8]><link rel="stylesheet" href="/fpse/css/ie/v8.css" /><![endif]-->
</head>
<body>

 <!-- Header Wrapper -->
  <div class="wrapper style1">
  
  <!-- Header -->
   <div id="header">
    <div class="container">
      
     <!-- Logo -->
      <h1><a href="/fpse/index.html" id="logo">FPSE</a></h1>
     
     <!-- Nav -->
      <nav id="nav">
       <ul>
          <li><a href="/fpse/logistics.html">Logistics</a></li>
          <li><a href="/fpse/dateline.html">Dateline</a></li> <!-- converted; don't edit .html edit .md -->
          <li><a href="/fpse/coding.html">Coding</a>
          <li><a href="/fpse/assignments/">Assignments</a>
          <li><a href="https://piazza.com/class/kd4zpku2vbg1az">Piazza</a></li>
          <li><a href="/fpse/contact.html">Contact Us</a></li>
      </ul>
</nav>
</div>
</div>


<!-- close-out code before the standard footer .. use to glue in raw html. -->
</div>
<!-- Main -->
<div id="main" class="wrapper style4">
<!-- Content -->
<div id="content" class="container">
<section>

<link rel="stylesheet" href="/fpse/css/friendly.css" />
<meta charset="utf-8" />
    <h2 id="lazy-data-structures">Lazy Data Structures</h2>

<ul>
  <li>OCaml is by default eager
    <ul>
      <li>function parameters are evaluated to values before calling functions</li>
      <li>Pairs, records, and variants all have their internals computed to values recursively.</li>
    </ul>
  </li>
  <li>But, sometimes laziness can be both useful and more efficient
    <ul>
      <li>for lazy funcation call, no need to compute arguments that are not used</li>
      <li>It allows for construction of “infinite” lists, etc
        <ul>
          <li>Don’t compute the nth element until it is asked for</li>
          <li>But, once it is computed, cache it (a form of memoizing)</li>
          <li>Just don’t ask for all infinitely many elements!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="super-simple-encoding-of-laziness-in-ocaml">Super simple encoding of laziness in OCaml</h4>

<ul>
  <li>OCaml has no built-in Laziness (Haskell does)</li>
  <li>But it can be encoded via a <em>thunk</em></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">frozen_add</span> <span class="o">=</span> <span class="k">fun</span> <span class="bp">()</span> <span class="o">-&gt;</span> <span class="n">printf</span> <span class="s2">"Have a smiley day!</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span>
<span class="k">let</span> <span class="n">thaw</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span> <span class="bp">()</span>
<span class="n">thaw</span> <span class="n">frozen_add</span><span class="p">;;</span> <span class="c">(* 4+3 not computed until here *)</span>
</code></pre></div></div>

<ul>
  <li>This encoding is in fact just “call by name”, laziness means memoizing the result.</li>
</ul>

<h4 id="the-baselazy-module">The <code>Base.Lazy</code> module</h4>

<ul>
  <li><code>Base.Lazy</code> is a much more usable sugar for the above</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">open</span> <span class="nc">Lazy</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="k">lazy</span><span class="p">(</span><span class="n">printf</span> <span class="s2">"Have a smiley day!</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">l</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">lazy_t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">lazy</span><span class="o">&gt;</span> <span class="c">(* lazy_t is the wrapper type *)</span>
<span class="o">#</span> <span class="n">force</span> <span class="n">l</span><span class="p">;;</span>
<span class="nc">Have</span> <span class="n">a</span> <span class="n">smiley</span> <span class="n">day</span><span class="o">!</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="n">lv</span> <span class="o">=</span>  <span class="p">(</span><span class="n">force</span> <span class="n">lv</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">force</span> <span class="n">lv</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">f</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">lazy_t</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">f</span> <span class="n">l</span><span class="p">;;</span>
<span class="nc">Have</span> <span class="n">a</span> <span class="n">smiley</span> <span class="n">day</span><span class="o">!</span> <span class="c">(* this is printed only once, the 2nd force uses cached 5 value *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>

<ul>
  <li>Fact: laziness is just a “wrapper” on a computation</li>
  <li>So: Lazy is in fact (yet) another monad - !
    <ul>
      <li>We won’t get into <code>Lazy.bind</code> etc here but lets make an infinite stream of fib’s.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">open</span> <span class="nc">Core</span>
<span class="k">open</span> <span class="nc">Lazy</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">stream</span> <span class="nn">Lazy</span><span class="p">.</span><span class="n">t</span> <span class="c">(* List MUST be infinite *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">all_ones</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="k">lazy</span><span class="p">(</span><span class="n">all_ones</span><span class="p">))</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">ints</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">n</span><span class="o">,</span><span class="k">lazy</span><span class="p">(</span><span class="n">ints</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

<span class="c">(* Code to get the nth element of a lazy list *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">nth</span> <span class="p">(</span><span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">stream</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span><span class="k">'</span><span class="n">a</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">hd</span>
  <span class="k">else</span> <span class="n">nth</span> <span class="p">(</span><span class="n">force</span> <span class="n">tl</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c">(* A more interesting example - shows memoization, this is not exponential *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stream</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">fib_rest</span> <span class="p">(</span><span class="nc">Cons</span><span class="p">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">tl</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">stream</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">)</span> <span class="o">=</span> 
   <span class="k">let</span> <span class="nc">Cons</span><span class="p">(</span><span class="n">hd'</span><span class="o">,_</span><span class="p">)</span> <span class="o">=</span> <span class="n">force</span> <span class="n">tl</span> <span class="k">in</span>
    <span class="nc">Cons</span> <span class="p">(</span><span class="n">hd</span> <span class="o">+</span> <span class="n">hd'</span><span class="o">,</span> <span class="k">lazy</span><span class="p">(</span><span class="n">fib_rest</span> <span class="p">(</span><span class="n">force</span> <span class="n">tl</span><span class="p">)))</span> <span class="k">in</span>
  <span class="nc">Cons</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">lazy</span><span class="p">(</span><span class="nc">Cons</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">lazy</span><span class="p">(</span><span class="n">fib_rest</span> <span class="n">fib</span><span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li>One thing not clear from the code is that a <code>Lazy</code> will not be recomputed</li>
  <li>Once the list is “unrolled” by one call it doesn’t need to be “re-unrolled”</li>
  <li>This is a form of caching / memoization built into <code>Lazy</code>
    <ul>
      <li>(but not in our crude encoding of it above)</li>
    </ul>
  </li>
  <li>Note that becuase of that the above nth function will in fact be linear, not exponential</li>
</ul>

<h2 id="asynchronous-programming">Asynchronous Programming</h2>

<p>Concurrency is needed for two main reasons</p>
<ol>
  <li>You want to run things in parallel for speed gain (multi-core, cluster, etc)</li>
  <li>You are waiting for a result from an I/O action
    <ul>
      <li>Disk read/write, network request, remote API call, etc</li>
      <li>(Sometimes also awaiting for internal actions such as time-outs)</li>
    </ul>
  </li>
</ol>

<p>In OCaml</p>
<ul>
  <li>Concurrency for speed gain is a work in progress, look for a release in a year or two</li>
  <li>Concurrency to support asynchronous waiting: <code>Async</code> library (which is based on the <code>Lwt</code> library)</li>
</ul>

<p>Local concurrency for speed</p>
<ul>
  <li>This is usually done via <em>threads</em></li>
  <li>fork off another computation with its own runtime stack etc but share the heap</li>
  <li>But, threads are notoriously difficult to debug
    <ul>
      <li>100’s of patches have been added to help (channels, monitors, locks, ownership types, etc etc etc) but still hard</li>
    </ul>
  </li>
  <li>So, better to use a simpler system focused on waiting for I/O if that is all you really need</li>
</ul>

<p><a name="async"></a></p>
<h3 id="async"><code>Async</code></h3>

<ul>
  <li><code>Async</code> is another Jane Street library</li>
  <li>It is based on the notion of a <em>promise</em></li>
  <li>Promises have been around for a very long time but are gaining in popularity</li>
  <li>Many languages have libraries implementing some form</li>
  <li>In <code>Async</code> they are called deferreds, of type <code>Deferred.t</code></li>
</ul>

<h4 id="deferreds">Deferreds</h4>

<ul>
  <li>A <code>Deferred.t</code> is an action returning a result</li>
  <li>Until the action is forced, it won’t run (like laziness)</li>
  <li>When it is forced a result will be returned which is an <code>option</code>
    <ul>
      <li><code>None</code> will mean failure; I/O always needs failure case</li>
    </ul>
  </li>
  <li>Here is an example using <code>Async.Reader.file_contents</code>
    <ul>
      <li>reads a whole file into a string</li>
      <li>but, calls to it <em>immediately</em> return</li>
      <li>The file is not in fact read until the deferred is run</li>
      <li>This is a special file operation function part of <code>Async</code> to support deferreds.</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">"async"</span><span class="p">;;</span>
<span class="o">#</span> <span class="o">#</span><span class="n">require</span> <span class="s2">"ppx_jane"</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">open</span> <span class="nc">Async</span><span class="p">;;</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">eventual_string</span> <span class="o">=</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="s2">"update.py"</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">eventual_string</span> <span class="o">:</span> <span class="kt">string</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">eventual_string</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span> <span class="c">(* nothing has been done to force the Deferred to run *)</span>
<span class="o">#</span> <span class="n">eventual_string</span><span class="p">;;</span> <span class="c">(* .. utop forces it to run implicitly - like Lazy.force but implicit *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span>
<span class="s2">"#!/usr/bin/python</span><span class="err">\</span><span class="s2">...</span><span class="se">\n\n</span><span class="s2">"</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">eventual_string</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span>
<span class="nc">Some</span>
 <span class="s2">"#!/usr/bin/python</span><span class="err">\</span><span class="s2">...</span><span class="se">\n\n</span><span class="s2">"</span>
</code></pre></div></div>
<ul>
  <li>An odd thing about the above is let-defining a <code>Deferred</code> will not run it
    <ul>
      <li>but, if it is directly fed into the top loop it will implicitly run</li>
      <li>this is becuase <code>utop</code> when it sees a direct deferred will run it and return the result</li>
    </ul>
  </li>
</ul>

<p>(Note the <code>Async</code> examples we base on <a href="https://dev.realworldocaml.org/concurrent-programming.html">Real World OCaml Chapter 15</a> which has a lot more than what we are covering)</p>

<h4 id="the-async-monad">The Async monad</h4>

<ul>
  <li><code>Lazy</code> and <code>Option</code> we saw it was often not hard to avoid the <code>bind</code>/<code>return</code> view</li>
  <li>This is also possible with <code>Async</code> but often I/O actions are sequenced and <code>bind</code>/<code>return</code> is thus very helpful.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">uppercase_file</span> <span class="p">(</span><span class="n">filename</span> <span class="o">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">unit</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span><span class="o">%</span><span class="n">bind</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="n">filename</span> <span class="k">in</span>
        <span class="nn">Writer</span><span class="p">.</span><span class="n">save</span> <span class="n">filename</span> <span class="o">~</span><span class="n">contents</span><span class="o">:</span><span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">uppercase</span> <span class="n">s</span><span class="p">)</span>
<span class="o">#</span> <span class="n">uppercase_file</span> <span class="s2">"t.txt"</span> <span class="c">(* this will implicitly run the Deferred above *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Reader</span><span class="p">.</span><span class="n">file_contents</span> <span class="s2">"t.txt"</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"HELLO FOLKS!"</span>
</code></pre></div></div>

<p><code>Deferred.return</code> does the normal wrapping thing, it defers a normal value</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">return</span><span class="p">(</span><span class="mi">10</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">d</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="n">d</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>

<h3 id="ivars">Ivars</h3>

<ul>
  <li>Deferred’s are in fact implemented with <code>Ivars</code></li>
  <li>Think of it as “the implementation of a promise”</li>
  <li>Often you can use library functions that are <code>Deferred</code> aware</li>
  <li>But using <code>Ivar</code> you can write your own</li>
  <li>Here is an example based on RWOC:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="k">let</span> <span class="n">ivar</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="c">(* Create an Ivar; think of it like a ref cell *)</span>
<span class="k">val</span> <span class="n">ivar</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak1</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
  <span class="p">{</span><span class="nn">Async_kernel__</span><span class="p">.</span><span class="nn">Types</span><span class="p">.</span><span class="nn">Ivar</span><span class="p">.</span><span class="n">cell</span> <span class="o">=</span> <span class="nn">Async_kernel__Types</span><span class="p">.</span><span class="nn">Cell</span><span class="p">.</span><span class="nc">Empty</span><span class="p">}</span>
<span class="o">#</span> <span class="k">let</span> <span class="n">def</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">read</span> <span class="n">ivar</span>  <span class="c">(* Read the contents of the promise -- an empty one now! *)</span>
<span class="k">val</span> <span class="n">def</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak2</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">abstr</span><span class="o">&gt;</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">def</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">_weak3</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">None</span> <span class="c">(* It is nothing.  Typing `def;;` now will loop forever! *)</span>
<span class="o">#</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">fill</span> <span class="n">ivar</span> <span class="s2">"Hello"</span> <span class="c">(* Fill a promise explicitly *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="o">#</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">peek</span> <span class="n">def</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">option</span> <span class="o">=</span> <span class="nc">Some</span> <span class="s2">"Hello"</span> <span class="c">(* Indeed it got filled *)</span>
<span class="n">def</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="s2">"Hello"</span>
</code></pre></div></div>

<h3 id="making-the-monadic-bind-and-return">Making the monadic <code>bind</code> and return`</h3>

<ul>
  <li>Let us show how <code>bind</code> can be defined with <code>Ivar</code>s</li>
  <li>This will give us the complete picture of the monad</li>
  <li>Uses <code>upon : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit</code>
    <ul>
      <li>takes an <code>Ivar</code> (a promise), and when it is fulfilled runs the <code>('a -&gt; unit)</code> code</li>
    </ul>
  </li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bind'</span> <span class="p">(</span><span class="n">d</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="n">f</span><span class="o">:</span><span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span><span class="p">))</span> <span class="o">:</span> <span class="k">'</span><span class="n">b</span> <span class="nn">Deferred</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
    <span class="n">upon</span> <span class="n">d</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="c">(* Run this first function when d is determined *)</span>
             <span class="n">upon</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="c">(* then run f x *)</span>
                  <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nn">Ivar</span><span class="p">.</span><span class="n">fill</span> <span class="n">i</span> <span class="n">y</span><span class="p">)</span>
           <span class="p">);</span> <span class="c">(* call the promise "filled" when f x is determined *)</span>
    <span class="nn">Ivar</span><span class="p">.</span><span class="n">read</span> <span class="n">i</span> <span class="c">(* this returns a Deferred so users can pull on it *)</span>
</code></pre></div></div>

<p>We covered the basic concepts of <code>Async</code> above. See <a href="https://dev.realworldocaml.org/concurrent-programming.html">Real World OCaml Chapter 15</a> for larger examples including asynchronous http.</p>
      
          </section>
        </div>
      </div>

				<div id="copyright">
					Web Design: <a href="http://templated.co">TEMPLATED</a> Images: <a href="http://unsplash.com">Unsplash</a> (<a href="http://unsplash.com/cc0">CC0</a>)
				</div>			


   </body>
</html>
